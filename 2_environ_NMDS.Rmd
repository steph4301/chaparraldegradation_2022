

```{r install libraries}

############# load libraries 

library(tidyverse) # includes ggplot2 - data visulization, dplyr, tidyr, readr, purr, tibble, stringr, forcats
library(here)
library(cluster)
library(vegan)
library(ggvegan)
library(indicspecies)
library(plotly)
library(gridExtra)
library(calecopal) 
library(gt)

# library(ggpubr) # customize ggplot2 for publication
# library(broom)
# library(AICcmodavg)
# library(readxl) # for .xls and .xlsx sheets
# library(janitor)

# library(multcompView)
# if (!require(devtools)) {
#   install.packages("devtools")
# }
# devtools::install_github("gavinsimpson/ggvegan")
# 
# library(ggpmisc)

# Set seed for analyses
set.seed(3980)
```


```{r load data}

################### load environmental data

extracted_load <- read.csv("~/Dropbox/GRADSCHOOL/Dissertation/R_dissertation/chaparraldegradation_2022/chaparraldegradation_2022/Extracted_Elevation_Slope_Aspect_Hillshade_20m.csv", header = TRUE, na.strings=c("","NA")) %>% 
  dplyr::select(system_ind, aspect, elevation, hillshade, slope, site, southwestness, lat, long, cluster)
# names(extracted_load)

twi_fire_load <- read.csv("~/Dropbox/GRADSCHOOL/Dissertation/R_dissertation/chaparraldegradation_2022/chaparraldegradation_2022/Extracted_Elevation_Slope_Aspect_Hillshade_TWI_Fire_20m.csv", header = TRUE, na.strings = c("", "NA")) %>% 
  dplyr::select(system_ind, twi, fire_event_count, last_fire)

extracted_join <- extracted_load %>% 
  left_join(twi_fire_load, by = "system_ind")

extracted_prep <- extracted_join%>% 
    rename(site_rep = system_ind) %>% 
 filter(site_rep != "1.03") %>% 
# “southwest-ness” is calculated using: cos (aspect - 225°)
      mutate(site_rep = case_when(site_rep == "1.1" ~ "1.10", # old ~ new
                                   site_rep == "2.1" ~ "2.10",
                                   site_rep == "2.2" ~ "2.20",
                                  site_rep == "INT1" ~ "INT1_1",
                                    site_rep == "INT2" ~ "INT2_1",
                                    site_rep == "INT3" ~ "INT3_1",
                                    site_rep == "INT4" ~ "INT4_1",
                                    site_rep == "INT5" ~ "INT5_1",
                                   TRUE ~ site_rep)) %>% 
    mutate(rowname = 1:39) %>% 
     mutate(
      aspect = as.numeric(aspect),
      elevation = as.integer(elevation), # meters
      hillshade = as.numeric(hillshade), 
      slope = as.numeric(slope), # degrees
      site_rep = as.character(site_rep), 
      site = as.character(site), 
      rowname = as.character(rowname)
      ) %>% 
  rename(plant_cluster = cluster)


extracted_prep$site_rep <- gsub("\\.", "_", extracted_prep$site_rep)

# view(extracted_prep)
# length(extracted_prep$site_rep)    # n = 39


############# load plant clusters (n = 5)

cluster <- extracted_prep %>% dplyr::select(rowname, plant_cluster)
 
```



```{r}

##########  Prepare environ data for an NMDS (numbers only matrix)

df <- extracted_prep %>%  
  dplyr::select(!c("site", "site_rep", "aspect", "last_fire", "rowname")) 

# names(df)
# [1] "elevation"        "hillshade"        "slope"           
# [4] "southwestness"    "lat"              "long"            
# [7] "plant_cluster"          "twi"              "fire_event_count"

```

### means (SD)
```{r}

######### Table of means and SD of environmental variables

means <- df %>% 
  group_by(plant_cluster) %>% 
   summarize(elev_mean = mean(elevation),
            elev_sd = sd(elevation),
            hill_mean = mean(hillshade),
            hill_sd = sd(hillshade),
            slope_mean = mean(slope),
            slope_sd = sd(slope),
            sw_mean = mean(southwestness),
            sw_sd = sd(southwestness),
            fire_mean = mean(fire_event_count),
            fire_sd = sd(fire_event_count),
            lat_mean = mean(lat),
            lat_sd = sd(lat),
             long_mean = mean(long),
            long_sd = sd(long)
            ) %>% 
  pivot_longer(cols = 2:15, values_to = "mean", names_to = "variable") %>% 
  pivot_wider(id_cols = plant_cluster, names_from = variable, values_from = mean)

means_combined <- df %>%
  group_by(plant_cluster) %>%
  summarize(
    elev = paste0(round(mean(elevation), 2), " ± ", round(sd(elevation), 2)),
    hillshade = paste0(round(mean(hillshade), 2), " ± ", round(sd(hillshade), 2)),
    slope = paste0(round(mean(slope), 2), " ± ", round(sd(slope), 2)),
    southwestness = paste0(round(mean(southwestness), 2), " ± ", round(sd(southwestness), 2)),
    fire_events = paste0(round(mean(fire_event_count), 2), " ± ", round(sd(fire_event_count), 2)),
    latitude = paste0(round(mean(lat), 4), " ± ", round(sd(lat), 4)),
    longitude = paste0(round(mean(long), 4), " ± ", round(sd(long), 4))
  )

# Print as a gt table
means_combined %>%
  gt() %>%
  tab_header(
    title = "Summary Statistics by Cluster",
    subtitle = "Mean ± Standard Deviation for Elevation, Hillshade, Slope, Southwestness, Fire Events, and Coordinates"
  ) %>%
  cols_align(
    align = "center", # Center alignment
    columns = "plant_cluster" # Specify the "cluster" column
  ) %>% 
  tab_options(
    table.width = pct(100) # Make the table width 100%
  )

```



### Hierarchical Agglomerative Clustering

```{r}

# NAME data set
df <- df # from two chunks above


# Calculate distance measure matrix, Bray is the best for community data
d <- vegdist(df, method = "bray") 


# Check which method produces best clustering
m <- c( "average", "single", "complete", "ward", "gaverage")
names(m) <- c( "average", "single", "complete", "ward", "gaverage")

# function to compute coefficient
ac <- function(x) {
  agnes(d, method = x, diss = TRUE, par.method = -0.25)$ac}

# Best method?
map_dbl(m, ac)

# Best method is g average at 0.9658701  (flexible beta)



#########################
#### Find optimal number of clusters

# Scree plot  
fviz_nbclust(df, FUN = hcut, diss = d, method = "wss") # 2 groups

# Average Silhouette
# Measures how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The Average Silhouette Width is the mean of all silhouette scores within a cluster or across all clusters.
# S ≈ 1: The point is well clustered
fviz_nbclust(df, FUN = hcut, diss = d, method = "silhouette") # 2 groups

# Gap Stat
# Compares the total within-cluster variation for different numbers of clusters with their expected values under a null reference distribution of the data (i.e., uniformly distributed points).
# The optimal number of clusters is the smallest k such that the Gap Statistic is maximized or the first local maximum occurs, indicating that adding more clusters does not significantly improve the clustering.
fviz_nbclust(df, FUN = hcut, diss = d, method = "gap_stat")
# 2 gruops is best

# Above tests suggest at least two, but are also not conclusive...

# Define function to compute Mantel correlation tests for different cluster assignments
compute_mantel_correlation <- function(hclust_obj, distance_matrix) {

  # Initialize variables to store results
  mantel_correlation <- numeric(length = length(hclust_obj$order) - 1)
  
  # Iterate through different numbers of clusters
  for (k in 2:length(hclust_obj$order)) {
    cluster_assignments <- cutree(hclust_obj, k = k)
    cluster_distance <- as.matrix(dist(cluster_assignments))
    mantel_result <- mantel(cluster_distance, distance_matrix)
    mantel_correlation[k - 1] <- mantel_result$statistic
    # Print Mantel correlation for each number of clusters
    print(paste("Mantel Correlation (r) for", k, "clusters:", mantel_result$statistic))
  }
  
  return(mantel_correlation)
}

# Create Clusters and then run tests
Hclust.result <- agnes(d, method = "gaverage", par.method = -0.25) # Perform hierarchical clustering
mantel_results <- compute_mantel_correlation(Hclust.result, d)

# Find the optimal number of clusters based on the largest Mantel correlation, r
optimal_clusters <- which.max(mantel_results) + 1  # Add 1 to convert index to number of clusters
print(paste("Optimal Number of Clusters:", optimal_clusters)) # 2 groups


######## Use ISA to determine optimal clusters

# Function to run multipatt() on k iterations of clusters and extract ISA values
run_multipatt_and_extract_ISA <- function(data, max_clusters) {
  
  # Initialize an empty dataframe to store ISA values
  isa_df <- data.frame(Species = colnames(data))
  
  # Iterate through different numbers of clusters
  for (k in 2:max_clusters) {
    cluster_assignments <- cutree(agnes(vegdist(data, method = "bray"), method = "gaverage", par.method = -0.25), k = k)
    
    # Convert cluster assignments to a factor
    cluster_factor <- as.factor(cluster_assignments)
    
    # Run multipatt() with the cluster factor
    multipatt_result <- multipatt(data, cluster = cluster_factor, duleg = FALSE)
    
    # Extract ISA values and p-values
    isa_values <- multipatt_result$sign$index
    p_values <- multipatt_result$sign$p.value
    
    # Filter by p-value <= 0.05
    significant_isa_values <- ifelse(p_values <= 0.05, isa_values, NA)
    
    # Extract ISA values for each species and add to the dataframe
    isa_df[[as.character(k)]] <- significant_isa_values
  }
  
  return(isa_df)
}


max_clusters <- 10  # Maximum number of clusters to iterate through

# Run multipatt() and extract ISA values for each species
isa_data <- run_multipatt_and_extract_ISA(df, max_clusters)

# Frequency distribution of number of significant ISA in each cluster step
frq.ISA <- isa_data %>%
  pivot_longer(cols = 2:10, names_to = "Cluster", values_to = "ISA_SCORE") %>%
  drop_na() %>% 
  group_by(Cluster) %>% 
  summarise(count = n()) %>% 
  arrange(as.numeric(Cluster))


#######
# Now calculate the sum of the differences in ISA scores from one step to the next
# When the indicator values of all species are decreasing, the clustering method does not explain anything more. 
# Take difference of species index values

isa.diff.data <- isa_data %>% 
  mutate(k2 = `2`-`3`) %>% 
  mutate(k3 = `3`-`4`) %>%
  mutate(k4 = `4`-`5`) %>%
  mutate(k5 = `5`-`6`) %>%
  mutate(k6 = `6`-`7`) %>%
  mutate(k7 = `7`-`8`) %>%
  mutate(k8 = `8`-`9`) %>%
  mutate(k9 = `9`-`10`) 

isa.diff.sum <- isa.diff.data %>%
  select(Species, 11:18) %>% 
  pivot_longer(cols = 2:9, names_to = "Cluster", values_to = "ISA_SCORE") %>% 
  drop_na() %>%
  filter(ISA_SCORE <= 0)%>% 
  arrange(by = Cluster) %>% 
  group_by(Cluster) %>% 
  summarise(sum = sum(ISA_SCORE))
# view(isa.diff.sum)

ggplot(isa.diff.sum, # figure is blank because 2 clusters best describes the data
       aes(x = Cluster,
           y = sum)) +
  geom_bar(stat = "identity") +
  labs(title = "", x = "Cluster", y = "Value") +
  theme_minimal()



# Beta average
hcluster.environ <- agnes(d, method = "gaverage", par.method = -0.25) # Perform hierarchical clustering (using average linkage)
 
plot(hcluster.environ)
rect.hclust(hcluster.environ, k = 2)

# Cut tree into groups
sub_grp <- cutree(hcluster.environ, k = 2)


# Number of members in each cluster
table(sub_grp)


# Combine group labels into species matrix
# temp.df <- extracted_prep %>%  
#   rownames_to_column() 

my_groups <- as.data.frame(sub_grp) %>% 
  rownames_to_column()

environ.subgrp.df <- left_join(extracted_prep, my_groups, by = "rowname") %>% 
  dplyr::select(rowname, sub_grp, site_rep)

# Create a combined label
combined_labels <- paste(environ.subgrp.df$sub_grp, environ.subgrp.df$site_rep, sep = " - ")

# Plot the hierarchical clustering dendrogram with the combined labels
plot(hcluster.environ, labels = combined_labels, main = "Hierarchical Clustering Dendrogram")
rect.hclust(hcluster.environ, k = 2)

################
# Indicator Species Analysis

ISA.abs.cover <- multipatt(x = df, cluster = sub_grp, duleg = FALSE)

# A = The values are the **specificity** component of IV for that species in that combination of groups.
# B = The values are the **fidelity** component of IV for that species in that combination of groups
summary(ISA.abs.cover, indvalcomp=TRUE)





##############
# Does community composition differ among groups?

# Check for homogeneity of dispersion among groups, required for MANOVA
trt <- as.character(my_groups$sub_grp)

# There is significant dispersion within groups, and groups are unbalanced --- cannot use MANOVA (adonis)
anova(betadisper(d, trt))

mod <- betadisper(d, trt)

TukeyHSD(mod)
# $group
#            diff         lwr          upr     p adj
# 2-1 -0.01106682 -0.01973743 -0.002396211 0.0137766

boxplot(mod)

plot(mod)

# Best option is MRPP -->  MRPP stands for Multi-Response Permutation Procedure, 
# a non-parametric statistical test used to assess whether there is a 
# significant difference between two or more groups based on multivariate data. 
# It is similar to PERMANOVA but uses a different approach to compare the within-group 
# and between-group distances.
# 
# The key idea is simple: if groups differ, the mean within-group dissimilarity should be smaller
# than the mean dissimilarity among randomly selected groups of the same size.
results <- mrpp(d, grouping = sub_grp, permutations = 999)
results



```


### NMDS

#### Visualize community differences by environmental variables

```{r nmds by species percent cover}
          
# the AUTOTRANSFORM = F skips the automatic data transformations and uses the input data as is
# - when the raw data contains the information you need (e.g., abundance)
# - when you have a small number of samples or small number of variables
# - when you want to preserve the original scale of the data (e.g., interested in the absolute differences betwen two sets of measurements)

mds <- metaMDS(df, 
                       autotransform = TRUE, # FALSE or TRUE
                       distance = "bray",   # bray or "raup" - Bray is the best for community data
                      k = 3, #dimentions
                      trymax = 400) # this is more appropriate for my data

mds$stress
# k = 2D: stress test = 0.08459596
# k = 3D: stress test = 0.05561168
# k = 4D: stress test = 0.03806059


stressplot(mds) # A Shepard plot compares the observed dissimilarities (distances in the original data) to the fitted distances (distances in the reduced NMDS space).
gof <- goodness(mds) # Higher values indicate points that are poorly represented in the reduced-dimensional space, contributing more to the stress
gof
# min(gof) = 0.004642076
# max(gof) = 0.01496991 <- relationships in your data are well represented!

plot(mds, display = "sites", type = "none")
points(mds, display = "sites", cex = 2* # 2x for visibility
         gof/mean(gof)) # standardized by the mean
# larger points = less well represented

```


```{r environ nmds, include=FALSE}

### Plot NMDS

######## don't run becuase ENVIRON variables are of different units. Run PCA instead.


mds.df <- vegan::scores(mds, display = "sites") %>% 
  as.data.frame() %>% 
  rownames_to_column("rowname") %>% 
  full_join(cluster, by = "rowname") %>% 
    mutate(plant_cluster = as.character(plant_cluster)) %>% 
  full_join(my_groups, by = "rowname") %>% 
  rename(environ_cluster = sub_grp) %>% 
     mutate(environ_cluster = as.character(environ_cluster))

# uses the RAUP-CRICK dissimilarity index to calculate pairwise dissimilarities
# - adjusts for spp richness
# - downweights importance of rare spp 
# - more useful when interested in community STRUCTURE rather than individual species
# - takes into account differences in species evenness
# abcover_byspecies_NMDS <- metaMDS(abcover_byspecies_nmdsprep_num, distance = "raup") 


ggplot(mds.df,
       aes(x = NMDS1,
           y = NMDS2,
           color = environ_cluster, 
           shape = environ_cluster)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse() + 
  theme(axis.title = element_text(size = 20)) +
  theme(axis.text = element_text(size = 16))


ggplot(mds.df,
       aes(x = NMDS2,
           y = NMDS3,
           color = environ_cluster,
           shape = environ_cluster)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse() + 
  theme(axis.title = element_text(size = 20)) +
  theme(axis.text = element_text(size = 16))


p <- plot_ly(mds.df,
        x = ~NMDS1,
        y = ~NMDS2,
        z = ~NMDS3,
        type =  "scatter3d",
        color=mds.df$envion_cluster)
p

```

### PCA

```{r}

########### Environ PCA

birdPCA <- rda(df)

PCAscores <- vegan::scores(birdPCA, display = "sites") %>% 
  as.data.frame() %>% 
  rownames_to_column("site") %>% 
    mutate(rowname = 1:39) %>% 
    mutate(rowname = as.character(rowname)) %>% 
  full_join(cluster, by = "rowname") %>% 
   full_join(my_groups, by = "rowname") %>% 
  rename(environ_cluster = sub_grp) %>% 
     mutate(environ_cluster = as.character(environ_cluster))

PCAvect <- scores(birdPCA, display = "species") %>% 
  as.data.frame()

plot_PCA <- ggplot() +
  geom_point(data = PCAscores, 
             aes(x = PC1, y = PC2, color = environ_cluster, shape = environ_cluster, size = 3)) +
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  geom_segment(data = PCAvect, aes(x = 0, y = 0, xend = PC1, yend = PC2), arrow = arrow(length = unit(0.2, "cm"))) +
  geom_text(data = PCAvect, aes(x = PC1, y = PC2, label = rownames(PCAvect))) +
  theme_bw() +
  labs(x = "PC1",
       y = "PC2",
       title = "Principal Components Analysis") 


plot_PCA

```

### boxplots

- by environ clusters (n = 2)

```{r}

df <-  extracted_prep %>% 
   full_join(my_groups, by = "rowname") %>% 
  rename(environ_cluster = sub_grp) %>% 
     mutate(environ_cluster = as.character(environ_cluster)) %>% 
   mutate(plant_cluster = as.character(plant_cluster))


######### take home
# Group 1 is at lower elevation, more shady, more negative TWI, higher lat, less negative long, one fire. 14 or 14 transects burned in 2007. The three transects that burned in 2003 and 2007 were INT 1, INT2, and 1.10. === GROUP 1 includes transects from Site 1 and INT 1, 3. (n = 14 transects)

length(
  df %>%  
    filter(environ_cluster == "1") %>% 
    filter(last_fire == "2007") %>% 
         pull(environ_cluster)
       )

# Group 2 at higher elevation, less shady, less negative TWI, lower lat, more negative long, two fires. 21 transects in Group 2 burned in 2003 and 2007. Most transects are from Site 2. 4 transects are not from Site 2: INT1, INT2, INT4, 1.10. Only 3 burned in 2007 only (INT1, INT2, 1.10) (n = 25 transects) INT4 burned twice.

length(
  df %>%  
    filter(environ_cluster == "2") %>% 
         pull(environ_cluster)
       )

# southwestness, slope was the same between Group 1 and Group 2

# I'm guessing elevation, shade, twi are big environmental factors as is fire history. I'm guessing lat and long are less predictive and more a result of our site locations.

########################################## elevation

hist(df$elevation)
shapiro.test(df$elevation) # not normal

kruskal.test(elevation ~ environ_cluster, data = df)
pairwise.wilcox.test(df$elevation, df$environ_cluster, p.adjust.method = "BH")
#   1      
# 2 3.2e-07

boxplot(elevation ~ environ_cluster, df)


########################################## hillshade
hist(df$hillshade)
shapiro.test(df$hillshade) # normally distributed

summary(aov((hillshade ~ environ_cluster), data = df))
#                Df Sum Sq Mean Sq F value Pr(>F)  
# environ_cluster  1   1450  1450.1   4.249 0.0463 *
# Residuals       37  12627   341.3                      

TukeyHSD(aov(hillshade ~ environ_cluster, df), conf.level=.95) 
# $environ_cluster
#         diff       lwr      upr     p adj
# 2-1 12.71143 0.2168144 25.20604 0.0463482 <- sig

boxplot(hillshade ~ environ_cluster, df)



########################################## southwestness
hist(df$southwestness)
shapiro.test(df$southwestness) # <- not normal

kruskal.test(southwestness ~ environ_cluster, data = df) # p-value = 0.6818

pairwise.wilcox.test(df$southwestness, df$environ_cluster, p.adjust.method = "BH")
boxplot(southwestness ~ environ_cluster, df)


########################################## twi
hist(df$twi)
shapiro.test(df$twi) # 0.033 <- not normal

kruskal.test(twi ~ environ_cluster, data = df) 
# Kruskal-Wallis chi-squared = 4.57, df = 1, p-value = 0.03254
pairwise.wilcox.test(df$twi, df$environ_cluster, p.adjust.method = "BH")

boxplot(twi ~ environ_cluster, df)

########################################## slope
hist(df$slope)
shapiro.test(df$slope) # <- normal

summary(aov(slope ~ environ_cluster, df))
TukeyHSD(aov(slope ~ environ_cluster, df), conf.level = .95) # not sig diff
# $environ_cluster
#          diff       lwr      upr     p adj
# 2-1 -3.707741 -8.831239 1.415758 0.1510141

boxplot(slope ~ environ_cluster, df)

########################################## lat
hist(df$lat)
shapiro.test(df$lat) # not normal

kruskal.test(lat ~ environ_cluster, data = df) 
# Kruskal-Wallis chi-squared = 13.181, df = 1, p-value = 0.0002828
pairwise.wilcox.test(df$lat, df$environ_cluster, p.adjust.method = "BH")

boxplot(lat ~ environ_cluster, df)

########################################## long
hist(df$long)
shapiro.test(df$long) # not normal

kruskal.test(long ~ environ_cluster, data = df) 
pairwise.wilcox.test(df$long, df$environ_cluster, p.adjust.method = "BH")
#  1     
# 2 0.0022

boxplot(long ~ environ_cluster, df)

########################################## fire_event_count
hist(df$fire_event_count)
shapiro.test(df$fire_event_count) # not normal

kruskal.test(fire_event_count ~ environ_cluster, data = df) 
pairwise.wilcox.test(df$fire_event_count, df$environ_cluster, p.adjust.method = "BH")
#   1      
# 2 1.7e-07

boxplot(fire_event_count ~ environ_cluster, df)

```

- by plant clusters (n = 5)

```{r}

########################################## elevation

hist(df$elevation)
shapiro.test(df$elevation)
# Shapiro-Wilk normality test
# 
# data:  df$elevation
# W = 0.88322, p-value = 0.0007544 <-- not normally distributed

kruskal.test(elevation ~ plant_cluster, data = df)
pairwise.wilcox.test(df$elevation, df$plant_cluster, p.adjust.method = "BH")
# data:  df$elevation and df$cluster 
# 
#   1       2         3         4    
# 2 0.036   -         -        -    
# 3 0.366   0.036     -        -    
# 4 0.351  0.181      0.151     -    
# 5 0.366   0.366     0.221     0.943
boxplot(elevation ~ plant_cluster, df)
## 2 is diff from 1 and 3

########################################## hillshade
hist(df$hillshade)
shapiro.test(df$hillshade)
# Shapiro-Wilk normality test
# 
# data:  df$hillshade
# W = 0.97317, p-value = 0.467 <-- normally distributed
summary(aov((hillshade ~ plant_cluster), data = df))
#  Df Sum Sq Mean Sq F value Pr(>F)   
# cluster      4   4559  1139.7   4.071 0.0084 **
# Residuals   34   9518   279.9                  

TukeyHSD(aov(hillshade ~ plant_cluster, df), conf.level=.95) 
# $cluster
#           diff         lwr        upr     p adj
# 2-1 -25.126984 -49.4070518 -0.8469164 0.0395528 <-- 2 is shadier than 1
# 3-1  -4.255556 -26.3924005 17.8812893 0.9807491
# 4-1 -20.680556 -44.0914706  2.7303595 0.1045431
# 5-1   2.844444 -24.0286660 29.7175549 0.9980272
# 3-2  20.871429  -2.8715728 44.6144299 0.1072765
# 4-2   4.446429 -20.4887104 29.3815675 0.9854365
# 5-2  27.971429  -0.2394608 56.1823179 0.0528871 <-- not sig. 2 is shadier than 5
# 4-3 -16.425000 -39.2784323  6.4284323 0.2564228 
# 5-3   7.100000 -19.2888706 33.4888706 0.9361425
# 5-4  23.525000  -3.9414074 50.9914074 0.1225369

boxplot(hillshade ~ plant_cluster, df)
# 0 degrees = dark aka. lots of hillshading
# 255 degrees = bright aka. lots of sun exposure


########################################## southwestness
hist(df$southwestness)
shapiro.test(df$southwestness) # <- not normal
kruskal.test(southwestness ~ plant_cluster, data = df)
pairwise.wilcox.test(df$southwestness, df$plant_cluster, p.adjust.method = "BH")
boxplot(southwestness ~ plant_cluster, df)


########################################## twi
boxplot(twi ~ plant_cluster, df)

########################################## slope
boxplot(slope ~ plant_cluster, df)
shapiro.test(df$slope) # <- normal
summary(aov(slope ~ plant_cluster, df))
TukeyHSD(aov(slope ~ plant_cluster, df), conf.level = .95)
# Fit: aov(formula = slope ~ plant_cluster, data = df)
# $cluster
#          diff         lwr       upr     p adj
# 2-1  4.865313  -5.3013433 15.031969 0.6454368
# 3-1  1.879894  -7.3893422 11.149131 0.9765639
# 4-1 -1.014681 -10.8174014  8.788040 0.9981919
# 5-1 11.216590  -0.0358360 22.469017 0.0510664 <- not sig - 5 is steeper than 1
# 3-2 -2.985419 -12.9271919  6.956355 0.9077278
# 4-2 -5.879994 -16.3209440  4.560957 0.4943670
# 5-2  6.351278  -5.4613095 18.163865 0.5395130
# 4-3 -2.894575 -12.4638642  6.674714 0.9054976
# 5-3  9.336696  -1.7129674 20.386359 0.1309924
# 5-4 12.231271   0.7304168 23.732125 0.0324924 <-- 5 is steeper than 4


########################################## lat
boxplot(lat ~ plant_cluster, df)

########################################## long
boxplot(long ~ plant_cluster, df)

########################################## fire_event_count
boxplot(fire_event_count ~ plant_cluster, df)

```
