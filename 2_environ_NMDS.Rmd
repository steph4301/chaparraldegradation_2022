

```{r install libraries}

############# load libraries 

library(tidyverse) # includes ggplot2 - data visulization, dplyr, tidyr, readr, purr, tibble, stringr, forcats
library(here)
library(cluster)
library(vegan)
library(ggvegan)
library(indicspecies)
library(plotly)
library(gridExtra)
library(calecopal) 
library(factoextra)
library(gt)
library(ggrepel) # avoid overlaping labes in ggplot2
library(scales) # for commas in numbers

# library(ggpubr) # customize ggplot2 for publication
# library(broom)
# library(AICcmodavg)
# library(readxl) # for .xls and .xlsx sheets
# library(janitor)

# library(multcompView)
# if (!require(devtools)) {
#   install.packages("devtools")
# }
# devtools::install_github("gavinsimpson/ggvegan")
# 
# library(ggpmisc)
```


```{r}

####################### set basics

# Set seed for analyses
set.seed(3980)


clean_background <- theme(plot.background = element_rect("white"),
        panel.background = element_rect("white"),
        panel.grid = element_line("white"),
        axis.line = element_line("gray25"),
        axis.text = element_text(size = 12, color = "gray25"),
        axis.title = element_text(color = "gray25"),
        legend.text = element_text(size = 12),
        legend.key = element_rect("white"))
```

### load data

- hillshade: higher numbers = more sunny. Lower numbers = more north facing

```{r load data}

################### load environmental data

extracted_load <- read.csv("~/Dropbox/GRADSCHOOL/Dissertation/R_dissertation/chaparraldegradation_2022/chaparraldegradation_2022/Extracted_Elevation_Slope_Aspect_Hillshade_20m.csv", header = TRUE, na.strings=c("","NA")) %>% 
  dplyr::select(system_ind, aspect, elevation, slope, site, lat, long, cluster) %>% 
  mutate(southwestness = cos(225-aspect))
# sort(unique(extracted_load$system_ind))

twi_firecount_solarrad_load <- read.csv("~/Dropbox/GRADSCHOOL/Dissertation/R_dissertation/chaparraldegradation_2022/chaparraldegradation_2022/Extracted_Elevation_Slope_Aspect_Hillshade_20m_20241014_8pm.csv", header = TRUE, na.strings = c("", "NA")) %>% 
  dplyr::select(system_ind, twi, summer_solarradiation, winter_solarradiation, equinox_solarradiation, fire_event_count) %>% 
  mutate(total_solrad = summer_solarradiation + winter_solarradiation + equinox_solarradiation + equinox_solarradiation) 
# sort(unique(twi_firecount_solarrad_load$system_ind))

extracted_join <- extracted_load %>% 
  left_join(twi_firecount_solarrad_load, by = "system_ind")
# sort(unique(extracted_join$system_ind))

extracted <- extracted_join%>% 
    rename(site_rep = system_ind) %>% 
 filter(site_rep != "1.03") %>% 
      mutate(site_rep = case_when(site_rep == "1.1" ~ "1.10", # old ~ new
                                   site_rep == "2.1" ~ "2.10",
                                   site_rep == "2.2" ~ "2.20",
                                  site_rep == "INT1" ~ "INT1_1",
                                    site_rep == "INT2" ~ "INT2_1",
                                    site_rep == "INT3" ~ "INT3_1",
                                    site_rep == "INT4" ~ "INT4_1",
                                    site_rep == "INT5" ~ "INT5_1",
                                   TRUE ~ site_rep)) %>% 
     rownames_to_column() %>% 
     mutate(
      southwestness = as.numeric(southwestness),
      elevation = as.integer(elevation), # meters
      slope = as.numeric(slope), # degrees
      site_rep = as.character(site_rep), 
      site = as.character(site),
      cluster = as.character(cluster),
      fire_event_count = as.integer(fire_event_count),
       rowname = as.character(rowname)
      ) %>% 
  rename(plant_cluster = cluster)


extracted$site_rep <- gsub("\\.", "_", extracted$site_rep)

# length(extracted$site_rep)    # n = 39


############# load plant clusters (n = 5)

# plant_cluster_list <- extracted_prep %>% 
#   dplyr::select(site_rep, plant_cluster)

 
```


### TABLE mean
- environmental means by plant cluster (n = 5)


```{r}

######### Table of means and SD of environmental variables by plant cluster

means <- extracted %>%
   dplyr::select(c("site_rep", "plant_cluster", 
                   "slope", "southwestness", "twi", "fire_event_count", 
                   #"summer_solarradiation", "winter_solarradiation", "equinox_solarradiation",
                   "total_solrad")) %>%
  group_by(plant_cluster) %>% 
  mutate(plant_cluster = factor(plant_cluster, levels = c(1, 3, 2, 4, 5))) %>%  # Reorder plant_cluster
  summarize(
    slope = paste0(round(mean(slope), 2), " ± ", round(sd(slope), 2)), # MEAN becuase normally distributed
    southwestness = paste0(round(median(southwestness), 2), " ± ", round(sd(southwestness), 2)),
    fire_events = paste0(round(median(fire_event_count), 2), " ± ", round(sd(fire_event_count), 2)),
    twi = paste0(round(median(twi), 2), " ± ", round(sd(twi), 2)),
   total_solrad = paste0(comma(round(median(total_solrad), 0)), " ± ", comma(round(sd(total_solrad), 0)))
  )


# Print as a gt table
table_plant <- means %>%
  # Rename plant_cluster values before passing to gt
  mutate(plant_cluster = recode(plant_cluster, 
                                `1` = "NNG", 
                                `2` = "ssF", 
                                `3` = "ssG", 
                                `4` = "ssFG", 
                                `5` = "EVG")) %>%
  gt() %>%
  tab_header(
    title = "Summary of Environmental Variables by Plant Cluster"
    #,
    #subtitle = "words here"
  ) %>%
   tab_footnote(
    footnote = "Means and standard deviations reported for normally distributed variables.", 
    locations = cells_column_labels(columns = slope)
  ) %>% 
   tab_footnote(
    footnote = "Medians and standard deviations reported for non-normally distributed variables.", 
    locations = cells_column_labels(c(columns = southwestness, twi, fire_events, total_solrad))
  ) %>% 
  
  # Rename the column headers
  cols_label(
    plant_cluster = "Plant Group",        # Rename "plant_cluster" column
    slope = "Slope (%)",                    # Rename "slope" column
    southwestness = "Southwestness",        # Rename "southwestness" column
    twi = "TWI",       # Rename "tpi" column
    fire_events = "Fire Count",        # Rename "fire_events" column
    total_solrad = "Total solar radiation"
  ) %>%
  cols_align(
    align = "center", # Center alignment
    columns = "plant_cluster" # Specify the "cluster" column
  ) %>% 
  tab_options(
    table.width = pct(100) # Make the table width 100%
  ) 

table_plant


```

### Hierarchical Agglomerative Clustering

```{r}

##########  Prepare environ data for an NMDS (numbers only matrix)

df <- extracted %>%  
  column_to_rownames("site_rep") %>% 
  dplyr::select(c("slope", "southwestness", "twi", "fire_event_count",  
                  #"summer_solarradiation", "winter_solarradiation", "equinox_solarradiation"
                  "total_solrad"
                  ))


# using data set *** df *** from two chuncks above

names(df)
row.names(df)

# Calculate distance measure matrix, Bray is the best for community data
d <- vegdist(df, method = "bray") 


# Check which method produces best clustering
m <- c( "average", "single", "complete", "ward", "gaverage")
names(m) <- c( "average", "single", "complete", "ward", "gaverage")

# function to compute coefficient
ac <- function(x) {
  agnes(d, method = x, diss = TRUE, par.method = -0.25)$ac}

# Best method?
map_dbl(m, ac) # <-  gaverage is best


#########################
#### Find optimal number of clusters

# Scree plot  
fviz_nbclust(df, FUN = hcut, diss = d, method = "wss") # 3 groups is best

# Average Silhouette
# Measures how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The Average Silhouette Width is the mean of all silhouette scores within a cluster or across all clusters.
# S ≈ 1: The point is well clustered
fviz_nbclust(df, FUN = hcut, diss = d, method = "silhouette") # 2 or 3 groups

# Gap Stat
# Compares the total within-cluster variation for different numbers of clusters with their expected values under a null reference distribution of the data (i.e., uniformly distributed points).
# The optimal number of clusters is the smallest k such that the Gap Statistic is maximized or the first local maximum occurs, indicating that adding more clusters does not significantly improve the clustering.
fviz_nbclust(df, FUN = hcut, diss = d, method = "gap_stat") # 3 groups is best

# Above tests suggest at least two, but are also not conclusive...

# Define function to compute Mantel correlation tests for different cluster assignments
compute_mantel_correlation <- function(hclust_obj, distance_matrix) {

  # Initialize variables to store results
  mantel_correlation <- numeric(length = length(hclust_obj$order) - 1)
  
  # Iterate through different numbers of clusters
  for (k in 2:length(hclust_obj$order)) {
    cluster_assignments <- cutree(hclust_obj, k = k)
    cluster_distance <- as.matrix(dist(cluster_assignments))
    mantel_result <- mantel(cluster_distance, distance_matrix)
    mantel_correlation[k - 1] <- mantel_result$statistic
    # Print Mantel correlation for each number of clusters
    print(paste("Mantel Correlation (r) for", k, "clusters:", mantel_result$statistic))
  }
  
  return(mantel_correlation)
}

# Create Clusters and then run tests
Hclust.result <- agnes(d, method = "gaverage", par.method = -0.25) # Perform hierarchical clustering
mantel_results <- compute_mantel_correlation(Hclust.result, d)

# Find the optimal number of clusters based on the largest Mantel correlation, r
optimal_clusters <- which.max(mantel_results) + 1  # Add 1 to convert index to number of clusters
print(paste("Optimal Number of Clusters:", optimal_clusters)) # <-- 3 groups


######## Use ISA to determine optimal clusters

# Function to run multipatt() on k iterations of clusters and extract ISA values
run_multipatt_and_extract_ISA <- function(data, max_clusters) {
  
  # Initialize an empty dataframe to store ISA values
  isa_df <- data.frame(Species = colnames(data))
  
  # Iterate through different numbers of clusters
  for (k in 2:max_clusters) {
    cluster_assignments <- cutree(agnes(vegdist(data, method = "bray"), method = "gaverage", par.method = -0.25), k = k)
    
    # Convert cluster assignments to a factor
    cluster_factor <- as.factor(cluster_assignments)
    
    # Run multipatt() with the cluster factor
    multipatt_result <- multipatt(data, cluster = cluster_factor, duleg = FALSE)
    
    # Extract ISA values and p-values
    isa_values <- multipatt_result$sign$index
    p_values <- multipatt_result$sign$p.value
    
    # Filter by p-value <= 0.05
    significant_isa_values <- ifelse(p_values <= 0.05, isa_values, NA)
    
    # Extract ISA values for each species and add to the dataframe
    isa_df[[as.character(k)]] <- significant_isa_values
  }
  
  return(isa_df)
}


max_clusters <- 10  # Maximum number of clusters to iterate through

# Run multipatt() and extract ISA values for each species
isa_data <- run_multipatt_and_extract_ISA(df, max_clusters)

# Frequency distribution of number of significant ISA in each cluster step
frq.ISA <- isa_data %>%
  pivot_longer(cols = 2:10, names_to = "Cluster", values_to = "ISA_SCORE") %>%
  drop_na() %>% 
  group_by(Cluster) %>% 
  summarise(count = n()) %>% 
  arrange(as.numeric(Cluster))


#######
# Now calculate the sum of the differences in ISA scores from one step to the next
# When the indicator values of all species are decreasing, the clustering method does not explain anything more. 
# Take difference of species index values

isa.diff.data <- isa_data %>% 
  mutate(k2 = `2`-`3`) %>% 
  mutate(k3 = `3`-`4`) %>%
  mutate(k4 = `4`-`5`) %>%
  mutate(k5 = `5`-`6`) %>%
  mutate(k6 = `6`-`7`) %>%
  mutate(k7 = `7`-`8`) %>%
  mutate(k8 = `8`-`9`) %>%
  mutate(k9 = `9`-`10`) 

isa.diff.sum <- isa.diff.data %>%
  select(Species, 11:18) %>% 
  pivot_longer(cols = 2:9, names_to = "Cluster", values_to = "ISA_SCORE") %>% 
  drop_na() %>%
  filter(ISA_SCORE <= 0)%>% 
  arrange(by = Cluster) %>% 
  group_by(Cluster) %>% 
  summarise(sum = sum(ISA_SCORE))

ggplot(isa.diff.sum, # figure is blank 
       aes(x = Cluster,
           y = sum)) +
  geom_bar(stat = "identity") +
  labs(title = "", x = "Cluster", y = "Value") +
  theme_minimal()



# Beta average
hcluster.environ <- agnes(d, method = "gaverage", par.method = -0.25) # Perform hierarchical clustering (using average linkage)
 
plot(hcluster.environ)
rect.hclust(hcluster.environ, k = 3)

# Cut tree into groups
sub_grp <- cutree(hcluster.environ, k = 3)


# Number of members in each cluster
table(sub_grp)
# sub_grp
#  1  2  3 
# 16 14  9 

# sub_grp <-- with 2 groups
#  1  2 
# 27 12

# Combine group labels into species matrix
# temp.df <- extracted_prep %>%  
#   rownames_to_column() 

my_groups <- as.data.frame(sub_grp) %>% 
  rownames_to_column() # turning rownames into its own column

environ.subgrp.df <- left_join(extracted, my_groups, by = "rowname") %>% 
  dplyr::select(rowname, sub_grp, site_rep)

# Create a combined label
combined_labels <- paste(environ.subgrp.df$sub_grp, environ.subgrp.df$site_rep, sep = " - ")

# Plot the hierarchical clustering dendrogram with the combined labels
plot(hcluster.environ, labels = combined_labels, main = "Hierarchical Clustering Dendrogram")
rect.hclust(hcluster.environ, k = 3)

################
# Indicator Species Analysis

ISA.abs.cover <- multipatt(x = df, cluster = sub_grp, duleg = FALSE)

# A = The values are the **specificity** component of IV for that species in that combination of groups.
# B = The values are the **fidelity** component of IV for that species in that combination of groups
summary(ISA.abs.cover, indvalcomp=TRUE)





##############
# Does community composition differ among groups?

# Check for homogeneity of dispersion among groups, required for MANOVA
trt <- as.character(my_groups$sub_grp)

# There is significant dispersion within groups, and groups are unbalanced --- cannot use MANOVA (adonis)
anova(betadisper(d, trt))

mod <- betadisper(d, trt)

TukeyHSD(mod)


boxplot(mod)

plot(mod)

# Best option is MRPP -->  MRPP stands for Multi-Response Permutation Procedure, 
# a non-parametric statistical test used to assess whether there is a 
# significant difference between two or more groups based on multivariate data. 
# It is similar to PERMANOVA but uses a different approach to compare the within-group 
# and between-group distances.
# 
# The key idea is simple: if groups differ, the mean within-group dissimilarity should be smaller
# than the mean dissimilarity among randomly selected groups of the same size.
results <- mrpp(d, grouping = sub_grp, permutations = 999)
results



```


### NMDS

#### Visualize community differences by environmental variables

```{r nmds by species percent cover, include = FALSE}
          
### the AUTOTRANSFORM = F skips the automatic data transformations and uses the input data as is
### - when the raw data contains the information you need (e.g., abundance)
### - when you have a small number of samples or small number of variables
### - when you want to preserve the original scale of the data (e.g., interested in the absolute differences betwen two sets of measurements)

# mds <- metaMDS(df, 
                      #  autotransform = TRUE, # FALSE or TRUE
                      #  distance = "bray",   # bray or "raup" - Bray is the best for community data
                      # k = 3, #dimentions
                      # trymax = 400) # this is more appropriate for my data

# mds$stress
### k = 2D: stress test = 0.06422607
### k = 3D: stress test = 0.04510397
### k = 4D: stress test = 0.03603733


### stressplot(mds) # A Shepard plot compares the observed dissimilarities (distances in the original data) to the fitted distances (distances in the reduced NMDS space).
# gof <- goodness(mds) # Higher values indicate points that are poorly represented in the reduced-dimensional space, contributing more to the stress
### min(gof) = 0.004822674
### max(gof) = 0.011505323

# plot(mds, display = "sites", type = "none")
# points(mds, display = "sites", cex = 2* # 2x for visibility
         # gof/mean(gof)) # standardized by the mean
### larger points = less well represented

```

```{r environ nmds, include=FALSE}

### Plot NMDS

######## don't run becuase ENVIRON variables are of different units. Run PCA instead.

 
# mds.df <- vegan::scores(mds, display = "sites") %>% 
#   as.data.frame() %>% 
#   rownames_to_column("site_rep") %>% 
#   full_join(extracted %>% dplyr::select("site_rep", "plant_cluster"), by = "site_rep") %>% 
#     mutate(plant_cluster = as.character(plant_cluster)) %>% 
#   rownames_to_column() %>% 
#   full_join(my_groups, by = "rowname") %>% 
#   rename(environ_cluster = sub_grp) %>% 
#      mutate(environ_cluster = as.character(environ_cluster)) %>% 
#   dplyr::select(-rowname)

# uses the RAUP-CRICK dissimilarity index to calculate pairwise dissimilarities
# - adjusts for spp richness
# - downweights importance of rare spp 
# - more useful when interested in community STRUCTURE rather than individual species
# - takes into account differences in species evenness
# abcover_byspecies_NMDS <- metaMDS(abcover_byspecies_nmdsprep_num, distance = "raup") 


# ggplot(mds.df,
#        aes(x = NMDS1,
#            y = NMDS2,
#            color = environ_cluster, 
#            shape = environ_cluster)) +
#   geom_point(size = 3, alpha = 0.8) +
#   stat_ellipse() + 
#   theme(axis.title = element_text(size = 20)) +
#   theme(axis.text = element_text(size = 16))


# ggplot(mds.df,
#        aes(x = NMDS2,
#            y = NMDS3,
#            color = environ_cluster,
#            shape = environ_cluster)) +
#   geom_point(size = 3, alpha = 0.8) +
#   stat_ellipse() + 
#   theme(axis.title = element_text(size = 20)) +
#   theme(axis.text = element_text(size = 16))


# p <- plot_ly(mds.df,
#         x = ~NMDS1,
#         y = ~NMDS2,
#         z = ~NMDS3,
#         type =  "scatter3d",
#         color=mds.df$envion_cluster)
# p

```

### PCA 
- n = 39 transects (including INT transects)

```{r}


########### Environ PCA - unscaled data

pca_data <- extracted %>% 
  dplyr::select(c(slope, twi, southwestness, fire_event_count, site_rep, 
                  #summer_solarradiation, winter_solarradiation, equinox_solarradiation
                  total_solrad
                  )) %>% 
  column_to_rownames("site_rep")

########### Environ PCA - scaled data - PCA results are the same with unscaled and scaled data, so I'll stick with the unscaled data (sept. 19, 2024 - SML)
# pca_data <- extracted_prep %>% 
#   dplyr::select(!c(rowname, aspect, site, last_fire, elevation, lat, long)) %>% 
#   left_join(environ.subgrp.df, by = "site_rep") %>%
#    rename(environ_cluster = sub_grp) 
# 
# # Select the columns to exclude from scaling
# exclude_names <- c("site_rep", "plant_cluster", "rowname", "environ_cluster")
# 
# # Separate the data into unscaled and scaled parts
# unscaled_columns <- pca_data %>%
#   dplyr::select(all_of(exclude_names))  # Unscaled columns
# 
# scaled_columns <- pca_data %>%
#   dplyr::select(-all_of(exclude_names)) %>%  # All other columns (to be scaled)
#   scale()  # Scale only the selected columns
# 
# # Combine the unscaled and scaled parts back together
# final_df <- cbind(unscaled_columns, scaled_columns)


# Run PCA on the scaled part of the data only (ignoring the unscaled columns)
pca_result <- prcomp(pca_data, center = TRUE, scale = TRUE)
pca_scores <- pca_result$x  # These are the scores (transformed data)

# View PCA results
summary(pca_result)
# Importance of components: 
#                           PC1    PC2    PC3    PC4     PC5
# Standard deviation     1.4238 1.0116 0.9723 0.7316 0.68461
# Proportion of Variance 0.4054 0.2047 0.1891 0.1071 0.09374
# Cumulative Proportion  0.4054 0.6101 0.7992 0.9063 1.00000

summary(pca_scores)

pca_values <- as.data.frame(pca_result$x)
loadings_df <- as.data.frame(pca_result$rotation) #df with variables' vectors
loadings_df <- loadings_df * 5 # scale for visuals

pca_df <- pca_values %>% 
  rownames_to_column("site_rep") %>% 
  
  full_join(extracted %>% dplyr::select("site_rep", "plant_cluster"), by = "site_rep") %>% 
    mutate(plant_cluster = as.character(plant_cluster)) %>% 
  rownames_to_column() %>% 
  full_join(my_groups, by = "rowname") %>% 
  rename(environ_cluster = sub_grp) %>% 
     mutate(environ_cluster = as.character(environ_cluster)) %>% 
  dplyr::select(-rowname)


PCA_environcluster <- ggplot() +
  geom_point (data = pca_df,
              aes(x = PC1, 
                  y = PC2, 
                  color = environ_cluster, 
                  shape = environ_cluster), 
              size = 4) +  
  scale_color_manual(values = c("1" = "gold", "2" = "green", "3" = "darkgreen")) +
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) + 
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  
  geom_segment(data = loadings_df, # <- vectors
               aes(x = 0,
                   y = 0, 
                   xend = PC1, 
                   yend = PC2),  
               arrow = arrow(length = unit(0.2, "cm")), 
               color = "black", alpha = 0.8) +  # alpha = transparency (0 = transparent, 1 = solid)
  
  geom_text_repel(data = loadings_df,  # vector text                 
                  aes(x = PC1, 
                      y = PC2, 
                      label = rownames(loadings_df)),
                  size = 4, color = "blue") +             # Text labels in blue
  
 labs(title = "PCA of Environmental Variables", 
       x = "Principal Component 1 (40.54%)",
       y = "Principal Component 2 (20.47%)") +                  
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) +         # Center title
  xlim(-4, 4) +
  ylim(-5, 4)


PCA_plantcluster <- ggplot() +
  geom_point (data = pca_df,
              aes(x = PC1, y = PC2, 
                  color = factor(plant_cluster, levels = c(1, 3, 2, 4, 5)), 
                 shape = factor(plant_cluster, levels = c(1, 3, 2, 4, 5)), 
                 fill = factor(plant_cluster, levels = c(1, 3, 2, 4, 5))), 
              size = 4) +  
  # how the data points look
  scale_shape_manual(values = c("1" = 21, "2" = 21, "3" = 21, "4" = 21, "5" = 7),
                     labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
  scale_color_manual(values = c("1" = "black", "2" = "black", "3" = "black", "4" = "black", "5" = "black"),
                     labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
  scale_fill_manual(values = c("1" = "black", "2" = "grey85", "3" = "grey60", "4" = "white", "5" = "black"),
                     labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
  
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) + 
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  geom_segment(data = loadings_df, 
               aes(x = 0, y = 0, xend = PC1, yend = PC2),  # Vectors for loadings
               arrow = arrow(length = unit(0.2, "cm")), 
               color = "black", alpha = 0.8) +             # Vectors in blue, alpha = transparency (0 = transparent, 1 = solid)
  geom_text_repel(data = loadings_df,                    # Text labels for loadings
                  aes(x = PC1, y = PC2, label = rownames(loadings_df)),
                  size = 4, color = "blue") +             # Text labels in blue
 labs(title = "PCA of Environmental Variables", 
       x = "Principal Component 1 (40.54%)",
       y = "Principal Component 2 (20.47%)") +                   
  #clean_background +      
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) +         # Center title
  xlim(-4, 4) +
  ylim(-5, 4) +
    guides(color = guide_legend(title = "Plant Group"),
         shape = guide_legend(title = "Plant Group"),
         fill = guide_legend(title = "Plant Group"))



PCA_plot <- ggplot() +
  geom_point (data = pca_df,
              aes(x = PC1, 
                  y = PC2, 
                  color = environ_cluster, 
                  shape = plant_cluster), 
              size = 4) +  
  scale_color_manual(values = c("1" = "orange", "2" = "cyan", "3" = "darkgreen")) +
  
  scale_shape_manual(values = c("1" = 1, "2" = 2, "3" = 3, "4" = 22, "5" = 7),
                     labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
  
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) + 
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  geom_segment(data = loadings_df, 
               aes(x = 0, y = 0, xend = PC1, yend = PC2),  # Vectors for loadings
               arrow = arrow(length = unit(0.2, "cm")), 
               color = "black", alpha = 0.8) +             # Vectors in blue, alpha = transparency (0 = transparent, 1 = solid)
  geom_text_repel(data = loadings_df,                    # Text labels for loadings
                  aes(x = PC1, y = PC2, label = rownames(loadings_df)),
                  size = 4, color = "blue") +             # Text labels in blue
  labs(title = "PCA of Environmental Variables", 
       x = "Principal Component 1 (40.54%)",
       y = "Principal Component 2 (20.47%)") +                  
  #clean_background +      
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) +         # Center title
  xlim(-4, 4) +
  ylim(-5, 4)



PCA_environcluster

PCA_plantcluster

PCA_plot

```

### MEAN by plant (n=5) 

- environmental variables (n = 5): slope, southwestness, total_solrad, fire_event_count, twi

```{r}

boxdf <-  extracted %>% 
   full_join(my_groups, by = "rowname") %>% 
  rename(environ_cluster = sub_grp) %>% 
     mutate(environ_cluster = as.character(environ_cluster)) %>% 
   mutate(plant_cluster = as.character(plant_cluster))




########################################## slope
boxplot(slope ~ plant_cluster, boxdf)
shapiro.test(boxdf$slope) # <- normal
summary(aov(slope ~ plant_cluster, boxdf))
TukeyHSD(aov(slope ~ plant_cluster, boxdf), conf.level = .95)
# Fit: aov(formula = slope ~ plant_cluster, data = df)
# $cluster
#          diff         lwr       upr     p adj
# 2-1  4.865313  -5.3013433 15.031969 0.6454368
# 3-1  1.879894  -7.3893422 11.149131 0.9765639
# 4-1 -1.014681 -10.8174014  8.788040 0.9981919
# 5-1 11.216590  -0.0358360 22.469017 0.0510664 <- not sig - 5 is steeper than 1
# 
# 3-2 -2.985419 -12.9271919  6.956355 0.9077278
# 4-2 -5.879994 -16.3209440  4.560957 0.4943670
# 5-2  6.351278  -5.4613095 18.163865 0.5395130
# 
# 4-3 -2.894575 -12.4638642  6.674714 0.9054976
# 5-3  9.336696  -1.7129674 20.386359 0.1309924
# 
# 5-4 12.231271   0.7304168 23.732125 0.0324924 <-- 5 is steeper than 4

# 1 ab
# 2 ab
# 3 ab
# 4 a
# 5 b steeper than 4


########################################## southwestness
hist(boxdf$southwestness)
boxplot(southwestness ~ plant_cluster, boxdf)
shapiro.test(boxdf$southwestness) # <- not normal
kruskal.test(southwestness ~ plant_cluster, data = boxdf) # no differences
pairwise.wilcox.test(boxdf$southwestness, boxdf$plant_cluster, p.adjust.method = "BH")


# values range from −1 (northeast) to 1 (southwest)

# data:  boxdf$southwestness and boxdf$plant_cluster 
# 
#   1    2    3    4   
# 2 0.94 -    -    -   
# 3 0.94 0.94 -    -   
# 4 0.94 0.94 0.94 -   
# 5 0.94 0.94 0.94 0.94

# 1 a
# 2 a
# 3 a
# 4 a
# 5 a

########################################## totalsolarrad
hist(boxdf$total_solrad)
boxplot(total_solrad ~ plant_cluster, boxdf)

shapiro.test(boxdf$total_solrad) # <- not normal
kruskal.test(total_solrad ~ plant_cluster, data = boxdf) 
#	Kruskal-Wallis rank sum test
# 
# data:  total_solrad by plant_cluster
# Kruskal-Wallis chi-squared = 22.611, df = 4, p-value = 0.0001514 <- sig

pairwise.wilcox.test(boxdf$total_solrad, boxdf$plant_cluster, p.adjust.method = "BH")
# data:  boxdf$total_solrad and boxdf$plant_cluster 
# 
#   1      2      3      4     
# 2 0.2172 -      -      -     
# 3 0.3687 0.0066 -      -     
# 4 0.0846 0.3687 0.0053 -     
# 5 0.0053 0.0053 0.0053 0.0053
# 
# P value adjustment method: BH 

# 1 and 5 are sig diff
# 1 and 2, 3, 4 are same

# 1 ac
# 2 ac
# 3 c
# 4 a
# 5 b


########################################## fire_event_count
hist(boxdf$fire_event_count)
shapiro.test(boxdf$fire_event_count) # <- not normal - basian distribution
kruskal.test(fire_event_count ~ plant_cluster, data = boxdf) 
pairwise.wilcox.test(boxdf$fire_event_count, boxdf$plant_cluster, p.adjust.method = "BH") 
boxplot(fire_event_count ~ plant_cluster, boxdf)

# data:  boxdf$fire_event_count and boxdf$plant_cluster 
# 
#   1     2     3     4    
# 2 0.087 -     -     -    
# 3 0.954 0.087 -     -    
# 4 0.679 0.154 0.653 -    
# 5 0.131 0.954 0.123 0.294

# 1 a
# 2 a
# 3 a
# 4 a
# 5 a

########################################## twi
hist(boxdf$twi)
boxplot(twi ~ plant_cluster, boxdf)
shapiro.test(boxdf$twi) # <- not normal
kruskal.test(twi ~ plant_cluster, data = boxdf) # no differences
pairwise.wilcox.test(boxdf$twi, boxdf$plant_cluster, p.adjust.method = "BH") 

# boxdf$twi and boxdf$plant_cluster 
# 
#   1    2    3    4   
# 2 0.59 -    -    -   
# 3 0.63 0.63 -    -   
# 4 0.58 0.78 0.63 -   
# 5 0.42 0.58 0.42 0.42

# 1 a
# 2 a
# 3 a
# 4 a
# 5 a




# Cells with a lower index value represent areas with steepest slope and tend to be ridges or crests
# present on the landscape. Higher cell values represent areas with increased accumulated runoff
# potential. These areas are identified by a low slope and large upslope contributing areas. 



table_plant_statsmeans <- means %>%  
  
   mutate(
    slopesig = case_when(
      plant_cluster == "1" ~ " (ab)",
      plant_cluster == "2" ~ " (ab)",
      plant_cluster == "3" ~ " (ab)",
      plant_cluster == "4" ~ " (a)",
      plant_cluster == "5" ~ " (b)",
      TRUE ~ NA_character_  # Optional: fill with NA if no match
    )
  ) %>% 
  mutate(
    SWsig = case_when(
      plant_cluster == "1" ~ " (a)",
      plant_cluster == "2" ~ " (a)",
      plant_cluster == "3" ~ " (a)",
      plant_cluster == "4" ~ " (a)",
      plant_cluster == "5" ~ " (a)",
      TRUE ~ NA_character_  # Optional: fill with NA if no match
    )
  ) %>% 
  mutate(
    firesig = case_when(
      plant_cluster == "1" ~ " (a)",
      plant_cluster == "2" ~ " (a)",
      plant_cluster == "3" ~ " (a)",
      plant_cluster == "4" ~ " (a)",
      plant_cluster == "5" ~ " (a)",
      TRUE ~ NA_character_  # Optional: fill with NA if no match
    )
  ) %>% 
   mutate(
    twisig = case_when(
      plant_cluster == "1" ~ " (a)",
      plant_cluster == "2" ~ " (a)",
      plant_cluster == "3" ~ " (a)",
      plant_cluster == "4" ~ " (a)",
      plant_cluster == "5" ~ " (a)",
      TRUE ~ NA_character_  # Optional: fill with NA if no match
    )
  ) %>% 
    mutate(
    solarsig = case_when(
      plant_cluster == "1" ~ " (ac)",
      plant_cluster == "2" ~ " (ac)",
      plant_cluster == "3" ~ " (c)",
      plant_cluster == "4" ~ " (a)",
      plant_cluster == "5" ~ " (b)",
      TRUE ~ NA_character_  # Optional: fill with NA if no match
    )
  ) %>% 
  mutate(Slope = paste(slope, slopesig, sep = ""), 
         Southwestness = paste(southwestness, SWsig, sep = ""), 
         Fire = paste(fire_events, firesig, sep = ""), 
          TWI = paste(twi, twisig, sep = ""), 
          SolarRad = paste(total_solrad, solarsig, sep = ""), 
          ) %>% 
  dplyr::select(plant_cluster, Slope, Southwestness, Fire, TWI, SolarRad) %>% 
  relocate(Slope, Southwestness, Fire, TWI, SolarRad, .after = plant_cluster) %>% 
  
  mutate(plant_cluster = recode(plant_cluster, 
                                `1` = "NNG", 
                                `2` = "ssF", 
                                `3` = "ssG", 
                                `4` = "ssFG", 
                                `5` = "EVG")) %>%

  gt() %>%
  tab_header(
    title = "Summary Statistics by Plant Cluster") %>%
  tab_footnote(
    footnote = "Means and standard deviations reported for normally distributed variables.", 
    locations = cells_column_labels(columns = Slope)
  ) %>% 
   tab_footnote(
    footnote = "Medians and standard deviations reported for non-normally distributed variables.", 
    locations = cells_column_labels(c(columns = Southwestness, TWI, Fire, SolarRad))
  ) %>% 
  # Rename the column headers
  cols_label(
    plant_cluster = "Plant Group",        # Rename "plant_cluster" column
    Slope = "Slope (%)",                    # Rename "slope" column
    Southwestness = "Southwestness",        # Rename "southwestness" column
    TWI = "TWI",       # Rename "tpi" column
    Fire = "Fire Events",        # Rename "fire_events" column
    SolarRad = "Total solar radiation"
  ) %>%
  cols_align(
    align = "center", # Center alignment
    columns = "plant_cluster" # Specify the "cluster" column
  ) %>% 
  tab_options(
    table.width = pct(100) # Make the table width 100%
  ) 


table_plant_statsmeans

```

### MEANS by environ (n=3) 

```{r}


length(
  boxdf %>%  
    filter(environ_cluster == "1")  %>% 
         pull(environ_cluster)
       ) # n = 17

length(
  boxdf %>%  
    filter(environ_cluster == "2") %>% 
         pull(environ_cluster)
       ) # n = 13
length(
  boxdf %>%  
    filter(environ_cluster == "3") %>% 
         pull(environ_cluster)
       ) # n = 9


########################################## southwestness
hist(boxdf$southwestness)
shapiro.test(boxdf$southwestness) # <- not normal

kruskal.test(southwestness ~ environ_cluster, data = boxdf) # p-value = 0.7918

pairwise.wilcox.test(boxdf$southwestness, boxdf$environ_cluster, p.adjust.method = "BH")
boxplot(southwestness ~ environ_cluster, boxdf)
# no sig diffs

########################################## twi
hist(boxdf$twi)
shapiro.test(boxdf$twi) # 0.033 <- not normal

kruskal.test(twi ~ environ_cluster, data = boxdf) 
# Kruskal-Wallis chi-squared = 4.57, df = 1, p-value = 0.7641
pairwise.wilcox.test(boxdf$twi, boxdf$environ_cluster, p.adjust.method = "BH") # no sig diffs

boxplot(twi ~ environ_cluster, boxdf)

# Cells with a lower index value represent areas with steepest slope and tend to be ridges or crests
# present on the landscape. Higher cell values represent areas with increased accumulated runoff
# potential. These areas are identified by a low slope and large upslope contributing areas. 

########################################## slope
hist(boxdf$slope)
shapiro.test(boxdf$slope) # <- normal

summary(aov(slope ~ environ_cluster, boxdf)) # p = 0.167, not sig diff
TukeyHSD(aov(slope ~ environ_cluster, boxdf), conf.level = .95) 
# $environ_cluster
#          diff        lwr       upr     p adj
# 2-1 -4.163725 -10.932312  2.604862 0.3012302
# 3-1  1.704033  -5.869081  9.277146 0.8471351
# 3-2  5.867757  -2.098456 13.833970 0.1838509

boxplot(slope ~ environ_cluster, boxdf)

########################################## fire_event_count
hist(boxdf$fire_event_count)
shapiro.test(boxdf$fire_event_count) # not normal

kruskal.test(fire_event_count ~ environ_cluster, data = boxdf) 
pairwise.wilcox.test(boxdf$fire_event_count, boxdf$environ_cluster, p.adjust.method = "BH")
#   1      
# 2 1.7e-07

boxplot(fire_event_count ~ environ_cluster, boxdf)


########################################## total_sol_rad
hist(boxdf$fire_event_count)
shapiro.test(boxdf$fire_event_count) # not normal

kruskal.test(fire_event_count ~ environ_cluster, data = boxdf) 
pairwise.wilcox.test(boxdf$fire_event_count, boxdf$environ_cluster, p.adjust.method = "BH")
#   1      
# 2 1.7e-07

boxplot(fire_event_count ~ environ_cluster, boxdf)





############################### Environ variables by environ cluster

Env_means <- boxdf %>% 
   dplyr::select(c("site_rep", "plant_cluster", "environ_cluster",
                   "slope", "southwestness", "twi", "fire_event_count", 
                   "total_solrad")) %>%
  group_by(environ_cluster) %>% 
  mutate(environ_cluster = factor(environ_cluster, levels = c(1, 2, 3 ))) %>%  # Reorder
  
  summarize(
    slope = paste0(round(mean(slope), 2), " ± ", round(sd(slope), 2)), # MEAN becuase normally distributed
    southwestness = paste0(round(median(southwestness), 2), " ± ", round(sd(southwestness), 2)),
    fire_events = paste0(round(median(fire_event_count), 2), " ± ", round(sd(fire_event_count), 2)),
    twi = paste0(round(median(twi), 2), " ± ", round(sd(twi), 2)),
   total_solrad = paste0(comma(round(median(total_solrad), 0)), " ± ", comma(round(sd(total_solrad), 0)))
  )


# Print as a gt table
table_environ <- Env_means %>%
  # Rename environ_cluster values before passing to gt
  mutate(environ_cluster = recode(environ_cluster, 
                                `1` = "Steep, sunny", 
                                `2` = "Flat, sunny", 
                                `3` = "Steep, shady, dry")) %>%
  gt() %>%
  tab_header(
    title = "Summary of Environmental Variables by Environmental Cluster"
    #,
    #subtitle = "words here"
  ) %>%
   tab_footnote(
    footnote = "Means and standard deviations reported for normally distributed variables.", 
    locations = cells_column_labels(columns = slope)
  ) %>% 
   tab_footnote(
    footnote = "Medians and standard deviations reported for non-normally distributed variables.", 
    locations = cells_column_labels(c(columns = southwestness, twi, fire_events, total_solrad))
  ) %>% 
  
  # Rename the column headers
  cols_label(
    environ_cluster = "Environmental Group",        # Rename "plant_cluster" column
    slope = "Slope (%)",                    # Rename "slope" column
    southwestness = "Southwestness",        # Rename "southwestness" column
    twi = "TWI",       # Rename "tpi" column
    fire_events = "Fire Count",        # Rename "fire_events" column
    total_solrad = "Total solar radiation"
  ) %>%
  cols_align(
    align = "center", # Center alignment
    columns = "environ_cluster" # Specify the "cluster" column
  ) %>% 
  tab_options(
    table.width = pct(100) # Make the table width 100%
  ) 

table_environ

```








# END

- n = 34 transects (omitting INT transects)
NOTE: On Sept 19, 2024 I ran a PCA analysis omitting INT transects and the values were similar enough that I am deciding to include INT transects in the PCA. This is a more complete analysis (becuase I'm using all data points) and because I think it's a "pro" to include and not having to justify why I am omitting them. 
```{r}

########### Environ PCA without INT transects


# pca_data_woINT <- extracted %>% 
#   dplyr::select(c(hillshade, slope, twi, southwestness, fire_event_count, site_rep, site)) %>% 
#   filter(site == "site_1" | site == "site_2") %>% 
#   column_to_rownames("site_rep") %>% 
#   dplyr::select(-site)


### Run PCA on the scaled part of the data only (ignoring the unscaled columns)
# pca_result <- prcomp(pca_data_woINT, center = TRUE, scale = TRUE)
# pca_scores <- pca_result$x  # These are the scores (transformed data)

### View PCA results
# summary(pca_result)
### Importance of components: ---------- pca_data_woINT ------------------
###                           PC1    PC2    PC3    PC4     PC5
### Standard deviation     1.4952 1.0201 0.8859 0.7524 0.61059
### Proportion of Variance 0.4471 0.2081 0.1570 0.1132 0.07456
### Cumulative Proportion  0.4471 0.6553 0.8122 0.9254 1.00000 <-- better explanation by PC1 and PC2 w/o INT transects
### 
### # Importance of components: ---------- pca_data ------------------
###                           PC1    PC2    PC3    PC4     PC5
### Standard deviation     1.4435 1.0747 0.8609 0.7676 0.65664
### Proportion of Variance 0.4167 0.2310 0.1482 0.1178 0.08623
### Cumulative Proportion  0.4167 0.6477 0.7959 0.9138 1.00000

# summary(pca_scores)

# pca_values <- as.data.frame(pca_result$x)
# loadings_df <- as.data.frame(pca_result$rotation) #df with variables' vectors
# loadings_df <- loadings_df * 5 # scale for visuals

# pca_df <- pca_values %>%
#   rownames_to_column("site_rep") %>%
#   
#   left_join(extracted %>% dplyr::select("site_rep", "plant_cluster"), by = "site_rep") %>% 
#     mutate(plant_cluster = as.character(plant_cluster)) %>% 
#   rownames_to_column() %>% 
#   left_join(my_groups, by = "rowname") %>% 
#   rename(environ_cluster = sub_grp) %>% 
#      mutate(environ_cluster = as.character(environ_cluster)) %>% 
#   dplyr::select(-rowname)


# PCA_plot_2 <- ggplot() +
#   geom_point (data = pca_df,
#               aes(x = PC1, y = PC2, color = environ_cluster, shape = plant_cluster), 
#               size = 4) +  
#   scale_color_manual(values = c("1" = "darkorange", "2" = "darkgreen")) +
#   
#   scale_shape_manual(values = c("1" = 1, "2" = 2, "3" = 3, "4" = 22, "5" = 7),
#                      labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
#   
#   geom_vline(xintercept = c(0), color = "grey70", linetype = 2) + 
#   geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
#   geom_segment(data = loadings_df, 
#                aes(x = 0, y = 0, xend = PC1, yend = PC2),  # Vectors for loadings
#                arrow = arrow(length = unit(0.2, "cm")), 
#                color = "black", alpha = 0.8) +             # Vectors in blue, alpha = transparency (0 = transparent, 1 = solid)
#   geom_text_repel(data = loadings_df,                    # Text labels for loadings
#                   aes(x = PC1, y = PC2, label = rownames(loadings_df)),
#                   size = 4, color = "blue") +             # Text labels in blue
#   labs(title = "PCA of Environmental Variables - omit INT", 
#        x = "Principal Component 1 (44.71%)",
#        y = "Principal Component 2 (20.81%)") +                  
#   #clean_background +      
#   theme_bw()+
#   theme(plot.title = element_text(hjust = 0.5)) +         # Center title
#   xlim(-4, 4) +
#   ylim(-5, 4)


# PCA_environcluster_2 <- ggplot() +
#   geom_point (data = pca_df,
#               aes(x = PC1, y = PC2, color = environ_cluster, shape = environ_cluster), 
#               size = 4) +  
#   scale_color_manual(values = c("1" = "darkorange", "2" = "darkgreen")) +
#   #scale_shape_manual(values = c("1" = 0, "2" = 4, "3" = 2, "4" = 3, "5" = 7)) +
#   geom_vline(xintercept = c(0), color = "grey70", linetype = 2) + 
#   geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
#   geom_segment(data = loadings_df, 
#                aes(x = 0, y = 0, xend = PC1, yend = PC2),  # Vectors for loadings
#                arrow = arrow(length = unit(0.2, "cm")), 
#                color = "black", alpha = 0.8) +             # Vectors in blue, alpha = transparency (0 = transparent, 1 = solid)
#   geom_text_repel(data = loadings_df,                    # Text labels for loadings
#                   aes(x = PC1, y = PC2, label = rownames(loadings_df)),
#                   size = 4, color = "blue") +             # Text labels in blue
#   labs(title = "PCA of Environmental Variables", 
#        x = "Principal Component 1 (44.71%)",
#        y = "Principal Component 2 (20.81%)") +               
#   #clean_background +      
#   theme_bw()+
#   theme(plot.title = element_text(hjust = 0.5)) +         # Center title
#   xlim(-4, 4) +
#   ylim(-5, 4)


# PCA_plantcluster_2 <- ggplot() +
#   geom_point (data = pca_df,
#               aes(x = PC1, y = PC2, 
#                   color = plant_cluster, shape = plant_cluster, fill = plant_cluster), 
#               size = 4) +  
#   # how the data points look
#   scale_shape_manual(values = c("1" = 21, "2" = 21, "3" = 21, "4" = 21, "5" = 7),
#                      labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
#   scale_color_manual(values = c("1" = "black", "2" = "black", "3" = "black", "4" = "black", "5" = "black"),
#                      labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
#   scale_fill_manual(values = c("1" = "black", "2" = "grey75", "3" = "grey40", "4" = "white", "5" = "black"),
#                      labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
#   
#   geom_vline(xintercept = c(0), color = "grey70", linetype = 2) + 
#   geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
#   geom_segment(data = loadings_df, 
#                aes(x = 0, y = 0, xend = PC1, yend = PC2),  # Vectors for loadings
#                arrow = arrow(length = unit(0.2, "cm")), 
#                color = "black", alpha = 0.8) +             # Vectors in blue, alpha = transparency (0 = transparent, 1 = solid)
#   geom_text_repel(data = loadings_df,                    # Text labels for loadings
#                   aes(x = PC1, y = PC2, label = rownames(loadings_df)),
#                   size = 4, color = "blue") +             # Text labels in blue
#   labs(title = "PCA of Environmental Variables", 
#        x = "Principal Component 1 (44.71%)",
#        y = "Principal Component 2 (20.81%)") +                  
#   #clean_background +      
#   theme_bw()+
#   theme(plot.title = element_text(hjust = 0.5)) +         # Center title
#   xlim(-4, 4) +
#   ylim(-5, 4) +
#     guides(color = guide_legend(title = "Plant Group"),
#          shape = guide_legend(title = "Plant Group"),
#          fill = guide_legend(title = "Plant Group"))

# PCA_plot_2

# PCA_environcluster_2

# PCA_plantcluster_2

```




