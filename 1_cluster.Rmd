---
title: "Using cluster analysis to identify plant groupings among chaparral transects"
author: "Stephanie Lucero"
date: "2024-06-13"
output: html_document
---

load libraries
```{r}
library(MASS)
library(tidyverse)
library(here)
library(stringr)
library(factoextra)
library(cluster)
library(vegan)
library(indicspecies)
library(plotly)
library(dunn.test)
library(caret)
library(rpart)
library(ggrepel)
library(ggparty)
library(factoextra)

# Set seed for analyses
set.seed(3980)

```

# Step 1: Load the data
```{r bringing in the csv you sent me}
data_pc <- read.csv("twinspan_percentcover.csv")

rownames(data_pc) <- data_pc[,1]
data_pc[,1] <- NULL




```

# load data
```{r load point intercept transect data from csv, include=TRUE}
file_transect_2019_load <- read_excel("deg_percentcover_byspecies_bylifeform_2024.xlsx", sheet = "2019_data")

# -- years 2017, 2019
# -- Site 1: transects 1-6
# -- Site 2: transects 1-6
# -- INT1, INT2, INT3, INT4

# Finding species == "Bromus spp." to rename them by species
# transect2019_bromus <- file_transect_2019_load %>%
#   filter(grepl("Bromus", species))
# 
# transect2019_bromusspp <- file_transect_2019_load %>% 
#   filter(species == "Bromus spp.")

transect2019 <- file_transect_2019_load %>% 
  dplyr::select(c(site, transect, year, distance, vertical, species)) %>% # select columns to full join with 2024 data
  filter(year %in% c(2017, 2019))  %>% #filter data to 2019 data
   dplyr::select(year, site, transect, distance, vertical, species) %>% 
   mutate(species = ifelse(# a condition, a value if the condition is true, and a value if the condition is false
                              site == 2 & transect == 5 & distance %in% c(2, 6, 9) & species == "Bromus spp.", "Bromus hordeaceus", species)) %>% 
    mutate(species = ifelse(site == 2 & transect == 5 & distance %in% c(10, 28) & species == "Bromus spp.", "Bromus rubens", species)) %>% 
    mutate(species = ifelse(site == 2 & transect == 6 & distance %in% c(23, 35, 37) & species == "Bromus spp.", "Bromus hordeaceus", species)) %>% 
    mutate(species = ifelse(site == "INT1" & transect == 1 & distance %in% c(24) & species == "Bromus spp.", "Bromus diandrus", species))


# View the data (optional)
#View(transect2019)
#sort(unique(transect2019$transect))
#sort(unique(transect2019$site))

file_transect_2024_load <- read.csv("Transects_2024 - transect.csv", header = TRUE, na.strings=c("","NA"))
# -- years 2024
# -- Site 1: transects 7-14
# -- Site 2: transects 7-21
# -- INT5
transect2024 <- file_transect_2024_load %>%  
  dplyr::select(c(site, transect, year, distance, vertical, species)) %>% 
  filter(species != "N/A") %>% 
   mutate(species = case_when(species == "Bromus spp." ~ "Bromus rubens", # oldname ~ newname
                              TRUE ~ species))
  
# View the data (optional)
#view(transect2024)
#sort(unique(transect2024$transect))
#sort(unique(transect2024$site))
```

## full join transect data

```{r full join}
abcover_fulljoin <- full_join(transect2019, transect2024, by = intersect(names(transect2019), names(transect2024)))

# View the data (optional)
#View(abcover_full)
#sort(unique(abcover_full$transect))
#sort(unique(abcover_full$site))
```

## species list

```{r convert to tibble}
# convert dataframe to tibble
abcover_fulljoin_tib <- as_tibble(abcover_fulljoin) 
class(abcover_fulljoin_tib)

abcover_full <- abcover_fulljoin_tib %>% 
   mutate(site_rep = paste(site, transect, sep = "_")) %>% # combine site and rep to one column
   mutate(site_rep_dist = paste(site_rep, distance, sep = "_")) %>%  # combine site_rep and distance to one column 
   mutate(species = case_when(species == "BG bare ground" ~ "bare_ground", # oldname ~ newname
                              species == "ground" ~ "bare_ground", 
                              species == "native_litter" ~ "litter",
                              species == "nonnative_thatch" ~ "thatch",
                              species == "Bromus diandrus BRDI" ~ "Bromus diandrus",
                              species == "Bromus rubens BRRU" ~ "Bromus rubens", 
                              species == "Bromus hordeaceus BRHO" ~ "Bromus hordeaceus", 
                              species == "Rapistrum rugosum - round pods" ~ "Rapistrum rugosum", 
                              species == "HIIN Hirschfeldia incana - long pods" ~ "Hirschfeldia incana", 
                              species == "Hirschfeldia incana - long pods" ~ "Hirschfeldia incana", 
                              species == "Salvia lucophylla" ~ "Salvia leucophylla",
                              species == "Malacothamnus fasciculatus " ~ "Malacothamnus fasciculatus",
                              species == "dead HEAR" ~ "Heteromeles arbutifolia dead",
                              species == "dead MAFA" ~ "Malacothamnus fasciculatus dead",
                              species == "dead RHIL" ~ "Rhamnus ilicifolia dead",
                              species == "dead ARCA" ~ "Artemisia californica dead",
                              species == "dead SALE" ~ "Salvia leucophylla dead",
                              species == "ACGL Acmispon glaber" ~ "Acmispon glaber",
                              species == "dead Acmispon glaber" ~ "Acmispon glaber dead",
                              species == "Acmispon maritimus - round, sevfl" ~ "Acmispon maritimus",
                              species == "Acmispon strigosus - oval, sevfl" ~ "Acmispon strigosus",
                              species == "Sambucus nigra" ~ "Sambucus mexicana",
                              species == "Blitum californicum" ~ "Chenopodium californicum",
                              species == "Cryptantha sp." ~ "Cryptantha spp.",
                              TRUE ~ species)) %>% 
   mutate(
      year = as.character(year),
      site = as.character(site),
      transect = as.character(transect),
      distance = as.character(distance),
      vertical = as.character(vertical),
      species = as.character(species)
      )

glimpse(abcover_full) # look at new columns

sort(unique(abcover_full$species))

abcover_omitground <- abcover_charateristics_leaftype %>% 
  filter(vertical != "ground", 
         vertical != "ground cover") %>% 
  filter(species != "no_species", 
         species != "thatch") %>% 
  mutate(lifeform_status = paste(lifeform, status, sep = "_")) %>% 
  mutate(lifeform_status_leaftype = paste(lifeform_status, leaftype, sep = "_"))
```




# Assume your data is in a dataframe called `data` (only numeric variables)



# Step 2: Calculate the dissimilarity matrix
```{r clustering}

# NAME data set
df <- data_pc %>% 
  dplyr::select(!c(site, site_rep))

d <- vegdist(df, method = "bray")  # Bray-Curtis dissimilarity
# Calculate distance measure matrix, Bray is the best for community data
# Jaccard Index and Sorensen-Dice Coefficient treat percent cover data as binary (present/absent)
 
# Check which method produces best clustering
# average = Computes the average distance between all pairs of observations across two clusters.
# single = Uses the minimum distance between pairs of observations in two clusters.
# complete = Considers the maximum distance between pairs of observations in two clusters.
# ward = Minimizes the total within-cluster variance; merges clusters with the smallest increase in total variance.
# gaverage = Merges clusters based on the distance between their centroids (means of points in clusters).
m <- c( "average", "single", "complete", "ward", "gaverage")
names(m) <- c( "average", "single", "complete", "ward", "gaverage")

# function to compute coefficient
ac <- function(x) {
  agnes(diss_matrix, method = x, diss = TRUE, par.method = -0.25)$ac}

# Best method?
map_dbl(m, ac)

# Best method is g average at 0.8563148 


#########################
#### Find optimal number of clusters

# Scree plot  
fviz_nbclust(df, FUN = hcut, diss = d, method = "wss")

# Average Silhouette
# Measures how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The Average Silhouette Width is the mean of all silhouette scores within a cluster or across all clusters.
# S ≈ 1: The point is well clustered
fviz_nbclust(df, FUN = hcut, diss = d, method = "silhouette")
# 4 groups has highest Avg. sillhouete width

# Gap Stat
# Compares the total within-cluster variation for different numbers of clusters with their expected values under a null reference distribution of the data (i.e., uniformly distributed points).
# The optimal number of clusters is the smallest k such that the Gap Statistic is maximized or the first local maximum occurs, indicating that adding more clusters does not significantly improve the clustering.
fviz_nbclust(df, FUN = hcut, diss = d, method = "gap_stat")
# Eight clusters is best, adding more clusteres doesn't improve clustering
# My conclusion is 5 clusters is optimum


# Above tests suggest at least two, but are also not conclusive...

# Define function to compute Mantel correlation tests for different cluster assignments
compute_mantel_correlation <- function(hclust_obj, distance_matrix) {

  # Initialize variables to store results
  mantel_correlation <- numeric(length = length(hclust_obj$order) - 1)
  
  # Iterate through different numbers of clusters
  for (k in 2:length(hclust_obj$order)) {
    cluster_assignments <- cutree(hclust_obj, k = k)
    cluster_distance <- as.matrix(dist(cluster_assignments))
    mantel_result <- mantel(cluster_distance, distance_matrix)
    mantel_correlation[k - 1] <- mantel_result$statistic
    # Print Mantel correlation for each number of clusters
    print(paste("Mantel Correlation (r) for", k, "clusters:", mantel_result$statistic))
  }
  
  return(mantel_correlation)
}

# Create Cluster and then run tests
Hclust.result <- agnes(d, method = "gaverage", par.method = -0.25)
mantel_results <- round(compute_mantel_correlation(Hclust.result, d), 3)

# Find the optimal number of clusters based on the largest Mantel correlation, r
optimal_clusters <- which.max(mantel_results) + 1  # Add 1 to convert index to number of clusters
print(paste("Optimal Number of Clusters:", optimal_clusters))
# 4 groups = 0.608 
# 6 groups = 0.560
# 5 groups = 0.554
# 7 groups = 0.520




####
#### Use ISA to determine optimal clusters

# Function to run multipatt() on k iterations of clusters and extract ISA values
run_multipatt_and_extract_ISA <- function(data, max_clusters) {
  
  # Initialize an empty dataframe to store ISA values
  isa_df <- data.frame(Species = colnames(data))
  
  # Iterate through different numbers of clusters
  for (k in 2:max_clusters) {
    cluster_assignments <- cutree(agnes(vegdist(data, method = "bray"), method = "gaverage", par.method = -0.25), k = k)
    
    # Convert cluster assignments to a factor
    cluster_factor <- as.factor(cluster_assignments)
    
    # Run multipatt() with the cluster factor
    multipatt_result <- multipatt(data, cluster = cluster_factor, duleg = FALSE)
    
    # Extract ISA values and p-values
    isa_values <- multipatt_result$sign$index
    p_values <- multipatt_result$sign$p.value
    
    # Filter by p-value <= 0.05
    significant_isa_values <- ifelse(p_values <= 0.05, isa_values, NA)
    
    # Extract ISA values for each species and add to the dataframe
    isa_df[[as.character(k)]] <- significant_isa_values
  }
  
  return(isa_df)
}


max_clusters <- 10  # Maximum number of clusters to iterate through

# Run multipatt() and extract ISA values for each species
isa_data <- run_multipatt_and_extract_ISA(df, max_clusters)

# Frequency distribution of number of significant ISA in each cluster step
frq.ISA <- isa_data %>%
  pivot_longer(cols = 2:10, names_to = "Cluster", values_to = "ISA_SCORE") %>%
  drop_na() %>% 
  group_by(Cluster) %>% 
  summarise(count = n()) %>% 
  arrange(as.numeric(Cluster))


#######
# Now calculate the sum of the differences in ISA scores from one step to the next
# When the indicator values of all species are decreasing, the clustering method does not explain anything more. 
# Take difference of species index values

isa.diff.data <- isa_data %>% 
  mutate(k2 = `2`-`3`) %>% 
  mutate(k3 = `3`-`4`) %>%
  mutate(k4 = `4`-`5`) %>%
  mutate(k5 = `5`-`6`) %>%
  mutate(k6 = `6`-`7`) %>%
  mutate(k7 = `7`-`8`) %>%
  mutate(k8 = `8`-`9`) %>%
  mutate(k9 = `9`-`10`) 

isa.diff.sum <- isa.diff.data %>%
  dplyr::select(Species, 11:18) %>% 
  pivot_longer(cols = 2:9, names_to = "Cluster", values_to = "ISA_SCORE") %>% 
  drop_na() %>%
  filter(ISA_SCORE <= 0) %>% 
  arrange(by = Cluster) %>% 
  group_by(Cluster) %>% 
  summarise(sum = sum(ISA_SCORE))


ggplot(isa.diff.sum,
       aes(x = Cluster,
           y = sum)) +
  geom_bar(stat = "identity") +
  labs(title = "", x = "Cluster", y = "Value") +
  theme_minimal()

# The differences from 2 to 3 groups (-8) and from 3 to 4 groups (-4) are small, 
# indicating that moving from 2 to 4 clusters doesn’t significantly improve the ISA scores. 
# This suggests that the structure in the data is relatively stable with these numbers of clusters, 
# and adding more groups is not greatly improving how well species are associated with their clusters.

# The difference from 4 to 5 groups is -90, which is a noticeable drop. This indicates that introducing a 5th cluster starts to capture more distinct ecological patterns, improving the ISA scores.

# Optimal Number of Clusters:
# 4 clusters may be suboptimal due to the small improvement seen moving to 4 clusters from 3 (-4).
# 5 clusters is likely the best choice. The drop to -90 suggests that the 5-cluster solution 
# is where distinct ecological patterns are maximized before significant over-segmentation occurs.
# Adding more than 5 clusters likely results in diminishing returns, as indicated by the sharp declines in ISA scores.


# Doing 5 clusters! 
# Beta average
hcluster.abs.cover <- agnes(d, method = "gaverage", par.method = -0.25)

plot(hcluster.abs.cover)
rect.hclust(hcluster.abs.cover, k = 5)


# Cut tree into groups
sub_grp <- cutree(hcluster.abs.cover, k = 5)


# Number of members in each cluster
table(sub_grp)

# Combine group labels into species matrix
temp.df <- abs.cover.species.matrix.df %>% 
  rownames_to_column() 

my_groups <- as.data.frame(sub_grp) %>% 
  rownames_to_column()

abs.cover.subgrp.df <- left_join(temp.df, my_groups, by = "rowname")




################
# Indicator Species Analysis

ISA.abs.cover <- multipatt(x = df, cluster = sub_grp, duleg = FALSE)

# A = The values are the **specificity** component of IV for that species in that combination of groups.
# B = The values are the **fidelity** component of IV for that species in that combination of groups
summary(ISA.abs.cover, indvalcomp=TRUE)





##############
# Does community composition differ among sites?

# Check for homogeneity of dispersion among groups, required for MANOVA
trt <- as.character(my_groups$sub_grp)

# There is significant dispersion within groups, and groups are unbalanced --- cannot use MANOVA (adonis)
anova(betadisper(d, trt))

mod <- betadisper(d, trt)

TukeyHSD(mod)

boxplot(mod)

plot(mod)

# Best option is MRPP
# The key idea is simple: if groups differ, the mean within-group dissimilarity should be smaller
# than the mean dissimilarity among randomly selected groups of the same size.
# Sort of low effect size but groups are meaningful!
results <- mrpp(d, grouping = sub_grp, permutations = 999)
results


```



```{r}


# Step 3: Perform hierarchical clustering
clustering <- hclust(diss_matrix, method = "ward.D2")  # Ward's method

# Step 4: Plot the dendrogram
plot(clustering, labels = rownames(data), main = "Hierarchical Clustering Dendrogram")
plot(clustering, labels = data_pc$site_rep, main = "Hierarchical Clustering Dendrogram")


# Optionally, cut the tree to form clusters
cluster_2 <- cutree(clustering, k = 2)  # Cut the tree into 2 clusters
table(cluster_2)
data_pc$cluster_2 <- cluster_2

cluster_3 <- cutree(clustering, k = 3)  # Cut the tree into 3 clusters
table(cluster_3)
data_pc$cluster_3 <- cluster_3

cluster_4 <- cutree(clustering, k = 4)  # Cut the tree into 4 clusters
table(cluster_4)
data_pc$cluster_4 <- cluster_4

cluster_5 <- cutree(clustering, k = 5)  # Cut the tree into 4 clusters
table(cluster_5)
data_pc$cluster_5 <- cluster_5

cluster_6 <- cutree(clustering, k = 6)  # Cut the tree into 4 clusters
table(cluster_6)
data_pc$cluster_6 <- cluster_6

cluster_7 <- cutree(clustering, k = 7)  # Cut the tree into 4 clusters
table(cluster_7)
data_pc$cluster_7 <- cluster_7

cluster_8 <- cutree(clustering, k = 8)  # Cut the tree into 4 clusters
table(cluster_8)
data_pc$cluster_8 <- cluster_8

cluster_9 <- cutree(clustering, k = 9)  # Cut the tree into 4 clusters
table(cluster_9)
data_pc$cluster_9 <- cluster_9

cluster_10 <- cutree(clustering, k = 10)  # Cut the tree into 4 clusters
table(cluster_10)
data_pc$cluster_10 <- cluster_10
```

```{r}
plot(clustering, labels = data_pc$cluster_2, main = "Hierarchical Clustering Dendrogram") # splits are ranked by the height of their splits
plot(clustering, labels = data_pc$cluster_3, main = "Hierarchical Clustering Dendrogram")
plot(clustering, labels = data_pc$cluster_4, main = "Hierarchical Clustering Dendrogram")

plot(clustering, labels = data_pc$cluster_5, main = "Hierarchical Clustering Dendrogram") # these seem to be the major splits
plot(clustering, labels = data_pc$cluster_6, main = "Hierarchical Clustering Dendrogram") # this is the beginning of the smaller (less significant?) splits

plot(clustering, labels = data_pc$cluster_7, main = "Hierarchical Clustering Dendrogram") # HIIN is significant here
plot(clustering, labels = data_pc$cluster_8, main = "Hierarchical Clustering Dendrogram")
plot(clustering, labels = data_pc$cluster_9, main = "Hierarchical Clustering Dendrogram")
plot(clustering, labels = data_pc$cluster_10, main = "Hierarchical Clustering Dendrogram")
```

```{r indicator species}

# Assume `species_data` is your community data matrix (sites as rows, species as columns)
# Assume `clusters` is a vector defining the group membership for each site

# Run the Indicator Species Analysis
isa_results_2 <- multipatt(data, cluster_2, control = how(nperm=999))
# Summarize the results
summary(isa_results_2)
# View the significant indicator species
species_pvalues_2 <- isa_results_2$sign
significant_species_2 <- species_pvalues_2 %>% 
  filter(p.value <= 0.05)
significant_species_2

isa_results_3 <- multipatt(data, cluster_3, control = how(nperm=999))
summary(isa_results_3)
species_pvalues_3 <- isa_results_3$sign
significant_species_3 <- species_pvalues_3 %>% 
  filter(p.value <= 0.05)
significant_species_3

isa_results_4 <- multipatt(data, cluster_4, control = how(nperm=999))
summary(isa_results_4)
species_pvalues_4 <- isa_results_4$sign
significant_species_4 <- species_pvalues_4 %>% 
  filter(p.value <= 0.05)
significant_species_4

isa_results_5 <- multipatt(data, cluster_5, control = how(nperm=999)) # <- 5 clusters
summary(isa_results_5)

summary()isa_results <- multipatt(data, cluster_6, control = how(nperm=999)) # <- 6 clusters

isa_results <- multipatt(data, cluster_7, control = how(nperm=999))
isa_results <- multipatt(data, cluster_8, control = how(nperm=999))
isa_results <- multipatt(data, cluster_9, control = how(nperm=999))
isa_results <- multipatt(data, cluster_10, control = how(nperm=999))


```

```{r example, echo=FALSE}
# library(cluster)
# silhouette_5 <- silhouette(cluster_5, dist(data_pc))
# silhouette_6 <- silhouette(cluster_6, dist(data_pc))

# NOT RUN {
set.seed(123)

# Data preparation
# +++++++++++++++
data("iris")
head(iris)
# Remove species column (5) and scale the data
iris.scaled <- scale(iris[, -5])


# Optimal number of clusters in the data
# ++++++++++++++++++++++++++++++++++++++
# Examples are provided only for kmeans, but
# you can also use cluster::pam (for pam) or
#  hcut (for hierarchical clustering)
 
### Elbow method (look at the knee)
# Elbow method for kmeans
fviz_nbclust(iris.scaled, kmeans, method = "wss") +
geom_vline(xintercept = 4, linetype = 2)

# Average silhouette for kmeans
fviz_nbclust(iris.scaled, kmeans, method = "silhouette")

### Gap statistic
library(cluster)
set.seed(123)
# Compute gap statistic for kmeans
# we used B = 10 for demo. Recommended value is ~500
gap_stat <- clusGap(iris.scaled, FUN = kmeans, nstart = 25,
 K.max = 10, B = 10)
 print(gap_stat, method = "firstmax")
fviz_gap_stat(gap_stat)
 
# Gap statistic for hierarchical clustering
gap_stat <- clusGap(iris.scaled, FUN = hcut, K.max = 10, B = 10)
fviz_gap_stat(gap_stat)

 
# 
```


```