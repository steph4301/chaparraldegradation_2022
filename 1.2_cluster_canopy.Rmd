---
title: "Stand Deg: cluster analysis - canopy only"
author: "Stephanie Ma Lucero"
date: "2024-04-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### data load
```{r}

# standheight_load <- load df from 1.1_transect_continuous.Rmd

canopycomm_prep <- standheight %>% 
  dplyr::select(site_rep, distance, species) %>% 
   mutate(species = case_when( # oldname ~ newname
                              species == "ACGL Acmispon glaber" ~ "Acmispon glaber",
                              species %in% c("dead Acmispon glaber") ~ "Acmispon glaber dead",
                              species %in% c("ELCO") ~ "Elymus condensatus",
                              species %in% c("ELCO dead", "d elco") ~ "Elymus condensatus dead",
                              species == "ARCA" ~ "Artemisia californica",
                              species %in% c("avba", "AVBA", "AVBA dead", "Avena", "dd AVBA") ~ "Avena barbata",
                               species %in% c("BRDI", "dd BRDI", "Bromus diandrus BRDI") ~ "Bromus diandrus",
                               species %in% c("BRHO", "Bromus hordeaceus BRHO") ~ "Bromus hordeaceus",
                              species %in% c("BRMA", "Bromus rubens BRRU", "BRRU", "brru", "BRRU dead") ~ "Bromus rubens",
                              species %in% c("Brome spp.", "Brome spp. Dead") ~ "Bromus spp.",
                              species %in% c("CEME dead", "CENMEL", "d ceme") ~ "Centaurea melitensis",
                              species == "DICA" ~ "Dipterostemon capitatus",
                             species  %in% c("HIIN", "hiin", "HIIN dead", "HIIN Hirschfeldia incana - long pods", "Hirschfeldia incana - long pods", "dead HIIN") ~ "Hirschfeldia incana",
                            
                              species  %in% c("MAFA", "mafa", "Malacothamnus fasciculatus ") ~ "Malacothamnus fasciculatus",
                             species == "CEOL dead" ~ "Ceanothus oliganthus dead",
                              species == "CEOL" ~ "Ceanothus oliganthus",
                              species %in% c("dead MAFA", "MAFA dead", "dd MAFA") ~ "Malacothamnus fasciculatus dead",
                              species == "dead ARCA" ~ "Artemisia californica dead",
                             species %in% c("SALE", "Salvia lucophylla") ~ "Salvia leucophylla",
                              species %in% c("SALE dead", "dead SALE") ~ "Salvia leucophylla dead",
                             species %in% c("RHOV", "rhov") ~ "Rhus ovata",
                             species == "HEAR dead" ~ "Heteromeles arbutifolia dead", 
                             species == "HEAR" ~ "Heteromeles arbutifolia", 
                             species == "dead RHIL" ~ "Rhamnus ilicifolia",
                             
                             species %in% c("Cryptantha sp.") ~ "Cryptantha spp.",
                             species %in% c("MAMA", "mama", "MAMA dead") ~ "Marah macrocarpa",
                             species %in% c("ERCI", "erci") ~   "Erodium cicutarium",     
                             species %in% c("STLE") ~   "Stipa lepida",     
                             species %in% c("URCR") ~   "Eriodictyon crassifolium",  
                             species  %in% c("DICA", "dica") ~ "Dipterostemon capitatus",
                             species == "Rapistrum rugosum - round pods" ~ "Rapistrum rugosum",
                             species %in% c("no_species") ~ "bare_ground",
                             
                             
                              TRUE ~ species)) 
  

# sort(unique(canopycomm_prep$species))

canopycomm <- canopycomm_prep %>% 
   mutate(species = case_when( 
          species %in% c("Acmispon glaber dead", "Astragalus trichopodus",
                         "Acmispon glaber", "Apiastrum angustifolium") ~ "subshrub",  
          
          species %in% c("Stipa lepida") ~ "nativegrass",
          
          species %in% c("Artemisia californica", "Artemisia californica dead") ~ "decid.shrub",
          
           species %in% c("Ceanothus oliganthus", "Ceanothus oliganthus dead"
                          ) ~ "evg.shrub",
          
          species %in% c("Bromus diandrus", "Avena barbata", "Bromus spp.", "Bromus rubens", "Bromus diandrus", "Bromus hordeaceus", "Festuca myros") ~ "nngrass",
                             
          species %in% c("Centaurea melitensis", "Hirschfeldia incana") ~
            "nnforb",
                             
                              TRUE ~ species)) 
  
sort(unique(canopycomm$species))


```

```{r}
canopycomm_perccover <- canopycomm %>% 
  group_by(site_rep, species) %>%  
  summarize (n = length(species)) %>% 
  mutate(percent_cover = round((n/41*100),2)) %>% 
  ungroup() %>% 
  dplyr::select(-n) %>% 
  mutate(species = gsub(" ", ".", species)) %>% 
  pivot_wider(names_from = species, 
              values_from = percent_cover, 
              values_fill = list(percent_cover = 0.00)
              ) 
  

```


### cluster
```{r}
df <- canopycomm_perccover %>% 
  dplyr::select(!c(site_rep))

d <- vegdist(df, method = "bray")  # Bray-Curtis dissimilarity
# Calculate distance measure matrix, Bray is the best for community data
# Jaccard Index and Sorensen-Dice Coefficient treat percent cover data as binary (present/absent)
 
# Check which method produces best clustering
# average = Computes the average distance between all pairs of observations across two clusters.
# single = Uses the minimum distance between pairs of observations in two clusters.
# complete = Considers the maximum distance between pairs of observations in two clusters.
# ward = Minimizes the total within-cluster variance; merges clusters with the smallest increase in total variance.
# gaverage = Merges clusters based on the distance between their centroids (means of points in clusters).
m <- c( "average", "single", "complete", "ward", "gaverage")
names(m) <- c( "average", "single", "complete", "ward", "gaverage")

# function to compute coefficient
ac <- function(x) {
  agnes(d, method = x, diss = TRUE, par.method = -0.25)$ac}

# Best method?
map_dbl(m, ac)
# Best method is g average at 0.8553286 = Flexible Beta method


#########################
#### Find optimal number of clusters - k-means clustering

# Scree plot  
fviz_nbclust(df, FUN = hcut, diss = d, method = "wss") # Elbow method for kmeans

# Average Silhouette
# Measures how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The Average Silhouette Width is the mean of all silhouette scores within a cluster or across all clusters.
# S â‰ˆ 1: The point is well clustered
fviz_nbclust(df, FUN = hcut, diss = d, method = "silhouette") # Average silhouette for kmeans
# 9 groups has highest Avg. sillhouete width

# Gap Stat
# Compares the total within-cluster variation for different numbers of clusters with their expected values under a null reference distribution of the data (i.e., uniformly distributed points).
# The optimal number of clusters is the smallest k such that the Gap Statistic is maximized or the first local maximum occurs, indicating that adding more clusters does not significantly improve the clustering.
fviz_nbclust(df, FUN = hcut, diss = d, method = "gap_stat")
# Eight clusters is best, adding more clusteres doesn't improve clustering
# My conclusion is 5 clusters is optimum


# Above tests suggest at least two, but are also not conclusive...

# Define function to compute Mantel correlation tests for different cluster assignments
compute_mantel_correlation <- function(hclust_obj, distance_matrix) {

  # Initialize variables to store results
  mantel_correlation <- numeric(length = length(hclust_obj$order) - 1)
  
  # Iterate through different numbers of clusters
  for (k in 2:length(hclust_obj$order)) {
    cluster_assignments <- cutree(hclust_obj, k = k)
    cluster_distance <- as.matrix(dist(cluster_assignments))
    mantel_result <- mantel(cluster_distance, distance_matrix)
    mantel_correlation[k - 1] <- mantel_result$statistic
    # Print Mantel correlation for each number of clusters
    print(paste("Mantel Correlation (r) for", k, "clusters:", mantel_result$statistic))
  }
  
  return(mantel_correlation)
}

# Create Cluster and then run tests
Hclust.result <- agnes(d, method = "gaverage", par.method = -0.25)
mantel_results <- round(compute_mantel_correlation(Hclust.result, d), 3)

# Find the optimal number of clusters based on the largest Mantel correlation, r
optimal_clusters <- which.max(mantel_results) + 1  # Add 1 to convert index to number of clusters
print(paste("Optimal Number of Clusters:", optimal_clusters))
# 4 groups = 0.608 
# 6 groups = 0.560
# 5 groups = 0.554
# 7 groups = 0.520




####
#### Use ISA (indicator species analysis) to determine optimal clusters

# Function to run multipatt() on k iterations of clusters and extract ISA values
run_multipatt_and_extract_ISA <- function(data, max_clusters) {
  
  # Initialize an empty dataframe to store ISA values
  isa_df <- data.frame(Species = colnames(data))
  
  # Iterate through different numbers of clusters
  for (k in 2:max_clusters) {
    cluster_assignments <- cutree(agnes(vegdist(data, method = "bray"), method = "gaverage", par.method = -0.25), k = k)
    
    # Convert cluster assignments to a factor
    cluster_factor <- as.factor(cluster_assignments)
    
    # Run multipatt() with the cluster factor
    multipatt_result <- multipatt(data, cluster = cluster_factor, duleg = FALSE)
    
    # Extract ISA values and p-values
    isa_values <- multipatt_result$sign$index
    p_values <- multipatt_result$sign$p.value
    
    # Filter by p-value <= 0.05
    significant_isa_values <- ifelse(p_values <= 0.05, isa_values, NA)
    
    # Extract ISA values for each species and add to the dataframe
    isa_df[[as.character(k)]] <- significant_isa_values
  }
  
  return(isa_df)
}


max_clusters <- 10  # Maximum number of clusters to iterate through

# Run multipatt() and extract ISA values for each species
isa_data <- run_multipatt_and_extract_ISA(df, max_clusters)

# Frequency distribution of number of significant ISA in each cluster step
frq.ISA <- isa_data %>%
  pivot_longer(cols = 2:10, names_to = "Cluster", values_to = "ISA_SCORE") %>%
  drop_na() %>% 
  group_by(Cluster) %>% 
  summarise(count = n()) %>% 
  arrange(as.numeric(Cluster))


#######
# Now calculate the sum of the differences in ISA scores from one step to the next
# When the indicator values of all species are decreasing, the clustering method does not explain anything more. 
# Take difference of species index values

isa.diff.data <- isa_data %>% 
  mutate(k2 = `2`-`3`) %>% 
  mutate(k3 = `3`-`4`) %>%
  mutate(k4 = `4`-`5`) %>%
  mutate(k5 = `5`-`6`) %>%
  mutate(k6 = `6`-`7`) %>%
  mutate(k7 = `7`-`8`) %>%
  mutate(k8 = `8`-`9`) %>%
  mutate(k9 = `9`-`10`) 

isa.diff.sum <- isa.diff.data %>%
  dplyr::select(Species, 11:18) %>% 
  pivot_longer(cols = 2:9, names_to = "Cluster", values_to = "ISA_SCORE") %>% 
  drop_na() %>%
  filter(ISA_SCORE <= 0) %>% 
  arrange(by = Cluster) %>% 
  group_by(Cluster) %>% 
  summarise(sum = sum(ISA_SCORE))


ggplot(isa.diff.sum,
       aes(x = Cluster,
           y = sum)) +
  geom_bar(stat = "identity") +
  labs(title = "", x = "Cluster", y = "Value") +
  theme_minimal()

# The differences from 2 to 3 groups (-8) and from 3 to 4 groups (-4) are small, 
# indicating that moving from 2 to 4 clusters doesnâ€™t significantly improve the ISA scores. 
# This suggests that the structure in the data is relatively stable with these numbers of clusters, 
# and adding more groups is not greatly improving how well species are associated with their clusters.

# The difference from 4 to 5 groups is -90, which is a noticeable drop. This indicates that introducing a 5th cluster starts to capture more distinct ecological patterns, improving the ISA scores.

# Optimal Number of Clusters:
# 4 clusters may be suboptimal due to the small improvement seen moving to 4 clusters from 3 (-4).
# 5 clusters is likely the best choice. The drop to -90 suggests that the 5-cluster solution 
# is where distinct ecological patterns are maximized before significant over-segmentation occurs.
# Adding more than 5 clusters likely results in diminishing returns, as indicated by the sharp declines in ISA scores.


# Doing 5 clusters! 
# Beta average
hcluster.abs.cover <- agnes(d, method = "gaverage", par.method = -0.25)
# Negative values of beta (e.g., -0.25) make the clustering process more similar to single linkage (minimum distance between clusters).

# Positive values of beta make the process more similar to complete linkage (maximum distance). beta = 0 corresponds to the standard average linkage (UPGMA).

plot(hcluster.abs.cover)
rect.hclust(hcluster.abs.cover, k = 4)


# Cut tree into groups
sub_grp <- cutree(hcluster.abs.cover, k = 5)

# Number of members in each cluster
table(sub_grp)

# Calculate the distance to centroid for each cluster
bd <- betadisper(d, sub_grp)
centroid_coords <- bd$centroids
centroid_distances <- round(vegdist(centroid_coords, method = "euclidean"), 2) # Calculate the distances between the centroids
#     1    2    3    4
# 2 0.76               
# 3 0.65 0.86          
# 4 0.62 0.59 0.62     
# 5 0.81 0.77 0.80 0.65

# Combine group labels into species matrix
temp.df2 <- data_pc %>%
  rownames_to_column()

my_groups2 <- as.data.frame(sub_grp) %>%
  rownames_to_column()

cluster.subgrp.df_prep2 <- left_join(temp.df2, my_groups2, by = "rowname")

# # Create a combined label
# cluster.subgrp.df$combined_labels <- paste(cluster.subgrp.df$sub_grp, # <-- oringinal code cluster.subgrp.df$site_rep, sep = " - ")
cluster.subgrp.df2 <- cluster.subgrp.df_prep2 %>% 
  mutate(sub_grp_name = recode(sub_grp,
                                 "1" = "1",
                                 "2" = "2",
                                 "3" = "3",
                                 "4" = "4",
                                "5" = "5"
                          )) %>%

   mutate(combined_labels = paste(sub_grp_name, site_rep, sep = "."))

# Plot the hierarchical clustering dendrogram with the combined labels
### oringinal code
plot(hcluster.abs.cover, 
     labels = cluster.subgrp.df2$combined_labels, 
     main = "Hierarchical Clustering Dendrogram")
rect.hclust(hcluster.abs.cover, k = 5)

hcluster.abs.cover_obj <- as.hclust(hcluster.abs.cover)
plot(
  hcluster.abs.cover_obj,
  labels = cluster.subgrp.df$combined_labels,
  main = "Hierarchical Clustering Dendrogram",
  cex.main = 1.5,         # Increase title size
  cex = 1.2,  # Adjust this value as needed to enlarge text
   hang = -1               # Better spacing
)
rect.hclust(hcluster.abs.cover_obj, k = 5, border = "red", )



################
# Indicator Species Analysis

ISA.abs.cover <- multipatt(x = df, cluster = sub_grp, duleg = FALSE)

# A = The values are the **specificity** component of IV for that species in that combination of groups.
# B = The values are the **fidelity** component of IV for that species in that combination of groups
summary(ISA.abs.cover, indvalcomp=TRUE)

# Multilevel pattern analysis
#  ---------------------------
# 
#  Association function: IndVal.g
#  Significance level (alpha): 0.05
# 
#  Total number of species: 44
#  Selected number of species: 7 
#  Number of species associated to 1 group: 5 
#  Number of species associated to 2 groups: 2 
#  Number of species associated to 3 groups: 0 
#  Number of species associated to 4 groups: 0 
# 
#  List of species associated to each combination: 
# 
# 
#  Group 1+3  #sps.  2 
#                          A      B  stat p.value   
# Avena.barbata       0.9185 1.0000 0.958   0.005 **
# Hirschfeldia.incana 0.9121 0.6842 0.790   0.010 **
# 
# 
# 
# 
#  Group 2  #sps.  1 
#                                 A      B  stat p.value   
# Malacothamnus.fasciculatus 0.7766 1.0000 0.881   0.005 **
# 
# 
# 
#  Group 3  #sps.  1 
#                      A      B  stat p.value   
# Bromus.diandrus 0.7822 1.0000 0.884   0.005 **
# 
# 
# 
# 
#  Group 5  #sps.  3 
#                                   A      B  stat p.value   
# native_litter                0.9750 1.0000 0.987   0.005 **
# Heteromeles.arbutifolia      0.7379 1.0000 0.859   0.005 **
# Heteromeles.arbutifolia.dead 0.9719 0.6667 0.805   0.010 **
# 
# 
# 
# ---
# Signif. codes:  0 â€˜***â€™ 0.001 â€˜**â€™ 0.01 â€˜*â€™ 0.05 â€˜.â€™ 0.1 â€˜ â€™ 1 




##############
# Does community composition differ among sites?

# Check for homogeneity of dispersion among groups, required for MANOVA
trt <- as.character(my_groups$sub_grp)

# There is significant dispersion within groups, and groups are unbalanced --- cannot use MANOVA (adonis)
anova(betadisper(d, trt))
# A low p-value (e.g., < 0.05) indicates that the dispersion (variance) among groups is significantly different, meaning that the assumption of homogeneity of dispersion is violated.

mod <- betadisper(d, trt)

TukeyHSD(mod)

boxplot(mod)

plot(mod)

# Best option is MRPP
# The key idea is simple: if groups differ, the mean within-group dissimilarity should be smaller
# than the mean dissimilarity among randomly selected groups of the same size.
results <- mrpp(d, grouping = sub_grp, permutations = 999)
results
# Call:
# mrpp(dat = d, grouping = sub_grp, permutations = 999) 
# 
# Dissimilarity index: bray 
# Weights for groups:  n 
# 
# Class means and counts:
# 
#       1      2      3      4      5     
# delta 0.2092 0.2408 0.1518 0.1582 0.1561 <- within-group dissimilarity
# n     10     7      10     8      5     
# 
# Chance corrected within-group agreement A: 0.592 
# Based on observed delta 0.1835 and expected delta 0.4498  <- randomly selected groups
# 
# Significance of delta: 0.001 <- p-value yay!
# Permutation: free
# Number of permutations: 999

```