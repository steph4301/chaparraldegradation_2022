xend = modelxend,
y = modelybeg,
yend = modelyend)
# second row of the psi-matrix
my.lines <- data.frame(psi = my.seg$psi[, 2], label = round(my.seg$psi[, 2], digits = 3))
r2 <- round(summary(my.seg)$adj.r.squared, digits = 4)
modelgraph_nnngrass <- p1 +
geom_point(aes(shape = standtype.y, color = standtype.y)) +
scale_color_manual(values = c("salmon2", "green4", "lightblue3"),
name = "Stand Type",
labels = c("intact" = "shrub dominated",
"matrix" = "matrix",
"degraded" = "grass dominated")) +
geom_vline(xintercept = my.lines$psi, linetype = "dashed") +
geom_segment(
data = segment_data,
mapping = aes(x=x, y=y, xend=xend, yend=yend),
inherit.aes = FALSE) +
geom_text(data = my.lines,
mapping = aes(x = psi, y = rep(0.85, length(my.lines$psi)), label = label),
inherit.aes = FALSE,
hjust = 1) +
geom_text(mapping = aes(x = 0.3, y = 0.8, hjust = 1, label=paste("Adjusted R Squared:", "\n", r2)), inherit.aes = FALSE)
modelgraph_nnngrass
# KIT - can you let me know if I ran this and the next chunck correctly - and why my shapes aren't showing up for this figure? Thank you!
abcover_nativecover_nngrasscover2 <- abcover_nativecover_nngrasscover
# [order(abcover_nativecover_nngrasscover$nonnative_forb, decreasing = TRUE),]
tail <- max(abcover_nativecover_nngrasscover2$native_shrub, n = 1)
p1 <- ggplot(abcover_nativecover_nngrasscover2, aes(y = nonnative_forb, x = native_shrub))
model <- lm(nonnative_forb ~ native_shrub, data = abcover_nativecover_nngrasscover2)
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model,
seg.Z = ~ native_shrub,
npsi = 2 #this is where you change number of thresholds?
)
bp <- as.data.frame(my.seg$psi)
bp <- as.list(bp$Est.)
bpcount <- length(bp) + 1
bpcount1 <- length(bp) - 1
modelxbeg <- rep(NaN, times = bpcount)
modelxend <- rep(NaN, times = bpcount)
modelybeg <- rep(NaN, times = bpcount)
modelyend <- rep(NaN, times = bpcount)
intercept <- rep(NaN, times = bpcount)
slope1 <- rep(NaN, times = bpcount)
break1 <- rep(NaN, times = bpcount)
for (i in 1:bpcount) {
break1[i] <- my.seg$psi[[i+bpcount1]]
if (i == 1) {
slope1[i] <- coef(my.seg)[[2]]
intercept[i] <- coef(my.seg)[[1]]
break1[i] <- 0 #min(abcover_nativecover_nngrasscover2$nonnative_forb, n = 1)
}
else {
slope1[i] <- slope1[i-1] + coef(my.seg)[[i+1]]
intercept[i] <- (intercept[i-1] + slope1[i-1]*break1[i]) - (slope1[i]*break1[i])
}
}
# KIT - can you let me know if I ran this and the next chunck correctly - and why my shapes aren't showing up for this figure? Thank you!
abcover_nativecover_nngrasscover2 <- abcover_nativecover_nngrasscover[order(abcover_nativecover_nngrasscover$nonnative_forb, decreasing = TRUE),]
tail <- max(abcover_nativecover_nngrasscover2$native_shrub, n = 1)
p1 <- ggplot(abcover_nativecover_nngrasscover2, aes(y = nonnative_forb, x = native_shrub))
model <- lm(nonnative_forb ~ native_shrub, data = abcover_nativecover_nngrasscover2)
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model,
seg.Z = ~ native_shrub,
npsi = 2 #this is where you change number of thresholds?
)
bp <- as.data.frame(my.seg$psi)
bp <- as.list(bp$Est.)
bpcount <- length(bp) + 1
bpcount1 <- length(bp) - 1
modelxbeg <- rep(NaN, times = bpcount)
modelxend <- rep(NaN, times = bpcount)
modelybeg <- rep(NaN, times = bpcount)
modelyend <- rep(NaN, times = bpcount)
intercept <- rep(NaN, times = bpcount)
slope1 <- rep(NaN, times = bpcount)
break1 <- rep(NaN, times = bpcount)
for (i in 1:bpcount) {
break1[i] <- my.seg$psi[[i+bpcount1]]
if (i == 1) {
slope1[i] <- coef(my.seg)[[2]]
intercept[i] <- coef(my.seg)[[1]]
break1[i] <- 0 #min(abcover_nativecover_nngrasscover2$nonnative_forb, n = 1)
}
else {
slope1[i] <- slope1[i-1] + coef(my.seg)[[i+1]]
intercept[i] <- (intercept[i-1] + slope1[i-1]*break1[i]) - (slope1[i]*break1[i])
}
}
# KIT - can you let me know if I ran this and the next chunck correctly - and why my shapes aren't showing up for this figure? Thank you!
abcover_nativecover_nngrasscover2 <- abcover_nativecover_nngrasscover[order(abcover_nativecover_nngrasscover$nonnative_forb, decreasing = TRUE),]
tail <- max(abcover_nativecover_nngrasscover2$native_shrub, n = 1)
p1 <- ggplot(abcover_nativecover_nngrasscover2, aes(y = nonnative_forb, x = native_shrub))
model <- lm(nonnative_forb ~ native_shrub, data = abcover_nativecover_nngrasscover2)
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model,
seg.Z = ~ native_shrub,
npsi = 1 #this is where you change number of thresholds?
)
bp <- as.data.frame(my.seg$psi)
bp <- as.list(bp$Est.)
bpcount <- length(bp) + 1
bpcount1 <- length(bp) - 1
modelxbeg <- rep(NaN, times = bpcount)
modelxend <- rep(NaN, times = bpcount)
modelybeg <- rep(NaN, times = bpcount)
modelyend <- rep(NaN, times = bpcount)
intercept <- rep(NaN, times = bpcount)
slope1 <- rep(NaN, times = bpcount)
break1 <- rep(NaN, times = bpcount)
for (i in 1:bpcount) {
break1[i] <- my.seg$psi[[i+bpcount1]]
if (i == 1) {
slope1[i] <- coef(my.seg)[[2]]
intercept[i] <- coef(my.seg)[[1]]
break1[i] <- 0 #min(abcover_nativecover_nngrasscover2$nonnative_forb, n = 1)
}
else {
slope1[i] <- slope1[i-1] + coef(my.seg)[[i+1]]
intercept[i] <- (intercept[i-1] + slope1[i-1]*break1[i]) - (slope1[i]*break1[i])
}
}
modelxend <- c(tail(break1, n = length(break1)-1), tail)
for (i in 1:bpcount) {
modelybeg[i] <- slope1[i]*break1[i] + intercept[i]
modelyend[i] <- slope1[i]*modelxend[i] + intercept[i]
}
segment_data = data.frame(
x = break1,
xend = modelxend,
y = modelybeg,
yend = modelyend)
# second row of the psi-matrix
my.lines <- data.frame(psi = my.seg$psi[, 2], label = round(my.seg$psi[, 2], digits = 3))
r2 <- round(summary(my.seg)$adj.r.squared, digits = 4)
modelgraph_nnngrass <- p1 +
geom_point(aes(shape = standtype.y, color = standtype.y)) +
scale_color_manual(values = c("salmon2", "green4", "lightblue3"),
name = "Stand Type",
labels = c("intact" = "shrub dominated",
"matrix" = "matrix",
"degraded" = "grass dominated")) +
geom_vline(xintercept = my.lines$psi, linetype = "dashed") +
geom_segment(
data = segment_data,
mapping = aes(x=x, y=y, xend=xend, yend=yend),
inherit.aes = FALSE) +
geom_text(data = my.lines,
mapping = aes(x = psi, y = rep(0.85, length(my.lines$psi)), label = label),
inherit.aes = FALSE,
hjust = 1) +
geom_text(mapping = aes(x = 0.3, y = 0.8, hjust = 1, label=paste("Adjusted R Squared:", "\n", r2)), inherit.aes = FALSE)
modelgraph_nnngrass
abcover_nativecover_nngrasscover2 <- abcover_nativecover_nngrasscover[order(abcover_nativecover_nngrasscover$native_forb, decreasing = TRUE),]
tail <- max(abcover_nativecover_nngrasscover2$native_forb, n = 1)
p1 <- ggplot(abcover_nativecover_nngrasscover2, aes(y = native_forb, x = native_shrub))
model <- lm(native_forb ~ native_shrub, data = abcover_nativecover_nngrasscover2)
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model, npsi = 2)
plot(fitted(my.seg))
bp <- as.data.frame(my.seg$psi)
bp <- as.list(bp$Est.)
bpcount <- length(bp) + 1
bpcount1 <- length(bp) - 1
modelxbeg <- rep(NaN, times = bpcount)
modelxend <- rep(NaN, times = bpcount)
modelybeg <- rep(NaN, times = bpcount)
modelyend <- rep(NaN, times = bpcount)
intercept <- rep(NaN, times = bpcount)
slope1 <- rep(NaN, times = bpcount)
break1 <- rep(NaN, times = bpcount)
for (i in 1:bpcount) {
break1[i] <- my.seg$psi[[i+bpcount1]]
if (i == 1) {
slope1[i] <- coef(my.seg)[[2]]
intercept[i] <- coef(my.seg)[[1]]
break1[i] <- min(abcover_nativecover_nngrasscover2$percentcover_native, n = 1)
}
else {
slope1[i] <- slope1[i-1] + coef(my.seg)[[i+1]]
intercept[i] <- (intercept[i-1] + slope1[i-1]*break1[i]) - (slope1[i]*break1[i])
}
}
modelxend <- c(tail(break1, n = length(break1)-1), tail)
for (i in 1:bpcount) {
modelybeg[i] <- slope1[i]*break1[i] + intercept[i]
modelyend[i] <- slope1[i]*modelxend[i] + intercept[i]
}
segment_data = data.frame(
x = break1,
xend = modelxend,
y = modelybeg,
yend = modelyend)
# second row of the psi-matrix
my.lines <- data.frame(psi = my.seg$psi[, 2], label = round(my.seg$psi[, 2], digits = 3))
r2 <- round(summary(my.seg)$adj.r.squared, digits = 4)
modelgraph_nngrass <- p1 +
geom_point(aes(shape = standtype.x, color = standtype.x)) +
scale_color_manual(values = c("salmon2", "green4", "lightblue3"),
name = "Stand Type",
labels = c("intact" = "shrub dominated",
"matrix" = "matrix",
"degraded" = "grass dominated")) +
geom_vline(xintercept = my.lines$psi, linetype = "dashed") +
geom_segment(
data = segment_data,
mapping = aes(x=x, y=y, xend=xend, yend=yend),
inherit.aes = FALSE) +
geom_text(data = my.lines,
mapping = aes(x = psi, y = rep(0.85, length(my.lines$psi)), label = label),
inherit.aes = FALSE,
hjust = 1) +
geom_text(mapping = aes(x = 0.3, y = 0.8, hjust = 1, label=paste("Adjusted R Squared:", "\n", r2)), inherit.aes = FALSE)
modelgraph_nngrass
abcover_nativecover_nngrasscover2 <- abcover_nativecover_nngrasscover
# [order(abcover_nativecover_nngrasscover$native_forb, decreasing = TRUE),]
tail <- max(abcover_nativecover_nngrasscover2$native_forb, n = 1)
p1 <- ggplot(abcover_nativecover_nngrasscover2, aes(y = native_forb, x = native_shrub))
model <- lm(native_forb ~ native_shrub, data = abcover_nativecover_nngrasscover2)
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model, npsi = 2)
plot(fitted(my.seg))
bp <- as.data.frame(my.seg$psi)
bp <- as.list(bp$Est.)
bpcount <- length(bp) + 1
bpcount1 <- length(bp) - 1
modelxbeg <- rep(NaN, times = bpcount)
modelxend <- rep(NaN, times = bpcount)
modelybeg <- rep(NaN, times = bpcount)
modelyend <- rep(NaN, times = bpcount)
intercept <- rep(NaN, times = bpcount)
slope1 <- rep(NaN, times = bpcount)
break1 <- rep(NaN, times = bpcount)
for (i in 1:bpcount) {
break1[i] <- my.seg$psi[[i+bpcount1]]
if (i == 1) {
slope1[i] <- coef(my.seg)[[2]]
intercept[i] <- coef(my.seg)[[1]]
break1[i] <- min(abcover_nativecover_nngrasscover2$percentcover_native, n = 1)
}
else {
slope1[i] <- slope1[i-1] + coef(my.seg)[[i+1]]
intercept[i] <- (intercept[i-1] + slope1[i-1]*break1[i]) - (slope1[i]*break1[i])
}
}
modelxend <- c(tail(break1, n = length(break1)-1), tail)
for (i in 1:bpcount) {
modelybeg[i] <- slope1[i]*break1[i] + intercept[i]
modelyend[i] <- slope1[i]*modelxend[i] + intercept[i]
}
segment_data = data.frame(
x = break1,
xend = modelxend,
y = modelybeg,
yend = modelyend)
# second row of the psi-matrix
my.lines <- data.frame(psi = my.seg$psi[, 2], label = round(my.seg$psi[, 2], digits = 3))
r2 <- round(summary(my.seg)$adj.r.squared, digits = 4)
modelgraph_nngrass <- p1 +
geom_point(aes(shape = standtype.x, color = standtype.x)) +
scale_color_manual(values = c("salmon2", "green4", "lightblue3"),
name = "Stand Type",
labels = c("intact" = "shrub dominated",
"matrix" = "matrix",
"degraded" = "grass dominated")) +
geom_vline(xintercept = my.lines$psi, linetype = "dashed") +
geom_segment(
data = segment_data,
mapping = aes(x=x, y=y, xend=xend, yend=yend),
inherit.aes = FALSE) +
geom_text(data = my.lines,
mapping = aes(x = psi, y = rep(0.85, length(my.lines$psi)), label = label),
inherit.aes = FALSE,
hjust = 1) +
geom_text(mapping = aes(x = 0.3, y = 0.8, hjust = 1, label=paste("Adjusted R Squared:", "\n", r2)), inherit.aes = FALSE)
modelgraph_nngrass
abcover_nativecover_nngrasscover2 <- abcover_nativecover_nngrasscover[order(abcover_nativecover_nngrasscover$native_forb, decreasing = TRUE),]
tail <- max(abcover_nativecover_nngrasscover2$native_forb, n = 1)
p1 <- ggplot(abcover_nativecover_nngrasscover2, aes(y = native_forb, x = native_shrub))
model <- lm(native_forb ~ native_shrub, data = abcover_nativecover_nngrasscover2)
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model, npsi = 2)
plot(fitted(my.seg))
bp <- as.data.frame(my.seg$psi)
bp <- as.list(bp$Est.)
bpcount <- length(bp) + 1
bpcount1 <- length(bp) - 1
modelxbeg <- rep(NaN, times = bpcount)
modelxend <- rep(NaN, times = bpcount)
modelybeg <- rep(NaN, times = bpcount)
modelyend <- rep(NaN, times = bpcount)
intercept <- rep(NaN, times = bpcount)
slope1 <- rep(NaN, times = bpcount)
break1 <- rep(NaN, times = bpcount)
for (i in 1:bpcount) {
break1[i] <- my.seg$psi[[i+bpcount1]]
if (i == 1) {
slope1[i] <- coef(my.seg)[[2]]
intercept[i] <- coef(my.seg)[[1]]
break1[i] <- min(abcover_nativecover_nngrasscover2$percentcover_native, n = 1)
}
else {
slope1[i] <- slope1[i-1] + coef(my.seg)[[i+1]]
intercept[i] <- (intercept[i-1] + slope1[i-1]*break1[i]) - (slope1[i]*break1[i])
}
}
modelxend <- c(tail(break1, n = length(break1)-1), tail)
for (i in 1:bpcount) {
modelybeg[i] <- slope1[i]*break1[i] + intercept[i]
modelyend[i] <- slope1[i]*modelxend[i] + intercept[i]
}
segment_data = data.frame(
x = break1,
xend = modelxend,
y = modelybeg,
yend = modelyend)
# second row of the psi-matrix
my.lines <- data.frame(psi = my.seg$psi[, 2], label = round(my.seg$psi[, 2], digits = 3))
r2 <- round(summary(my.seg)$adj.r.squared, digits = 4)
modelgraph_nngrass <- p1 +
geom_point(aes(shape = standtype.x, color = standtype.x)) +
scale_color_manual(values = c("salmon2", "green4", "lightblue3"),
name = "Stand Type",
labels = c("intact" = "shrub dominated",
"matrix" = "matrix",
"degraded" = "grass dominated")) +
geom_vline(xintercept = my.lines$psi, linetype = "dashed") +
geom_segment(
data = segment_data,
mapping = aes(x=x, y=y, xend=xend, yend=yend),
inherit.aes = FALSE) +
geom_text(data = my.lines,
mapping = aes(x = psi, y = rep(0.85, length(my.lines$psi)), label = label),
inherit.aes = FALSE,
hjust = 1) +
geom_text(mapping = aes(x = 0.3, y = 0.8, hjust = 1, label=paste("Adjusted R Squared:", "\n", r2)), inherit.aes = FALSE)
modelgraph_nngrass
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model,
seg.Z = ~ nonnative_grass
)
abcover_nativecover_nngrasscover2 <- abcover_nativecover_nngrasscover[order(abcover_nativecover_nngrasscover$native_grass, decreasing = TRUE),]
tail <- max(abcover_nativecover_nngrasscover2$nonnative_grass, n = 1)
p1 <- ggplot(abcover_nativecover_nngrasscover2, aes(x = nonnative_grass, y = native_grass))
model <- lm(native_grass ~ nonnative_grass, data = abcover_nativecover_nngrasscover2)
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model,
seg.Z = ~ nonnative_grass
)
bp <- as.data.frame(my.seg$psi)
bp <- as.list(bp$Est.)
bpcount <- length(bp) + 1
bpcount1 <- length(bp) - 1
modelxbeg <- rep(NaN, times = bpcount)
modelxend <- rep(NaN, times = bpcount)
modelybeg <- rep(NaN, times = bpcount)
modelyend <- rep(NaN, times = bpcount)
intercept <- rep(NaN, times = bpcount)
slope1 <- rep(NaN, times = bpcount)
break1 <- rep(NaN, times = bpcount)
for (i in 1:bpcount) {
break1[i] <- my.seg$psi[[i+bpcount1]]
if (i == 1) {
slope1[i] <- coef(my.seg)[[2]]
intercept[i] <- coef(my.seg)[[1]]
break1[i] <- 0
}
else {
slope1[i] <- slope1[i-1] + coef(my.seg)[[i+1]]
intercept[i] <- (intercept[i-1] + slope1[i-1]*break1[i]) - (slope1[i]*break1[i])
}
}
modelxend <- c(tail(break1, n = length(break1)-1), tail)
for (i in 1:bpcount) {
modelybeg[i] <- slope1[i]*break1[i] + intercept[i]
modelyend[i] <- slope1[i]*modelxend[i] + intercept[i]
}
segment_data = data.frame(
x = break1,
xend = modelxend,
y = modelybeg,
yend = modelyend)
# second row of the psi-matrix
my.lines <- data.frame(psi = my.seg$psi[, 2], label = round(my.seg$psi[, 2], digits = 3))
r2 <- round(summary(my.seg)$adj.r.squared, digits = 4)
modelgraph_nngrass <- p1 +
geom_point(aes(shape = standtype.y, color = standtype.y)) +
scale_color_manual(values = c("salmon2", "green4", "lightblue3"),
name = "Stand Type",
labels = c("intact" = "shrub dominated",
"matrix" = "matrix",
"degraded" = "grass dominated")) +
geom_vline(xintercept = my.lines$psi, linetype = "dashed") +
geom_segment(
data = segment_data,
mapping = aes(x=x, y=y, xend=xend, yend=yend),
inherit.aes = FALSE) +
geom_text(data = my.lines,
mapping = aes(x = psi, y = rep(0.85, length(my.lines$psi)), label = label),
inherit.aes = FALSE,
hjust = 1) +
geom_text(mapping = aes(x = 0.3, y = 0.8, hjust = 1, label=paste("Adjusted R Squared:", "\n", r2)), inherit.aes = FALSE)
modelgraph_nngrass
abcover_nativecover_nngrasscover2 <- abcover_nativecover_nngrasscover[order(abcover_nativecover_nngrasscover$native_grass, decreasing = TRUE),]
tail <- max(abcover_nativecover_nngrasscover2$nonnative_grass, n = 1)
p1 <- ggplot(abcover_nativecover_nngrasscover2, aes(x = nonnative_grass, y = native_grass))
model <- lm(native_grass ~ nonnative_grass, data = abcover_nativecover_nngrasscover2)
#analyze breakpoints
# have to provide estimates for breakpoints.
# after looking a the data,
my.seg <- segmented(model,
seg.Z = ~ nonnative_grass,
npsi = 2
)
bp <- as.data.frame(my.seg$psi)
bp <- as.list(bp$Est.)
bpcount <- length(bp) + 1
bpcount1 <- length(bp) - 1
modelxbeg <- rep(NaN, times = bpcount)
modelxend <- rep(NaN, times = bpcount)
modelybeg <- rep(NaN, times = bpcount)
modelyend <- rep(NaN, times = bpcount)
intercept <- rep(NaN, times = bpcount)
slope1 <- rep(NaN, times = bpcount)
break1 <- rep(NaN, times = bpcount)
for (i in 1:bpcount) {
break1[i] <- my.seg$psi[[i+bpcount1]]
if (i == 1) {
slope1[i] <- coef(my.seg)[[2]]
intercept[i] <- coef(my.seg)[[1]]
break1[i] <- 0
}
else {
slope1[i] <- slope1[i-1] + coef(my.seg)[[i+1]]
intercept[i] <- (intercept[i-1] + slope1[i-1]*break1[i]) - (slope1[i]*break1[i])
}
}
abcover_sum <- read.csv("processed/coverstatus.csv")
abcover_sum[,12] <- c("INT1", "INT2", "INT3", "ENH1", "ENH1", "ENH1", "ENH2", "ENH2", "ENH2", "DEG1", "DEG1", "DEG1", "DEG2", "DEG2", "DEG2")
abcover_sum <- abcover_sum %>%
rename(hill = V12) %>%
dplyr::select(!c(X, standtype, site_rep, native_fern, native_forb, nonnative_fern, nonnative_forb, nonnative_shrub, native_grass)) %>%
group_by(hill) %>%
summarise(across(nonnative_grass:native_shrub, mean))
abcover_sum <- cbind(abcover_sum[1], stack(abcover_sum[2:3])) %>%
rename(proportion = values,
type = ind) %>%
mutate(proportion = 100*proportion)
seedbank_byfamilystatus_proportion_1 <- seedbank_byfamilystatus_proportion %>%
group_by(site, family, status) %>%
summarize(across(proportion_germination, mean))
seedbank_byfamilystatus_proportion_hill <- seedbank_byfamily_status %>%
left_join(seedbank_byfamily_count, by = c("stand_core")) %>%
group_by(family, site) %>%
summarise(across(totalgerm_family:totalgerm_family_bystandcore, mean)) %>%
mutate(proportion_germination = (totalgerm_family/totalgerm_family_bystandcore)*100)
ggplot(seedbank_byfamilystatus_proportion %>%
dplyr::filter(status == "native" | status == "nonnative"),
aes(fill=family, y=proportion_germination, x=stand_core)) +
geom_bar(position="stack", stat="identity") +
ggtitle("Relative Germination by Family and Status") +
labs(x="Soil Core", y="Relative Germination") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~ status)
barwidth <- 0.35
ggplot() +
geom_bar(data = abcover_sum,
mapping = aes(x = as.numeric(interaction(hill)) + barwidth, y = proportion, fill = type),
stat="identity",
position='stack',
width = barwidth) +
scale_fill_manual(values = c("green3", "pink2")) +
new_scale_fill() +
geom_bar(data = subset(seedbank_byfamilystatus_proportion_1, status == "native"),
mapping = aes(x = as.numeric(interaction(site)), y = proportion_germination, fill = family),
stat="identity",
position='stack' ,
width = barwidth) +
ggtitle("Native") +
xlab("site") +
scale_x_continuous(breaks=c(1.25,2.25,3.25,4.25,5.25,6.25,7.25),labels=c("Deg1","Deg2","Enh1", "Enh1", "Int1", "Int2", "Int3"))
View(seedbank_load_v)
View(seedbank_load)
unique(seedbank_load$species_diversity)
View(seedbank_load)
seedbank_load_sorted <- seedbank_load[order(seedbank_load$species_diversity),]
unique(seedbank_load$species_diversity)
unique(seedbank_load_sorted$species_diversity)
View(ab_diversity)
View(ab_diversity)
View(seedbank_byfamily)
View(seedbank_load)
View(abcover_full)
>>>>>>> Stashed changes
