isa_df <- data.frame(Species = colnames(data))
# Iterate through different numbers of clusters
for (k in 2:max_clusters) {
cluster_assignments <- cutree(agnes(vegdist(data, method = "bray"), method = "gaverage", par.method = -0.25), k = k)
# Convert cluster assignments to a factor
cluster_factor <- as.factor(cluster_assignments)
# Run multipatt() with the cluster factor
multipatt_result <- multipatt(data, cluster = cluster_factor, duleg = FALSE)
# Extract ISA values and p-values
isa_values <- multipatt_result$sign$index
p_values <- multipatt_result$sign$p.value
# Filter by p-value <= 0.05
significant_isa_values <- ifelse(p_values <= 0.05, isa_values, NA)
# Extract ISA values for each species and add to the dataframe
isa_df[[as.character(k)]] <- significant_isa_values
}
return(isa_df)
}
max_clusters <- 10  # Maximum number of clusters to iterate through
# Run multipatt() and extract ISA values for each species
isa_data <- run_multipatt_and_extract_ISA(df, max_clusters)
# Frequency distribution of number of significant ISA in each cluster step
frq.ISA <- isa_data %>%
pivot_longer(cols = 2:10, names_to = "Cluster", values_to = "ISA_SCORE") %>%
drop_na() %>%
group_by(Cluster) %>%
summarise(count = n()) %>%
arrange(as.numeric(Cluster))
#######
# Now calculate the sum of the differences in ISA scores from one step to the next
# When the indicator values of all species are decreasing, the clustering method does not explain anything more.
# Take difference of species index values
isa.diff.data <- isa_data %>%
mutate(k2 = `2`-`3`) %>%
mutate(k3 = `3`-`4`) %>%
mutate(k4 = `4`-`5`) %>%
mutate(k5 = `5`-`6`) %>%
mutate(k6 = `6`-`7`) %>%
mutate(k7 = `7`-`8`) %>%
mutate(k8 = `8`-`9`) %>%
mutate(k9 = `9`-`10`)
isa.diff.sum <- isa.diff.data %>%
dplyr::select(Species, 11:18) %>%
pivot_longer(cols = 2:9, names_to = "Cluster", values_to = "ISA_SCORE") %>%
drop_na() %>%
filter(ISA_SCORE <= 0) %>%
arrange(by = Cluster) %>%
group_by(Cluster) %>%
summarise(sum = sum(ISA_SCORE))
ggplot(isa.diff.sum,
aes(x = Cluster,
y = sum)) +
geom_bar(stat = "identity") +
labs(title = "", x = "Cluster", y = "Value") +
theme_minimal()
# The differences from 2 to 3 groups (-8) and from 3 to 4 groups (-4) are small,
# indicating that moving from 2 to 4 clusters doesn’t significantly improve the ISA scores.
# This suggests that the structure in the data is relatively stable with these numbers of clusters,
# and adding more groups is not greatly improving how well species are associated with their clusters.
# The difference from 4 to 5 groups is -90, which is a noticeable drop. This indicates that introducing a 5th cluster starts to capture more distinct ecological patterns, improving the ISA scores.
# Optimal Number of Clusters:
# 4 clusters may be suboptimal due to the small improvement seen moving to 4 clusters from 3 (-4).
# 5 clusters is likely the best choice. The drop to -90 suggests that the 5-cluster solution
# is where distinct ecological patterns are maximized before significant over-segmentation occurs.
# Adding more than 5 clusters likely results in diminishing returns, as indicated by the sharp declines in ISA scores.
# Doing 5 clusters!
# Beta average
hcluster.abs.cover <- agnes(d, method = "gaverage", par.method = -0.25)
# Negative values of beta (e.g., -0.25) make the clustering process more similar to single linkage (minimum distance between clusters).
# Positive values of beta make the process more similar to complete linkage (maximum distance). beta = 0 corresponds to the standard average linkage (UPGMA).
plot(hcluster.abs.cover)
# Cut tree into groups
sub_grp <- cutree(hcluster.abs.cover, k = 5)
# Number of members in each cluster
table(sub_grp)
# Calculate the distance to centroid for each cluster
bd <- betadisper(d, sub_grp)
centroid_coords <- bd$centroids
centroid_distances <- round(vegdist(centroid_coords, method = "euclidean"), 2) # Calculate the distances between the centroids
#      1    2    3    4
# 2 0.62
# 3 0.64 0.69
# 4 0.60 0.41 0.54
# 5 0.83 0.71 0.73 0.65
# Combine group labels into species matrix
temp.df <- data_pc %>%
rownames_to_column()
my_groups <- as.data.frame(sub_grp) %>%
rownames_to_column()
cluster.subgrp.df <- left_join(temp.df, my_groups, by = "rowname")
# # Create a combined label
cluster.subgrp.df$combined_labels <- paste(cluster.subgrp.df$sub_grp, cluster.subgrp.df$site_rep, sep = " - ")
# Plot the hierarchical clustering dendrogram with the combined labels
plot(hcluster.abs.cover, labels = cluster.subgrp.df$combined_labels, main = "Hierarchical Clustering Dendrogram")
################
# Indicator Species Analysis
ISA.abs.cover <- multipatt(x = df, cluster = sub_grp, duleg = FALSE)
# A = The values are the **specificity** component of IV for that species in that combination of groups.
# B = The values are the **fidelity** component of IV for that species in that combination of groups
summary(ISA.abs.cover, indvalcomp=TRUE)
##############
# Does community composition differ among sites?
# Check for homogeneity of dispersion among groups, required for MANOVA
trt <- as.character(my_groups$sub_grp)
# There is significant dispersion within groups, and groups are unbalanced --- cannot use MANOVA (adonis)
anova(betadisper(d, trt))
# A low p-value (e.g., < 0.05) indicates that the dispersion (variance) among groups is significantly different, meaning that the assumption of homogeneity of dispersion is violated.
mod <- betadisper(d, trt)
TukeyHSD(mod)
boxplot(mod)
plot(mod)
# Best option is MRPP
# The key idea is simple: if groups differ, the mean within-group dissimilarity should be smaller
# than the mean dissimilarity among randomly selected groups of the same size.
results <- mrpp(d, grouping = sub_grp, permutations = 999)
results
# Call:
# mrpp(dat = d, grouping = sub_grp, permutations = 999)
#
# Dissimilarity index: bray
# Weights for groups:  n
#
# Class means and counts:
#
#       1      2      3      4      5
# delta 0.2092 0.2408 0.1518 0.1582 0.1561 <- within-group dissimilarity
# n     10     7      10     8      5
#
# Chance corrected within-group agreement A: 0.592
# Based on observed delta 0.1835 and expected delta 0.4498  <- randomly selected groups
#
# Significance of delta: 0.001 <- p-value yay!
# Permutation: free
# Number of permutations: 999
# Chunk 8
######
######### NMDS abs cover
# Define cluster groupings from above
# NAME data set
# df <- abs.cover.species.matrix.df %>%
#   column_to_rownames("RowNames")
# Calculate distance measure matrix, Bray is the best for community data
d <- vegdist(df, method = "bray")
hcluster <- agnes(d, method = "gaverage", par.method = -0.25)
# Cut tree into groups
hcluster.abs.cover <- agnes(d, method = "gaverage", par.method = -0.25)
sub_grp <- cutree(hcluster.abs.cover, k = 5)
my_groups <- as.data.frame(sub_grp) %>%
rownames_to_column()
# NMDS
# dimcheckMDS(df,
#   distance = "bray",
#   k = 10,
#  trymax = 400,
#  autotransform = FALSE)
# Picking k=3 for small stress value, and interpretation
mds <- metaMDS(df, k = 3, trymax = 400, autotransform = FALSE)
mds$stress
# k = 2D: stress test = 0.1648784
# k = 3D: stress test = 0.1128948
# k = 4D: stress test = 0.0831275
stressplot(mds) # A Shepard plot compares the observed dissimilarities (distances in the original data) to the fitted distances (distances in the reduced NMDS space).
gof <- goodness(mds) # Higher values indicate points that are poorly represented in the reduced-dimensional space, contributing more to the stress
gof
# min(gof) = 0.010
# max(gof) = 0.031 <- relationships in your data are well represented!
plot(mds, display = "sites", type = "none")
points(mds, display = "sites", cex = 2* # 2x for visibility
gof/mean(gof)) # standardized by the mean
# larger points = less well represented
# Plot NMDS
mds.df <- vegan::scores(mds, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("Sites") %>%
rownames_to_column("rowname") %>%
full_join(my_groups, by = "rowname") %>%
mutate(sub_grp = as.character(sub_grp))
ggplot(mds.df,
aes(x = NMDS1,
y = NMDS2,
color = sub_grp,
shape = sub_grp)) +
geom_point(size = 3, alpha = 0.8) +
stat_ellipse() +
theme(axis.title = element_text(size = 20)) +
theme(axis.text = element_text(size = 16))
ggplot(mds.df,
aes(x = NMDS2,
y = NMDS3,
color = sub_grp,
shape = sub_grp)) +
geom_point(size = 3, alpha = 0.8) +
stat_ellipse() +
theme(axis.title = element_text(size = 20)) +
theme(axis.text = element_text(size = 16))
p <- plot_ly(mds.df,
x = ~NMDS1,
y = ~NMDS2,
z = ~NMDS3,
type =  "scatter3d",
color=sub_grp)
p
# vectors
genp <- envfit(mds, df, perm = 999) # generate p-values
genp
pv <- genp$vectors$pvals %>% # extract p-values for each species
as.data.frame() %>%
rownames_to_column("species") %>%
dplyr::rename("pvals" = ".") %>%
left_join(sppchar, by = "species")
pv
# extract coordinates for species, only keep species with p-val = 0.05
spp <- genp %>%
scores(., display = "vectors") %>% # NMDS1, NMDS2 values
as.data.frame() %>%
rownames_to_column("species") %>%
full_join(., pv, by = "species") %>% # join pvalues and spp
filter(pvals <= 0.05)# <-- p-value
length(spp$species) #  <- limited number for visual clarity
# Convert sub_grp to a factor with the desired order
mds.df$sub_grp <- factor(mds.df$sub_grp,
levels = c("1", "3", "2", "4", "5"))  # Reorder as needed
#### native species
nmds_nat <- ggplot(mds.df,
aes(x = NMDS1,
y = NMDS2
)) +
geom_point(size = 3, alpha = 0.8, aes(color = sub_grp, shape = sub_grp, fill = sub_grp)) +
stat_ellipse(aes(color = sub_grp), size = 1, alpha = 0.5) +  # Apply color here. Alpha = transparency!
theme(axis.title = element_text(size = 20)) +
theme(axis.text = element_text(size = 16)) +
geom_segment(data = spp %>%  filter(status == "native"),
aes(x = 0, xend = NMDS1, y = 0, yend = NMDS2),
arrow = arrow(length = unit(0.25, "cm")),
col = "black") +
geom_text(data = spp %>%  filter(status == "native"),
aes(label = species),
position = position_jitter(width = 0.0, height = 0.1)) +
# how the data points look
scale_shape_manual(values = c("1" = 21, "2" = 21, "3" = 21, "4" = 21, "5" = 7),
labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
scale_color_manual(values = c("1" = "black", "2" = "blue", "3" = "orange", "4" = "purple", "5" = "darkgreen"),
# scale_color_manual(values = c("1" = "black", "2" = "black", "3" = "black", "4" = "black", "5" = "black"),
labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
scale_fill_manual(values = c("1" = "black", "2" = "grey85", "3" = "grey60", "4" = "white", "5" = "black"),
labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
theme_bw() +
guides(color = guide_legend(title = "Plant Group"),
shape = guide_legend(title = "Plant Group"),
fill = guide_legend(title = "Plant Group"))
#### non-native species
nmds_nn <- ggplot(mds.df,
aes(x = NMDS1,
y = NMDS2
)) +
geom_point(size = 3, alpha = 0.8, aes(color = sub_grp, shape = sub_grp, fill = sub_grp)) +
stat_ellipse(aes(color = sub_grp), size = 1, alpha = 0.5) +  # Apply color here
theme(axis.title = element_text(size = 20)) +
theme(axis.text = element_text(size = 16)) +
geom_segment(data = spp %>%  filter(status == "nonnative"),
aes(x = 0, xend = NMDS1, y = 0, yend = NMDS2),
arrow = arrow(length = unit(0.25, "cm")),
col = "black") +
geom_text(data = spp %>%  filter(status == "nonnative"),
aes(label = species),
position = position_jitter(width = 0.0, height = 0.1)) +
# how the data points look
scale_shape_manual(values = c("1" = 21, "2" = 21, "3" = 21, "4" = 21, "5" = 7),
labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
scale_color_manual(values = c("1" = "black", "2" = "blue", "3" = "orange", "4" = "purple", "5" = "darkgreen"),
labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
scale_fill_manual(values = c("1" = "black", "2" = "grey85", "3" = "grey60", "4" = "white", "5" = "black"),
labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +
theme_bw() +
guides(color = guide_legend(title = "Plant Group"),
shape = guide_legend(title = "Plant Group"),
fill = guide_legend(title = "Plant Group"))
# Combine plots
grid.arrange(nmds_nat,
nmds_nn,
nrow = 2,
ncol = 1,
widths = c(1), # Custom widths for each column
heights = c(1, 1) # Custom heights for each row
)
# Chunk 9
table_clustercover <- cluster.subgrp.df %>%
mutate(sub_grp = recode(sub_grp,
`1` = "NNG",
`2` = "ssF",
`3` = "ssG",
`4` = "ssFG",
`5` = "EVG")) %>%
pivot_longer(cols = 4:55, names_to = "Species", values_to = "percent_cover") %>%
rename(species = Species) %>%
group_by(sub_grp, species) %>%
summarise(mean_percentcover = round(mean(percent_cover, na.rm = TRUE)*100, 2)) %>%
pivot_wider(names_from = sub_grp, values_from = mean_percentcover) %>%
mutate(species = case_when(
species == "Festuca.myros" ~	"Festuca.myuros",
TRUE ~ species)) %>%
left_join(sppchar, by = "species") %>%
# mutate(species = ifelse(
#    species %in% c("Artemisia.californica",
#                   "Heteromeles.arbutifolia",
#                   "Salvia.apiana",
#                   "Baccharis.pilularis",
#                   "Ceanothus.oliganthus",
#                   "Eriodictyon.crassifolium",
#                   "Eriogonum.fasciculatum",
#                   "Malacothamnus.fasciculatus",
#                   "Rhamnus.ilicifolia",
#                   "Rhus.ovata",
#                   "Salvia.leucophylla",
#                   "Sambucus.mexicana"
#                   ),
#    paste0("<b><i>", species, "<b><i>"), # Bold and italicize these species
#    paste0("<i>", species, "<i>")              # Italicize all other species
# )) %>%
mutate(species = str_replace_all(species, "\\.", " ")) %>%
mutate(species = str_trim(species)) %>%
mutate(species = case_when(
species == "Cryptantha spp" ~ "Cryptantha spp.", # old name ~ new name
species == "Erodium spp" ~ "Erodium spp.",
species == "Lupinus spp" ~ "Lupinus spp.",
TRUE ~ species
)) %>%
relocate(status, lifecycle, lifeform, family, NNG, ssG, ssF, ssFG, EVG, .after = species)  %>%  # Move 'lifeform' after 'Species'
rename(Species = species,
Status = status,
Lifecycle = lifecycle,
Lifeform = lifeform,
Family = family) %>%
mutate(Status = case_when(
Status == "native" ~ "nat",
Status == "nonnative" ~ "nn",
TRUE ~ Status)
) %>%
mutate(Lifecycle = case_when(
Lifecycle == "annual" ~ "ann",
Lifecycle == "perennial" ~ "per",
TRUE ~ Lifecycle)
) %>%
#  mutate(Lifeform = case_when(
#   Lifeform == "forb" ~ "f",
#   Lifeform == "grass" ~ "g",
#    Lifeform == "shrub" ~ "s",
#   TRUE ~ Lifeform)
# )
mutate(Lifeform = ifelse(Species == "Heteromeles arbutifolia", "shrub (scl)", Lifeform)) %>%  # a condition, a value if the condition is true, and a value if the condition is false
mutate(Lifeform = ifelse(Species == "Rhamnus ilicifolia", "shrub (scl)", Lifeform)) %>%
mutate(Lifeform = ifelse(Species == "Rhus ovata", "shrub (scl)", Lifeform))
# view(table_clustercover)
# Print as a gt table
table_cover <- table_clustercover %>%
gt() %>%
tab_header(
title = "Mean Percent Cover by Cluster",
#subtitle = "Mean ± Standard Deviation for Elevation, Hillshade, Slope, Southwestness, Fire Events, and Coordinates"
) %>%
cols_align(
align = "left", # Center alignment
columns = "Species" # Specify the "cluster" column
) %>%
tab_options(
table.width = pct(80) # Make the table width 100%
)
table_cover
# Export the table as a PDF
gtsave(table_cover, "Ch1_Degradation_figures/table_spp_clustergroups_oct31.png",
expand = 10)
# # print as a HTML table with KABLE
# table_cover <- table_clustercover %>%
#    kable(format = "html", escape = FALSE) %>%
#    kable_styling("striped", full_width = FALSE)
#
# table_cover
# Chunk 10
# NAME data set
df <- data_pc %>%
dplyr::select(!c(site, site_rep))
d <- vegdist(df, method = "bray")  # Bray-Curtis dissimilarity
# Step 3: Perform hierarchical clustering
clustering <- agnes(d, method = "gaverage", par.method = -0.25)
# Step 4: Plot the dendrogram
# plot(clustering, labels = rownames(data), main = "Hierarchical Clustering Dendrogram")
plot(clustering, labels = data_pc$site_rep, main = "Hierarchical Clustering Dendrogram")
# Optionally, cut the tree to form clusters
cluster_2 <- cutree(clustering, k = 2)  # Cut the tree into 2 clusters
table(cluster_2)
data_pc$cluster_2 <- cluster_2
cluster_3 <- cutree(clustering, k = 3)  # Cut the tree into 3 clusters
table(cluster_3)
data_pc$cluster_3 <- cluster_3
cluster_4 <- cutree(clustering, k = 4)  # Cut the tree into 4 clusters
table(cluster_4)
data_pc$cluster_4 <- cluster_4
cluster_5 <- cutree(clustering, k = 5)  # Cut the tree into 5 clusters
table(cluster_5)
data_pc$cluster_5 <- cluster_5
cluster_6 <- cutree(clustering, k = 6)  # Cut the tree into 4 clusters
table(cluster_6)
data_pc$cluster_6 <- cluster_6
cluster_7 <- cutree(clustering, k = 7)  # Cut the tree into 4 clusters
table(cluster_7)
data_pc$cluster_7 <- cluster_7
cluster_8 <- cutree(clustering, k = 8)  # Cut the tree into 4 clusters
table(cluster_8)
data_pc$cluster_8 <- cluster_8
cluster_9 <- cutree(clustering, k = 9)  # Cut the tree into 4 clusters
table(cluster_9)
data_pc$cluster_9 <- cluster_9
cluster_10 <- cutree(clustering, k = 10)  # Cut the tree into 4 clusters
table(cluster_10)
data_pc$cluster_10 <- cluster_10
# Chunk 11
plot(clustering, labels = data_pc$cluster_2, main = "Hierarchical Clustering Dendrogram") # splits are ranked by the height of their splits
plot(clustering, labels = data_pc$cluster_5, main = "Hierarchical Clustering Dendrogram") # these seem to be the major splits
plot(clustering, labels = data_pc$cluster_7, main = "Hierarchical Clustering Dendrogram") # HIIN is significant here
plot(clustering, labels = data_pc$cluster_10, main = "Hierarchical Clustering Dendrogram")
# Assume `species_data` is your community data matrix (sites as rows, species as columns)
# Assume `clusters` is a vector defining the group membership for each site
# Run the Indicator Species Analysis
isa_results_2 <- multipatt(data, cluster_2, control = how(nperm=999))
table_clustercover <- cluster.subgrp.df %>%
table_clustercover <- cluster.subgrp.df %>%
mutate(sub_grp = recode(sub_grp,
`1` = "NNG",
`2` = "ssF",
`3` = "ssG",
`4` = "ssFG",
`5` = "EVG")) %>%
pivot_longer(cols = 4:55, names_to = "Species", values_to = "percent_cover") %>%
rename(species = Species) %>%
group_by(sub_grp, species) %>%
summarise(mean_percentcover = round(mean(percent_cover, na.rm = TRUE)*100, 2)) %>%
pivot_wider(names_from = sub_grp, values_from = mean_percentcover) %>%
mutate(species = case_when(
species == "Festuca.myros" ~	"Festuca.myuros",
TRUE ~ species)) %>%
left_join(sppchar, by = "species") %>%
# mutate(species = ifelse(
#    species %in% c("Artemisia.californica",
#                   "Heteromeles.arbutifolia",
#                   "Salvia.apiana",
#                   "Baccharis.pilularis",
#                   "Ceanothus.oliganthus",
#                   "Eriodictyon.crassifolium",
#                   "Eriogonum.fasciculatum",
#                   "Malacothamnus.fasciculatus",
#                   "Rhamnus.ilicifolia",
#                   "Rhus.ovata",
#                   "Salvia.leucophylla",
#                   "Sambucus.mexicana"
#                   ),
#    paste0("<b><i>", species, "<b><i>"), # Bold and italicize these species
#    paste0("<i>", species, "<i>")              # Italicize all other species
# )) %>%
mutate(species = str_replace_all(species, "\\.", " ")) %>%
mutate(species = str_trim(species)) %>%
mutate(species = case_when(
species == "Cryptantha spp" ~ "Cryptantha spp.", # old name ~ new name
species == "Erodium spp" ~ "Erodium spp.",
species == "Lupinus spp" ~ "Lupinus spp.",
TRUE ~ species
)) %>%
relocate(status, lifecycle, lifeform, family, NNG, ssG, ssF, ssFG, EVG, .after = species)  %>%  # Move 'lifeform' after 'Species'
rename(Species = species,
Status = status,
Lifecycle = lifecycle,
Lifeform = lifeform,
Family = family) %>%
mutate(Status = case_when(
Status == "native" ~ "nat",
Status == "nonnative" ~ "nn",
TRUE ~ Status)
) %>%
mutate(Lifecycle = case_when(
Lifecycle == "annual" ~ "ann",
Lifecycle == "perennial" ~ "per",
TRUE ~ Lifecycle)
) %>%
#  mutate(Lifeform = case_when(
#   Lifeform == "forb" ~ "f",
#   Lifeform == "grass" ~ "g",
#    Lifeform == "shrub" ~ "s",
#   TRUE ~ Lifeform)
# )
mutate(Lifeform = ifelse(Species == "Heteromeles arbutifolia", "shrub (scl)", Lifeform)) %>%  # a condition, a value if the condition is true, and a value if the condition is false
mutate(Lifeform = ifelse(Species == "Rhamnus ilicifolia", "shrub (scl)", Lifeform)) %>%
mutate(Lifeform = ifelse(Species == "Rhus ovata", "shrub (scl)", Lifeform))
# Print as a gt table
table_cover <- table_clustercover %>%
gt() %>%
tab_header(
title = "Mean Percent Cover by Cluster",
#subtitle = "Mean ± Standard Deviation for Elevation, Hillshade, Slope, Southwestness, Fire Events, and Coordinates"
) %>%
cols_align(
align = "left", # Center alignment
columns = "Species" # Specify the "cluster" column
) %>%
tab_options(
table.width = pct(80) # Make the table width 100%
)
table_cover
# Export the table as a PDF
gtsave(table_cover, "Ch1_Degradation_figures/table_spp_clustergroups_oct31.png",
expand = 10)
# Export the table as a PDF
gtsave(table_cover, "Ch1_Degradation_figures/table_spp_clustergroups_oct31.docx",
expand = 10)
