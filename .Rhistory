table.width = pct(100) # Make the table width 100%
)
table_plant
table_plant
# Print as a gt table
table_plant <- means_combined %>%
gt() %>%
tab_header(
title = "Summary Statistics by Plant Cluster",
subtitle = "Mean Â± Standard Deviation for Elevation, Hillshade, Slope, Southwestness, Fire Events, and Coordinates"
) %>%
cols_align(
align = "center", # Center alignment
columns = "plant_cluster" # Specify the "cluster" column
) %>%
tab_options(
table.width = pct(100) # Make the table width 100%
)
table_plant
table_plant
table_environ
table_env
knitr::opts_chunk$set(echo = TRUE)
###### load libraries
library(tidyverse) # includes ggplot2, dplyr, tidyr, readr, purr, tibble, stringr, forcats
library(vegan)
library(calecopal)
library(plotly)
library(ggvegan)
library(here)
library(cowplot)
library(factoextra)
library(ggrepel) # avoid overlaping labes in ggplot2
# library(ggpubr) # customize ggplot2 for publication
# library(broom)
# library(AICcmodavg)
# library(readxl) # for .xls and .xlsx sheets
# library(janitor)
# library(multcompView)
# library(ggthemes)
# library(ggnewscale)
# dune data: https://www.rpubs.com/RGrieger/545184
# Set seed for analyses
set.seed(8003)
######### load data
seedbank_load_raw <- read.csv("deg_seedbank_202407.csv", header = TRUE, na.strings=c("","NA"))
seedbank_load <- seedbank_load_raw %>%
dplyr::select(c("stand", "site", "soilcore", "depth_name", "treatment", "rep", "species_diversity", "genus_abundance", "lifeform", "status", "lifescycle", "family", "count"))
seedbank_load$count <- as.numeric(seedbank_load$count)
str(seedbank_load)
# print(seedbank_load)
# unique(seedbank_load$stand)
# unique(seedbank_load$site)
# unique(seedbank_load$soilcore)
# unique(seedbank_load$depth_name)
# unique(seedbank_load$treatment)
# unique(seedbank_load$status)
# sort(unique(seedbank_load$species_diversity))
# sort(unique(seedbank_load$genus_abundance))
# sort(unique(seedbank_load$family))
# sort(unique(seedbank_load$lifeform))
# sort(unique(seedbank_load$lifescycle))
dim(seedbank_load)
# [1] 2126   13
# head(seedbank_load)
# tail(seedbank_load)
# convert dataframe to tibble
seedbank_load <- as_tibble(seedbank_load)
# class(seedbank_load) # now a tibble
seedbank_load_v <- seedbank_load %>%
mutate(stand = fct_relevel(stand,
"intact", "enhanced", "degraded")) %>%
mutate(treatment = fct_relevel(treatment,
"control", "charate", "oven", "ovenchar")) %>%
mutate(family = case_when(
family ==  "Asteraceae  " ~ "Asteraceae", # old name ~ new name
family ==  "Cucurbitaceae  " ~ "Cucurbitaceae",
family ==  "Euphorbiaceae  " ~ "Euphorbiaceae",
family ==  "Fabaceae  " ~ "Fabaceae",
family ==  "Juncaceae  " ~ "Juncaceae",
family ==  "Liliaceae  " ~ "Liliaceae",
family ==  "Namaceae  " ~ "Namaceae",
#family ==  "Phrymaceae  "  ~ "Phrymaceae",
family ==  "Poaceae  " ~ "Poaceae",
family == "Themidaceae  " ~ "Themidaceae",
TRUE ~ as.character(family)  # Keep other observations unchanged
)) %>%
mutate(species_diversity = case_when(
species_diversity == "Astragalus trichopodus " ~ "Astragalus trichopodus",
species_diversity == "Erodium spp. "  ~ "Erodium spp.",
species_diversity == "Festuca myuros " ~ "Festuca myuros",
species_diversity == "Lactuca serriola " ~ "Lactuca serriola",
species_diversity ==   "Lupinus bicolor "   ~ "Lupinus bicolor",
species_diversity ==  "Salvia leucophylla "   ~ "Salvia leucophylla",
species_diversity == "Thysanocarpus spp. " ~ "Thysanocarpus spp.",
TRUE ~ as.character(species_diversity)  # Keep other observations unchanged
)) %>%
mutate(lifescycle = case_when(
lifescycle == "annual or biannual" ~ "biannual", # old name ~ new name
TRUE ~ as.character(lifescycle)  # Keep other observations unchanged
)) %>%
mutate(genus_abundance = case_when(
genus_abundance == "Lactuca serriola "  ~ "Lactuca serriola",
genus_abundance == "Lupinus bicolor "   ~ "Lupinus bicolor",
genus_abundance == "Thysanocarpus spp. "  ~ "Thysanocarpus spp.",
genus_abundance == "Unknown Phrymaceae  " ~ "Unknown Phrymaceae",
TRUE ~ as.character(genus_abundance)  # Keep other observations unchanged
))
# combine SITE and CORE to one column
seedbank_load_v$stand_core <- paste(seedbank_load_v$site, seedbank_load_v$soilcore, sep="_")
# combine SITE_CORE and DEPT to one column
seedbank_load_v$stand_core_depth <- paste(seedbank_load_v$stand_core, seedbank_load_v$depth_name, sep="_")
# combine SITE_CORE_DEPTH and TREATMENT to one column
seedbank_load_v$stand_core_depth_treat <- paste(seedbank_load_v$stand_core_depth, seedbank_load_v$treatment, sep="_")
glimpse(seedbank_load_v)
seedbank_load_v_omitpretreatment <- seedbank_load_v %>%
filter(!str_detect(treatment, "pretreat"))
# head(seedbank_load_v_omitpretreatment)
# list treatments
# unique(seedbank_load_v_omitpretreatment$treatment)
# list status
# unique(seedbank_load_v_omitpretreatment$status)
# list stand_core --> 26 = 7 + 10 + 9
# unique(seedbank_load_v_omitpretreatment$stand_core)
length(sort(unique(seedbank_load_v_omitpretreatment$species_diversity))) - 3
# n = 63 <--66 spp - Trifolium spp - Erodium spp. - Phacelia spp.
seed_genera <- seedbank_load_v_omitpretreatment %>%
dplyr::select(species_diversity) %>%
separate(col = species_diversity, into = c("Genus", "Species"), sep = " ") %>%
dplyr::select("Genus")
length(sort(unique(seed_genera$Genus))) - 1
# 49 genera <-- 50 - 1 for unknown
length(sort(unique(seedbank_load_v_omitpretreatment$family))) - 1
# n = 24 <-- 25 families - unknown family
# write.csv(seedbank_load_v_omitpretreatment, "~/Dropbox/GRADSCHOOL/Dissertation/R_dissertation/chaparraldegradation_2022/chaparraldegradation_2022/processed/seedbank_load_v_omitpretreatment.csv")
######## load data - germination by depth and treatment
germination_m2_raw <- read_xlsx("processed/old_processed/germination_m2.xlsx")
average_cover <- read.csv("nat_nn_cover.csv", header = TRUE, na.strings=c("","NA"))
germination_depthtreat <- germination_m2_raw %>%
mutate(site = fct_relevel(site,
"INT1", "INT2", "INT3","ENH1", "ENH2", "DEG1", "DEG2")) %>%
mutate(treatment = fct_relevel(treatment,
"control", "charate", "oven", "ovenchar")) %>%
left_join(average_cover, by = 'site') %>%
dplyr::select(stand, site, depth_name, subsample_g, treatment, species_diversity, genus_abundance, lifeform, status, lifescycle, family, count, stand_core, stand_core_depth, stand_core_depth_treat, n_per_g, native_shrub, nonnative_grass)
glimpse(germination_depthtreat)
# updated code on jan 21, 2024
seedbank_byfamily_new <- germination_depthtreat %>% # prior df: seedbank_load_v_omitpretreatment
filter(count > 0) %>%
group_by(stand, site, stand_core, family, status) %>%
# This will give a data point for every species based on germination numbers per species
dplyr::summarize(germ_nperg_family = sum(n_per_g),
N_species = length(unique(species_diversity)),
total_count = sum(count))
head(seedbank_byfamily_new)
sort(unique(seedbank_byfamily_new$family)) # df before transpose - use for ellipses
# N = 26 families
n_distinct(seedbank_byfamily_new$family) # 25
family_native <- ggplot(seedbank_byfamily_new %>%
dplyr::filter(status == "native"),
aes(fill=family, y=germ_nperg_family, x=stand_core)) +
geom_bar(position="stack", stat="identity") +
ylim(0, 2)+
#ggtitle("Germination (#/g soil) by Family and Status") +
labs(x="Sampling Location", y="Germination (#/g soil)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~ status)
family_native_print <- family_native + theme(legend.position = c(0.1, 0.2)) # Key location offset from (0,0)
family_nn <- ggplot(seedbank_byfamily_new %>%
dplyr::filter(status == "nonnative"),
aes(fill=family, y=germ_nperg_family, x=stand_core)) +
geom_bar(position="stack", stat="identity") +
ylim(0, 2)+
#ggtitle("Germination (#/g soil) by Family and Status") +
labs(x="Sampling Location", y="Germination (#/g soil)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~ status)
# With the par( ) function, you can include the option mfrow=c(nrows, ncols) to create a matrix of nrows x ncols plots that are filled in by row. mfcol=c(nrows, ncols) fills in the matrix by columns.
# option 1
# ggarrange(family_native, family_nn,
#           labels = c("A", "B"),
#           ncol = 1, nrow = 2)
#
# option 2
ggdraw() +
draw_plot(family_native, x = 0.02, y = .5, width = 1, height = .5) +
draw_plot(family_nn, x = 0.02, y = 0, width = 1, height = .5) +
# draw_plot(bp, x = 0, y = 0, width = 1, height = 0.5) +
draw_plot_label(label = c("A", "B"), size = 10,
x = c(0, 0), y = c(1, .5))
# species in columns
# sites or observations in rows
seedbank_nperg_bysamplocation <- germination_depthtreat %>%
group_by(stand, site, stand_core, genus_abundance) %>% # lifeform, status, lifescycle, family
filter(count > 0) %>%
filter(!is.na(genus_abundance)) %>% # omit blank cells in species
dplyr::summarize(totalgerm_nperg_genus = sum(n_per_g))
head(seedbank_nperg_bysamplocation) # df before transpose - use for ellipses
dim(seedbank_nperg_bysamplocation) #330   5
# species in columns down
# observations or sites in rows across
seedbank_nperg_bysamplocation_nmdsprep <- seedbank_nperg_bysamplocation %>%
tidyr::spread(genus_abundance, totalgerm_nperg_genus) %>% # transpose data so columns are stand_core
replace(is.na(.), 0) # replace NA with zeros --> isn't compatible with character columns
# view(seedbank_nperg_bysamplocation_nmdsprep)
# write.csv(seedbank_nperg_bysamplocation_nmdsprep, "~/Dropbox/GRADSCHOOL/Dissertation/R_dissertation/chaparraldegradation_2022b/processed/seedbank_NMDS_202401.csv")
seedbank_nperg_bysamplocation_nmdsprep_num <- seedbank_nperg_bysamplocation_nmdsprep %>%
ungroup() %>%
dplyr::select(!c('stand', 'site', 'stand_core')) %>%
replace(is.na(.), 0)
# head(seedbank_nperg_bysamplocation_nmdsprep_num) # only numbers
dim(seedbank_nperg_bysamplocation_nmdsprep_num) # 26 55
# NAME data set
df <- seedbank_nperg_bysamplocation_nmdsprep_num
# Calculate distance measure matrix, Bray is the best for community data
d <- vegdist(df, method = "bray")
# Check which method produces best clustering
m <- c( "average", "single", "complete", "ward", "gaverage")
names(m) <- c( "average", "single", "complete", "ward", "gaverage")
# function to compute coefficient
ac <- function(x) {
agnes(d, method = x, diss = TRUE, par.method = -0.25)$ac}
# Best method?
map_dbl(m, ac)
# Best method is g average at 0.83 (flexible beta)
#########################
#### Find optimal number of clusters
# Scree plot
fviz_nbclust(df, FUN = hcut, diss = d, method = "wss")
# Average Silhouette
# Measures how similar an object is to its own cluster (cohesion) compared to other clusters (separation). The Average Silhouette Width is the mean of all silhouette scores within a cluster or across all clusters.
# S â 1: The point is well clustered
fviz_nbclust(df, FUN = hcut, diss = d, method = "silhouette")
# 8 groups has the highest Avg Silhouette
# Gap Stat
# Compares the total within-cluster variation for different numbers of clusters with their expected values under a null reference distribution of the data (i.e., uniformly distributed points).
# The optimal number of clusters is the smallest k such that the Gap Statistic is maximized or the first local maximum occurs, indicating that adding more clusters does not significantly improve the clustering.
fviz_nbclust(df, FUN = hcut, diss = d, method = "gap_stat")
# 5 or 6 gruops is best
# Above tests suggest at least two, but are also not conclusive...
# Define function to compute Mantel correlation tests for different cluster assignments
compute_mantel_correlation <- function(hclust_obj, distance_matrix) {
# Initialize variables to store results
mantel_correlation <- numeric(length = length(hclust_obj$order) - 1)
# Iterate through different numbers of clusters
for (k in 2:length(hclust_obj$order)) {
cluster_assignments <- cutree(hclust_obj, k = k)
cluster_distance <- as.matrix(dist(cluster_assignments))
mantel_result <- mantel(cluster_distance, distance_matrix)
mantel_correlation[k - 1] <- mantel_result$statistic
# Print Mantel correlation for each number of clusters
print(paste("Mantel Correlation (r) for", k, "clusters:", mantel_result$statistic))
}
return(mantel_correlation)
}
# Create Cluster and then run tests
Hclust.result <- agnes(d, method = "gaverage", par.method = -0.25)
mantel_results <- compute_mantel_correlation(Hclust.result, d)
# Find the optimal number of clusters based on the largest Mantel correlation, r
optimal_clusters <- which.max(mantel_results) + 1  # Add 1 to convert index to number of clusters
print(paste("Optimal Number of Clusters:", optimal_clusters))
# [1] "Optimal Number of Clusters: 5"
####
#### Use ISA to determine optimal clusters
# Function to run multipatt() on k iterations of clusters and extract ISA values
run_multipatt_and_extract_ISA <- function(data, max_clusters) {
# Initialize an empty dataframe to store ISA values
isa_df <- data.frame(Species = colnames(data))
# Iterate through different numbers of clusters
for (k in 2:max_clusters) {
cluster_assignments <- cutree(agnes(vegdist(data, method = "bray"), method = "gaverage", par.method = -0.25), k = k)
# Convert cluster assignments to a factor
cluster_factor <- as.factor(cluster_assignments)
# Run multipatt() with the cluster factor
multipatt_result <- multipatt(data, cluster = cluster_factor, duleg = FALSE)
# Extract ISA values and p-values
isa_values <- multipatt_result$sign$index
p_values <- multipatt_result$sign$p.value
# Filter by p-value <= 0.05
significant_isa_values <- ifelse(p_values <= 0.05, isa_values, NA)
# Extract ISA values for each species and add to the dataframe
isa_df[[as.character(k)]] <- significant_isa_values
}
return(isa_df)
}
max_clusters <- 10  # Maximum number of clusters to iterate through
# Run multipatt() and extract ISA values for each species
isa_data <- run_multipatt_and_extract_ISA(df, max_clusters)
# Frequency distribution of number of significant ISA in each cluster step
frq.ISA <- isa_data %>%
pivot_longer(cols = 2:10, names_to = "Cluster", values_to = "ISA_SCORE") %>%
drop_na() %>%
group_by(Cluster) %>%
summarise(count = n()) %>%
arrange(as.numeric(Cluster))
#######
# Now calculate the sum of the differences in ISA scores from one step to the next
# When the indicator values of all species are decreasing, the clustering method does not explain anything more.
# Take difference of species index values
isa.diff.data <- isa_data %>%
mutate(k2 = `2`-`3`) %>%
mutate(k3 = `3`-`4`) %>%
mutate(k4 = `4`-`5`) %>%
mutate(k5 = `5`-`6`) %>%
mutate(k6 = `6`-`7`) %>%
mutate(k7 = `7`-`8`) %>%
mutate(k8 = `8`-`9`) %>%
mutate(k9 = `9`-`10`)
isa.diff.sum <- isa.diff.data %>%
select(Species, 11:18) %>%
pivot_longer(cols = 2:9, names_to = "Cluster", values_to = "ISA_SCORE") %>%
drop_na() %>%
filter(ISA_SCORE <= 0)%>%
arrange(by = Cluster) %>%
group_by(Cluster) %>%
summarise(sum = sum(ISA_SCORE))
# view(isa.diff.sum)
ggplot(isa.diff.sum,
aes(x = Cluster,
y = sum)) +
geom_bar(stat = "identity") +
labs(title = "", x = "Cluster", y = "Value") +
theme_minimal()
# Doing 3 clusters!
# Beta average
hcluster.abs.cover <- agnes(d, method = "gaverage", par.method = -0.25)
plot(hcluster.abs.cover)
rect.hclust(hcluster.abs.cover, k = 3)
# Cut tree into groups
sub_grp <- cutree(hcluster.abs.cover, k = 3)
# Number of members in each cluster
table(sub_grp)
# Combine group labels into species matrix
temp.df <- seedbank_nperg_bysamplocation_nmdsprep %>%
rownames_to_column()
my_groups <- as.data.frame(sub_grp) %>%
rownames_to_column()
seed.subgrp.df <- left_join(temp.df, my_groups, by = "rowname") %>%
dplyr::select(rowname, sub_grp, stand_core)
# Create a combined label
combined_labels <- paste(seed.subgrp.df$sub_grp, seed.subgrp.df$stand_core, sep = " - ")
# Plot the hierarchical clustering dendrogram with the combined labels
plot(hcluster.abs.cover, labels = combined_labels, main = "Hierarchical Clustering Dendrogram")
rect.hclust(hcluster.abs.cover, k = 3)
################
# Indicator Species Analysis
ISA.abs.cover <- multipatt(x = df, cluster = sub_grp, duleg = FALSE)
# A = The values are the **specificity** component of IV for that species in that combination of groups.
# B = The values are the **fidelity** component of IV for that species in that combination of groups
summary(ISA.abs.cover, indvalcomp=TRUE)
##############
# Does community composition differ among groups?
# Check for homogeneity of dispersion among groups, required for MANOVA
trt <- as.character(my_groups$sub_grp)
# There is significant dispersion within groups, and groups are unbalanced --- cannot use MANOVA (adonis)
anova(betadisper(d, trt))
mod <- betadisper(d, trt)
TukeyHSD(mod)
# $group
#            diff         lwr         upr     p adj
# 2-1 -0.10959209 -0.22252937 0.003345181 0.0583159
# 3-1  0.02930223 -0.08363504 0.142239508 0.7943526
# 3-2  0.13889433  0.02932908 0.248459576 0.0113293
boxplot(mod)
# groups 1 and 3 are similar
# group 2 is biologically different from 1 and 3
plot(mod)
# Best option is MRPP
# The key idea is simple: if groups differ, the mean within-group dissimilarity should be smaller
# than the mean dissimilarity among randomly selected groups of the same size.
# Sort of low effect size but groups are meaningful!
results <- mrpp(d, grouping = sub_grp, permutations = 999)
results
# USE THIS ONE!
# str(seedbank_nperg_bysamplocation_nmdsprep)
# stand_core_depth -->  tibble [89 Ã 52]
# the AUTOTRANSFORM = F skips the automatic data transformations and uses the input data as is
# - when the raw data contains the information you need (e.g., abundance)
# - when you have a small number of samples or small number of variables
# - when you want to preseve the original scale of the data (e.g., interested in the absolute differences between two sets of measurements)
seedbank_nperg_bysamplocation_nmds <- metaMDS(seedbank_nperg_bysamplocation_nmdsprep_num,
autotransform = F, # or T
distance = "bray",   # bray or raup
k = 3, #dimentions
try = 100, #runs
trymax = 400)
seedbank_nperg_bysamplocation_nmds$stress
# k = 2D: stress test = 0.1225128
# k = 3D: stress test = 0.07051168
# k = 4D: stress test = 0.05050043
# uses the RAUP-CRICK dissimilarity index to calculate pairwise dissimilarities
# - adjusts for spp richness
# - downweights importance of rare spp
# - more useful when interested in community STRUCTURE rather than individual species
# - takes into account differences in species evenness
#seedbank_nperg_bysamplocation_nmds <- metaMDS(seedbank_nperg_bysamplocation_nmdsprep_num, distance = "raup")
# stress tests are really low ==> I may have insufficient data. :/
stressplot(seedbank_nperg_bysamplocation_nmds) # A Shepard plot compares the observed dissimilarities (distances in the original data) to the fitted distances (distances in the reduced NMDS space).
gof <- goodness(seedbank_nperg_bysamplocation_nmds)
gof # Higher values indicate points that are poorly represented in the reduced-dimensional space, contributing more to the stress
# min(gof) = 0.007292025
# max(gof) = 0.02083548
plot(seedbank_nperg_bysamplocation_nmds, display = "sites", type = "none")
points(seedbank_nperg_bysamplocation_nmds, display = "sites", cex = 2* # 2x for visibility
gof/mean(gof)) # standardized by the mean
# larger points = less well represented
# Plot NMDS
mds.df <- vegan::scores(seedbank_nperg_bysamplocation_nmds, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("rowname")  %>%
full_join(seed.subgrp.df, by = "rowname") %>%
mutate(sub_grp = as.character(sub_grp))
ggplot(mds.df,
aes(x = NMDS1,
y = NMDS2,
color = sub_grp,
shape = sub_grp)) +
geom_point(size = 3, alpha = 0.8) +
stat_ellipse() +
theme(axis.title = element_text(size = 20)) +
theme(axis.text = element_text(size = 16))
ggplot(mds.df,
aes(x = NMDS2,
y = NMDS3,
color = sub_grp,
shape = sub_grp)) +
geom_point(size = 3, alpha = 0.8) +
stat_ellipse() +
theme(axis.title = element_text(size = 20)) +
theme(axis.text = element_text(size = 16))
p <- plot_ly(mds.df,
x = ~NMDS1,
y = ~NMDS2,
z = ~NMDS3,
type =  "scatter3d",
color=sub_grp)
p
# vectors
genp <- envfit(seedbank_nperg_bysamplocation_nmds, df, perm = 999) # generate p-values
genp
pv <- genp$vectors$pvals %>% # extract p-values for each species
as.data.frame() %>%
rownames_to_column("species") %>%
dplyr::rename("pvals" = ".") %>%
left_join(sppchar, by = "species")
ggplot(mds.df,
aes(x = NMDS1,
y = NMDS2
)) +
geom_point(size = 3, alpha = 0.8, aes(color = sub_grp, shape = sub_grp)) +
stat_ellipse(aes(color = sub_grp)) +  # Apply color here
theme(axis.title = element_text(size = 20)) +
theme(axis.text = element_text(size = 16)) +
geom_segment(data = spp,
aes(x = 0, xend = NMDS1, y = 0, yend = NMDS2),
arrow = arrow(length = unit(0.25, "cm")),
col = "black") +
geom_text_repel(data = spp,
aes(label = species),
position = position_jitter(width = 0.0, height = 0.1)) +
scale_color_manual(values = c("1" = "orange", "2" = "purple", "3" = "green"),
labels = c("1" = "Group1 - DEG", "2" = "Group2 - ENH", "3" = "Group3 - INT")) +
scale_shape_manual(values = c("1" = 16, "2" = 17, "3" = 18),
labels = c("1" = "Group1 - DEG", "2" = "Group2 - ENH", "3" = "Group3 - INT")) +
theme_bw()
# the AUTOTRANSFORM = F skips the automatic data transformations and uses the input data as is
# - when the raw data contains the information you need (e.g., abundance)
# - when you have a small number of samples or small number of variables
# - when you want to preseve the original scale of the data (e.g., interested in the absolute differences between two sets of measurements)
seedbank_nperg_bysamplocation_nmds <- metaMDS(seedbank_nperg_bysamplocation_nmdsprep_num,
autotransform = F, # or T
distance = "bray",   # bray or raup
k = 3, #dimentions
try = 100, #runs
trymax = 400)
seedbank_nperg_bysamplocation_nmds$stress
stressplot(seedbank_nperg_bysamplocation_nmds) # A Shepard plot compares the observed dissimilarities (distances in the original data) to the fitted distances (distances in the reduced NMDS space).
gof <- goodness(seedbank_nperg_bysamplocation_nmds)
gof # Higher values indicate points that are poorly represented in the reduced-dimensional space, contributing more to the stress
plot(seedbank_nperg_bysamplocation_nmds, display = "sites", type = "none")
points(seedbank_nperg_bysamplocation_nmds, display = "sites", cex = 2* # 2x for visibility
gof/mean(gof)) # standardized by the mean
# Plot NMDS
mds.df <- vegan::scores(seedbank_nperg_bysamplocation_nmds, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("rowname")  %>%
full_join(seed.subgrp.df, by = "rowname") %>%
mutate(sub_grp = as.character(sub_grp))
plot(seedbank_nperg_bysamplocation_nmds, display = "sites", type = "none")
# Plot NMDS
mds.df <- vegan::scores(seedbank_nperg_bysamplocation_nmds, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("rowname")  %>%
full_join(seed.subgrp.df, by = "rowname") %>%
mutate(sub_grp = as.character(sub_grp))
ggplot(mds.df,
aes(x = NMDS2,
y = NMDS3,
color = sub_grp,
shape = sub_grp)) +
geom_point(size = 3, alpha = 0.8) +
stat_ellipse() +
theme(axis.title = element_text(size = 20)) +
theme(axis.text = element_text(size = 16))
# vectors
genp <- envfit(seedbank_nperg_bysamplocation_nmds, df, perm = 999) # generate p-values
genp
pv <- genp$vectors$pvals %>% # extract p-values for each species
as.data.frame() %>%
rownames_to_column("species") %>%
dplyr::rename("pvals" = ".") %>%
left_join(sppchar, by = "species")
