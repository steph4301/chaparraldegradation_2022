---
title: "Stand Deg: percent cover regressions, shrub density"
author: "Stephanie Ma Lucero"
date: "2024-04-23"
output: html_document
---

<-- 1_cluster.Rmd

---> 1_july2025.Rmd


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Code to hang on to
- mutate(site_rep = paste(site, transect, sep = "_")) %>% # create a new third column
- unite("lifeform_status", 6:5, sep = "_") #combines characters in two columns to one column, withoutcreating a third column
- line types
-- "solid": A solid line.
-- "dashed": A dashed line.
-- "dotted": A dotted line.
-- "dotdash": Alternating dots and dashes.
-- "longdash": Long dashes.
-- "paste0() : to paste without spaces

SD = spread of data points
SE = precision of data points

- to rename INT sites to the same label: mutate(site = ifelse(str_detect(site, "INT"), "3", site)), 
 
- to expand the ggplot to show all the points:
    scale_y_continuous(
    limits = c(0, 300),
    breaks = seq(0, 300, by = 50),
    expand = expansion(mult = c(0, 0.05))
  ) +
  
  
  
If data are not normally distributed I can:
1. Provide summary of range - Report median with an interquartile range (IQR): Median (Q1–Q3)
2. Statistical comparison - Kruskal–Wallis test to compare among groups, followed by pairwise Wilcoxon rank-sum tests with p-value adjustment for multiple comparisons.



```{r libraries, message=FALSE}
library(here) # similar to set working directory
library(tidyverse) # data wrangling - includes ggplot2, dplyr, tidyr, readr, purr, tibble, stringr, forcats
library(readxl) 
library(gridExtra)
library(cowplot)
library(MASS)
library(multcompView) # for significance letters to p-values
library(gt) # for tables - use gt or knitr
library(knitr) # for tables
library(rstatix) # for pairwise Wilcoxon test with significance letters 
library(flextable)
library(mgcv) # for Generalized Additive Models (GAMs)
library(segmented) # for Threshold or Breakpoint Models (Piecewise Regression)
library(quantreg) # for Quantile Regression
library(ggpubr)
library(DHARMa)
library(lme4)
```

# colors
```{r colors, include=TRUE}
devtools::install_github("an-bui/calecopal")

library(calecopal)
# all palettes
names(cal_palettes)

#chaparral1
#chaparral2
cal_palette(name = "superbloom3", n = 5, type = "continuous") 

#species colors
HEAR <- "#D3E3CA"
RHOV <- "#92A587"
RHIL <- "#2F3525"

MAFA <- "gray60"
SALE <- "gray40"
ARCA <- "gray20"

scl <- 16
css <- 17

colors_scl <- c(HEAR, RHOV, RHIL)
colors_css <- c(MAFA, SALE, ARCA)

# Lifeform colors: shrub, grass, forb
shrub <- "green4"
grass <- "yellow2"
forb <- "purple2"
fern <- "black"
colors_lifeform <- c(shrub, grass, forb, fern)

# Ground cover types
bare_rock <- "gray40"
nonnative_thatch <- "black"
native_litter_wood <- "green4"
shape_bare_rock <- 16
shape_nonnative_thatch <- 15
shape_native_litter_wood <- 17

# Status colors: native, exotic 
native <- "black"
nonnative <- "maroon"
unknown <- "lightblue"
colors_status <- c(native, nonnative, unknown)

# Plant clusters
NNG <- "orange"
ssG <- "gray"
ssF <- "hotpink"
ssFG <- "blue"
EVG <- "green"
colors_plantclusters <- c(NNG, ssG, ssF, ssFG, EVG)

# "orange", "lightblue", "limegreen", "deeppink","mediumpurple2", "darkgreen"
```

#NOTES Transect data overview - Years collected: 2017, 2019, 2024 - Sites: 1 and 2 - Comparing to intact sites: INT1, INT2, INT3, INT4, INT5

# load data
```{r load point intercept transect data from csv, eval = FALSE}


########## don't run this code, instead use df from 1_cluster: transect2019

# file_transect_2019_load <- read_excel("deg_percentcover_byspecies_bylifeform_2024.xlsx", sheet = "2019_data")

# -- years 2017, 2019
# -- Site 1: transects 1-6
# -- Site 2: transects 1-6
# -- INT1, INT2, INT3, INT4

# Finding species == "Bromus spp." to rename them by species
# transect2019_bromus <- file_transect_2019_load %>%
#   filter(grepl("Bromus", species))

# transect2019_bromusspp <- file_transect_2019_load %>% 
#   filter(species == "Bromus spp.")

# transect2019 <- file_transect_2019_load %>% 
#   dplyr::select(c(site, transect, year, distance, vertical, species)) %>% # select columns to full join with 2024 data
#   filter(year %in% c(2017, 2019))  %>% #filter data to 2019 data
#    dplyr::select(year, site, transect, distance, vertical, species) %>% 
#    mutate(species = ifelse(# a condition, a value if the condition is true, and a value if the condition is false
#                               site == 2 & transect == 5 & distance %in% c(2, 6, 9) & species == "Bromus spp.", "Bromus hordeaceus", species)) %>% 
#     mutate(species = ifelse(site == 2 & transect == 5 & distance %in% c(10, 28) & species == "Bromus spp.", "Bromus rubens", species)) %>% 
#     mutate(species = ifelse(site == 2 & transect == 6 & distance %in% c(23, 35, 37) & species == "Bromus spp.", "Bromus hordeaceus", species)) %>% 
#     mutate(species = ifelse(site == "INT1" & transect == 1 & distance %in% c(24) & species == "Bromus spp.", "Bromus diandrus", species)) %>% 
#    mutate(
#        site = as.character(site))


# View the data (optional)
#View(transect2019)
#sort(unique(transect2019$transect))
#sort(unique(transect2019$site))

########## don't run this code, instead use df from 1_cluster: transect2024

# file_transect_2024_load <- read.csv("Transects_2024 - transect.csv", header = TRUE, na.strings=c("","NA"))

# -- years 2024
# -- Site 1: transects 7-14
# -- Site 2: transects 7-21
# -- INT5

# transect2024 <- file_transect_2024_load %>%
#   dplyr::select(c(site, transect, year, distance, vertical, species)) %>%
#   filter(species != "N/A") %>%
#    mutate(species = case_when(species == "Bromus spp." ~ "Bromus rubens", # oldname ~ newname
                              # TRUE ~ species))
  
# View the data (optional)
#view(transect2024)
#sort(unique(transect2024$transect))
#sort(unique(transect2024$site))
```

- load cluster
```{r}

groups_load <- read.csv("~/Dropbox/GRADSCHOOL/Dissertation/R_dissertation/chaparraldegradation_2022/chaparraldegradation_2022/data/Extracted_Elevation_Slope_Aspect_Hillshade_20m.csv", header = TRUE, na.strings=c("","NA")) 

groups <- groups_load %>% 
  dplyr::select(c(system_ind, cluster)) %>% 
  rename(site_rep = system_ind) %>% 
  mutate(site_rep = case_when(site_rep == "INT1" ~ "INT1.1", # old name ~ new name
                              site_rep == "INT2" ~ "INT2.1",
                              site_rep == "INT3" ~ "INT3.1",
                              site_rep == "INT4" ~ "INT4.1",
                              site_rep == "INT5" ~ "INT5.1",
                                  TRUE ~ site_rep))   %>% 
  mutate(site_rep = case_when(site_rep == "1.1" ~ "1.10", # old ~ new
                                 site_rep == "2.1" ~ "2.10",
                                 site_rep == "2.2" ~ "2.20",
                                   TRUE ~ site_rep)) %>% 
   mutate(
      site_rep = as.character(site_rep)
      ) %>% 
   add_row(site_rep = "INT5.5",
          cluster = 5) %>% 
  as_tibble() 


groupsdash <- groups %>%  
  separate(site_rep, into = c("site", "rep"), sep = "\\.") %>%
  mutate(rep = case_when(rep == "01" ~ "1", # oldname ~ newname
                         rep == "02" ~ "2",
                         rep == "03" ~ "3",
                         rep == "04" ~ "4",
                         rep == "05" ~ "5",
                         rep == "06" ~ "6",
                         rep == "07" ~ "7",
                         rep == "08" ~ "8",
                         rep == "09" ~ "9",
                              TRUE ~ rep)) %>% 
     mutate(site_rep = paste(site, rep, sep = "_")) %>% 
  dplyr::select(site_rep, cluster)  %>% 
     mutate(
      site_rep = as.character(site_rep)
      ) %>% 
  as_tibble() 
   


groups # 40 transects: "1.01"

groupsdash # 40 transects: "1_1
```

## full join transect data

```{r full join}
abcover_fulljoin <- full_join(transect2019, transect2024, 
                              by = intersect(names(transect2019), # transect2019 <-- the transect for INT5 is "5", the other INT transects are "1"
                                             names(transect2024))) 

# View the data (optional)
# View(abcover_fulljoin)
# sort(unique(abcover_fulljoin$transect))
# sort(unique(abcover_fulljoin$site))

```

## species list

```{r convert to tibble}
# convert dataframe to tibble
abcover_fulljoin_tib <- as_tibble(abcover_fulljoin) 
class(abcover_fulljoin_tib)

abcover_full <- abcover_fulljoin_tib %>% 
   mutate(site_rep = paste(site, transect, sep = "_")) %>% # combine site and rep to one column
   mutate(site_rep_dist = paste(site_rep, distance, sep = "_")) %>%  # combine site_rep and distance to one column 
   mutate(species = case_when(species == "BG bare ground" ~ "bare_ground", # oldname ~ newname
                              species == "ground" ~ "bare_ground", 
                              species == "native_litter" ~ "litter",
                              species == "nonnative_thatch" ~ "thatch",
                              species == "Bromus diandrus BRDI" ~ "Bromus diandrus",
                              species == "Bromus rubens BRRU" ~ "Bromus rubens", 
                              species == "Bromus hordeaceus BRHO" ~ "Bromus hordeaceus", 
                              species == "Rapistrum rugosum - round pods" ~ "Rapistrum rugosum", 
                              species == "HIIN Hirschfeldia incana - long pods" ~ "Hirschfeldia incana", 
                              species == "Hirschfeldia incana - long pods" ~ "Hirschfeldia incana", 
                              species == "Salvia lucophylla" ~ "Salvia leucophylla",
                              species == "Malacothamnus fasciculatus " ~ "Malacothamnus fasciculatus",
                              species == "dead HEAR" ~ "Heteromeles arbutifolia dead",
                              species == "dead MAFA" ~ "Malacothamnus fasciculatus dead",
                              species == "dead RHIL" ~ "Rhamnus ilicifolia dead",
                              species == "dead ARCA" ~ "Artemisia californica dead",
                              species == "dead SALE" ~ "Salvia leucophylla dead",
                              species == "ACGL Acmispon glaber" ~ "Acmispon glaber",
                              species == "dead Acmispon glaber" ~ "Acmispon glaber dead",
                              species == "Acmispon maritimus - round, sevfl" ~ "Acmispon maritimus",
                              species == "Acmispon strigosus - oval, sevfl" ~ "Acmispon strigosus",
                              species == "Sambucus nigra" ~ "Sambucus mexicana",
                              species == "Blitum californicum" ~ "Chenopodium californicum",
                              species == "Cryptantha sp." ~ "Cryptantha spp.",
                              species == "Mirabilis laevis var. crassifolia" ~ "Mirabilis laevis",
                              species == "unknown1 forb" ~ "Centaurea melitensis", # in ENH2, transect 1 (aka: Site 2.4)
                              TRUE ~ species)) %>% 
   mutate(
      year = as.character(year),
      site = as.character(site),
      transect = as.character(transect),
      distance = as.character(distance),
      vertical = as.character(vertical),
      species = as.character(species)
      )

glimpse(abcover_full) # look at new columns

sort(unique(abcover_full$species))
length(unique(abcover_full$site_rep)) # 40

# use abcover_full for species richness --> 1_spprich.Rmd

```

## species characteristics

```{r load species characteristics, include=TRUE}
specieslist <- file_transect_2019_load %>%
  dplyr::select(species, lifeform, status, lifecycle, family) %>% 
   mutate(status = case_when(status == "Native" ~ "native", # oldname ~ newname
                                status == "Non-native" ~ "nonnative",
                                status == "thatch" ~ "ground",
                                status == "litter" ~ "ground",
                                status == "rock" ~ "ground",
                                TRUE ~ status)) %>%
  
   mutate(lifeform = case_when(lifeform == "Grass" ~ "grass",
                                lifeform == "Shrub" ~ "shrub",
                                lifeform == "Forb" ~ "forb",
                                lifeform == "thatch" ~ "ground",
                                lifeform == "litter" ~ "ground",
                                lifeform == "rock" ~ "ground",
                                species == "Calystegia macrostegia" ~ "forb or vine",  # <-- changing CAL from "forb" to "forb or vine"
                                TRUE ~ lifeform)) %>%
  
   mutate(lifecycle = case_when(lifecycle == "Annual" ~ "annual",
                                lifecycle == "Perennial" ~ "perennial",
                                lifecycle == "thatch" ~ "ground",
                                lifecycle == "litter" ~ "ground",
                                lifecycle == "rock" ~ "ground",
                                TRUE ~ lifecycle)) %>%
  
   mutate(family = case_when(family == "thatch" ~ "ground",
                             family == "litter" ~ "ground",
                             family == "rock" ~ "ground",
                             TRUE ~ family)) %>%
  
   mutate(species = case_when(species == "BG bare ground" ~ "bare_ground",
                                species == "ground" ~ "bare_ground",
                                species == "native_litter" ~ "litter",
                                species == "nonnative_thatch" ~ "thatch",
                                species == "Bromus diandrus BRDI" ~ "Bromus diandrus",
                                species == "Bromus rubens BRRU" ~ "Bromus rubens",
                                species == "Bromus hordeaceus BRHO" ~ "Bromus hordeaceus",
                                species == "Rapistrum rugosum - round pods" ~ "Rapistrum rugosum",
                                species == "HIIN Hirschfeldia incana - long pods" ~ "Hirschfeldia incana",
                                species == "Hirschfeldia incana - long pods" ~ "Hirschfeldia incana",
                                species == "Salvia lucophylla" ~ "Salvia leucophylla",
                                species == "Malacothamnus fasciculatus " ~ "Malacothamnus fasciculatus",
                                species == "dead HEAR" ~ "Heteromeles arbutifolia dead",
                                species == "dead MAFA" ~ "Malacothamnus fasciculatus dead",
                                species == "dead RHIL" ~ "Rhamnus ilicifolia dead",
                                species == "dead ARCA" ~ "Artemisia californica dead",
                                species == "dead SALE" ~ "Salvia leucophylla dead",
                                species == "ACGL Acmispon glaber" ~ "Acmispon glaber",
                                species == "Acmispon maritimus - round, sevfl" ~ "Acmispon maritimus",
                                species == "Acmispon strigosus - oval, sevfl" ~ "Acmispon strigosus",
                                species == "Mirabilis laevis var. crassifolia" ~ "Mirabilis laevis",
                                TRUE ~ species)) %>%
  
  add_row(species = "Cryptantha spp.",
          lifeform = "forb", 
          status = "native",
          lifecycle = "annual",
          family = "Boraginaceae") %>% 
    add_row(species = "Acmispon glaber dead",
          lifeform = "forb",
          status = "native",
          lifecycle = "perennial",
          family = "Fabaceae") %>% 
    add_row(species = "Uropappus lindleyi",
          lifeform = "forb",
          status = "native",
          lifecycle = "annual",
          family = "Asteraceae") %>%
  
  filter(!species == "no_species") %>% 
  add_row(species = "no_species",
          lifeform = "no_species",
          status = "no_species",
          lifecycle = "no_species",
          family = "no_species") %>% 
  
  # adding species for total species richness: 1_spprich.Rmd ; df = spprich 
  add_row(species = "Festuca myuros", # add a row with the correct spelling
          lifeform = "grass",
          status = "nonnative",
          lifecycle = "annual",
          family = "Poaceae") %>% 
  add_row(species = "Adiantum capillus-veneris",
           lifeform = "fern", status = "native", lifecycle = "perennial", family = "Pteridaceae") %>% 		
  add_row(species = "Blitum californicum", 
           lifeform = "forb", status = "native", lifecycle = "perennial", family = "Chenopodiaceae") %>% 
  add_row(species = "Chlorogalum pomeridianum",
           lifeform = "forb", status = "native", lifecycle = "perennial", family = "Agavaceae") %>% 
  add_row(species = "Claytonia parviflora",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Montiaceae") %>% 
  add_row(species = "Claytonia perfoliatae",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Montiaceae") %>% 
  add_row(species = "Daucus pusillus",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Apiaceae") %>% 
  add_row(species = "Emmenanthe penduliflora",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Hydrophyllaceae") %>% 
  add_row(species = "Eriodictyon crassifolium",
           lifeform = "shrub", status = "native", lifecycle = "perennial", family = "Namaceae") %>% 
  add_row(species = "Eucrypta chrysanthemifolia",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Hydrophyllaceae") %>% 
  add_row(species = "Galium californicum",
           lifeform = "forb", status = "native", lifecycle = "perennial", family = "Rubiaceae") %>% 
  add_row(species = "Galium spp.", 
          lifeform = "forb", status = "native", lifecycle = "perennial", family = "Rubiaceae") %>% 
  add_row(species = "Lupinus bicolor",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Fabaceae") %>% 
  add_row(species = "Lupinus succulentus",
            lifeform = "forb", status = "native", lifecycle = "annual", family = "Fabaceae") %>%
  add_row(species = "Phacelia viscida",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Hydrophyllaceae") %>%
  add_row(species = "Phacelia distans",
             lifeform = "forb", status = "native", lifecycle = "annual", family = "Hydrophyllaceae") %>%
  add_row(species = "Phacelia tanacetifolia",
            lifeform = "forb", status = "native", lifecycle = "annual", family = "Hydrophyllaceae") %>%
  add_row(species = "Phacelia spp.",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Hydrophyllaceae") %>%
  add_row(species = "Trifolium gracilentum",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Fabaceae") %>% 
  add_row(species = "Trifolium spp.",
           lifeform = "forb", status = "native", lifecycle = "annual", family = "Fabaceae") %>% 
  add_row(species = "Acourtia microcephala",
           lifeform = "forb", status = "native", lifecycle = "perennial", family = "Asteraceae") %>% 
  add_row(species = "Asclepias fascicularis",
          lifecycle = "perennial", lifeform = "forb", status = "native",  family = "Apocynaceae") %>% 
  add_row(species = "Camissoniopsis micrantha", 
           lifecycle = "annual", lifeform = "forb", status = "native",  family = "Onagraceae") %>% 
  add_row(species = "Ceanothus cuneatus",  
           lifecycle = "perennial", lifeform = "shrub", status = "native",  family = "Rhamnaceae") %>% 
  
  add_row(species = "Clematis lasiantha", 
           lifecycle = "perennial", lifeform = "forb or vine", status = "native",  family = "Ranunculaceae") %>% 
    
  add_row(species = "Erigeron canadensis", 
           lifecycle = "annual", lifeform = "forb", status = "native",  family = "Asteraceae") %>% 
  
  add_row(species = "Hesperocnide tenella",   
           lifecycle = "annual", lifeform = "forb", status = "native",  family = "Urticaceae") %>% 
  add_row(species = "Lactuca serriola", 
           lifecycle = "annual", lifeform = "forb", status = "nonnative",  family = "Asteraceae") %>% 
  add_row(species = "Malacothrix saxitilis",   
           lifecycle = "perennial", lifeform = "forb", status = "native",  family = "Asteraceae") %>% 
                                                           
  add_row(species = "Medicago polymorpha",  
           lifecycle = "annual", lifeform = "forb", status = "native",  family = "Fabaceae") %>% 
  
  add_row(species = "Pseudognaphalium californicum",   
           lifecycle = "annual", # <-- annual or perennial. I chose "annual" since it's dry and PSCA maybe dies in the summer? 8/7/2025
          lifeform = "forb", 
          status = "native",  
          family = "Asteraceae") %>%  
  
  add_row(species = "Quercus agrifolia", 
           lifecycle = "perennial", lifeform = "tree", status = "native",  family = "Fagaceae") %>% 
  add_row(species = "Rafinesquia californica",  
           lifecycle = "annual", lifeform = "forb", status = "native",  family = "Asteraceae") %>% 
  add_row(species = "Salvia apiana",    
           lifecycle = "perennial", lifeform = "shrub", status = "native",  family = "Lamiaceae") %>% 
  add_row(species = "Sanicula crassicaulis",     	  
           lifecycle = "perennial", lifeform = "forb", status = "native",  family = "Apiaceae") %>% 
  
  add_row(species = "Solanum douglasii",
           lifecycle = "perennial", lifeform = "forb", status = "native",  family = "Solanaceae") %>% 
  
  add_row(species = "Thysanocarpus curvipes",   
          lifecycle = "annual", lifeform = "forb", status = "native",  family = "Brassicaceae") %>% 
  add_row(species = "Thysanocarpus spp.", # <- According to Calflora, T. laciniatus is also found in Ventura county. I'm not sure if THLA is at Piru, but on the datasheet papers we only wrote down "Thysanocarpus". 8/7/2025
           lifecycle = "annual", lifeform = "forb", status = "native",  family = "Brassicaceae") %>% 
  
  add_row(species = "Toxicodendron pubescens", 
           lifecycle = "perennial", 
           lifeform = "shrub", # <-- vine or shrub, labeled as "shrub" becuase that's the shape TOPU has at PIRU
           status = "native",  
           family = "Anacardiaceae") %>% 
  
    add_row(species = "Mirabilis laevis var. crassifolia", 
           lifecycle = "perennial", 
           lifeform = "forb", 
           status = "native",  
           family = "Nyctaginaceae") %>% 

################ characteristics of unknown species

  add_row(species = "Unknown 3 Grindelia?", # <- this plant could be Grindelia camporum or Grindelia hirsutula based on records in Calflora 8/7/20205
          lifecycle = "perennial",  # Site 2, transect 2
          lifeform = "forb", 
          status = "native",  
          family = "Asteraceae") %>% 
    
  add_row(species = "unknown collected aster (NB2312 page 123)", # <- labeled in my notebook NB2312 on page 123 as "Lactuca?", but I don't see spines on the leaves
          lifecycle = "annual", 
          lifeform = "forb", 
          status = "unknown",   # <- unknown
          family = "Asteraceae") %>% 
    
  add_row(species = "Unknown pretty seed", # <- INT4 U.P.S., no photos, no sample. 2017.
          lifecycle = "unknown", 
          lifeform = "unknown", 
          status = "unknown",  
          family = "unknown") %>% 
    
  add_row(species = "unknown seedling (photo)", # <- INT5, photos are on sheet = NOTES in PIRU_Transect_Belt google sheets (deep green seedling)
           lifecycle = "unknown", # <- likely perennial
          lifeform = "unknown", # <- likely shrub
          status = "unknown",   # <- likely native
          family = "unknown") %>% 
    
  add_row(species = "unknown shrub",
           lifecycle = "perennial", 
          lifeform = "shrub", 
          status = "unknown", # <- likely native  
          family = "unknown") %>% 
    
      add_row(species = "unknown7 forb - unknown oval shaped leaf, red colored stem at the base - no photos",
           lifecycle = "annual", 
          lifeform = "forb", 
          status = "unknown", # <- likely native  
          family = "unknown") %>% 
  mutate(family = case_when(family == "Chenopodiaceae  " ~ "Chenopodiaceae", 
                             family == "Convolvulaceae  " ~ "Convolvulaceae",
                             family == "Euphorbiaceae  " ~ "Euphorbiaceae",
                             family == "Hydrophyllaceae  " ~ "Hydrophyllaceae",
                             family == "Myrsinaceae  " ~ "Myrsinaceae",
                             family == "Nyctaginaceae  " ~ "Nyctaginaceae",
                             family == "Papaveraceae  " ~ "Papaveraceae",
                             family == "Solanacaeae" ~ "Solanaceae",
                             TRUE ~ family)) %>% 
       mutate(lifecycle = case_when(species == "Acmispon glaber" ~ "perennial", # oldname ~ newname
                                  species == "Acmispon glaber dead" ~ "perennial", 
                              TRUE ~ lifecycle)) %>% 
  
     distinct()
   

# View(specieslist)
sort(unique(specieslist$species))
sort(unique(specieslist$lifeform))
sort(unique(specieslist$status))
sort(unique(specieslist$lifecycle))
sort(unique(specieslist$family))


```

-- code to update list of species characteristics
```{r playing with da species list}
ab_species <- sort(unique(abcover_full$species))
species_species <- sort(unique(specieslist$species))

#These are the species that are in abcover_full that are NOT in the species list
difab <- setdiff(ab_species, species_species)
difab 

#These are the species that are in the species list that are NOT in abcover_full
difsp <- setdiff(species_species, ab_species)
difsp # it's ok if spp in the species list are not recorded in abcover_full

# # add species to the specieslist
# new.specieslist <- specieslist %>%
#   add_row(species = "Cryptantha spp.",
#           lifeform = "forb",
#           status = "native",
#           lifecycle = "annual",
#           family = "Boraginaceae ")
# #           
# # Rename species in the specieslist if needed
# new.specieslist <- specieslist %>%
#     mutate(species = case_when(species == "" ~ "",
#                                TRUE ~ species))
# 
# # Rename species in the data frame (abcover_full) if needed
# new.abcover_full <- abcover_full %>%
#     mutate(species = case_when(species == "Cryptantha sp." ~ "Cryptantha spp.",
#                               species == "dead Acmispon glaber" ~ "Acmispon glaber dead",
#                                TRUE ~ species))
# 
# new.ab_species <- sort(unique(new.abcover_full$species))
# new.species_species <- sort(unique(new.specieslist$species))
# 
# new.ab_species == new.species_species
# 
# #These are the species that are in abcover_full that are NOT in the species list
# new.difab <- setdiff(new.ab_species, new.species_species)
# new.difab
# 
# #These are the species that are in the species list that are NOT in abcover_full
# new.difsp <- setdiff(new.species_species, new.ab_species)
# new.difsp
# # 
# 
# # Run the code below when you are sure you added everything correctly 
# specieslist <- new.specieslist
# abcover_full <- new.abcover_full
# 
# write.csv(specieslist, file = "processed/specieslist.csv") # species and their characteristics :)

```

### left_join species characteristics
```{r left_join species characteristics}
abcover_charateristics <- abcover_full %>% 
  left_join(specieslist, by = "species") 
  

#sort(unique(abcover_charateristics$species))

# write.csv(abcover_charateristics, file = "processed/ab_specieslistwithcharateristics_09122025.csv") # species and their characteristics :)
```

## leaf type
```{r}
#shrub_leaftype <- read_excel("shrub_leaftype.xlsx") #original data

shrub_leaftype <- read.csv("data/shrub_leaftype.csv") %>% 
  dplyr::select("species", "leaftype") %>% 
   mutate(
      species = as.character(species),
      leaftype = as.character(leaftype)
      ) %>% 
  mutate(
    leaftype = if_else(grepl("dead", species, ignore.case = TRUE), "dead_shrub", leaftype)
  ) %>% 
  add_row(species = "Salvia apiana",
           leaftype = "nonsclero") %>% 
    add_row(species = "Cenothus oliganthus",
           leaftype = "nonsclero") %>% 
   add_row(species = "Quercus agrifolia",
           leaftype = "sclerophyllous") %>% 
    add_row(species = "no_shrubs",
           leaftype = "no_shrubs") %>% 
  add_row(species = "Ceanothus cuneatus", 
          leaftype = "sclerophyllous") %>% 
  add_row(species = "unknown5 shrub",
           leaftype = "unknown") 

print(sort(shrub_leaftype$species))
```

-- code to update list of shrub leaf characteristics
```{r update schlero leaf data}

#These are the species that are in abcover_full that are NOT in the species list
ab_shrubs_prep <- abcover_charateristics %>% 
  filter(lifeform == "shrub")
ab_shrubs <- sort(unique(ab_shrubs_prep$species))

shrub_shrubs_prep <- specieslist %>% 
  filter(lifeform == "shrub")
shrub_shrubs <- sort(unique(shrub_shrubs_prep$species))

# compare shrub lists
#These are the species that are in the species list that are NOT in abcover_full
difshr <- setdiff(ab_shrubs, shrub_shrubs)
difshr


# new.shrub_leaftype <- shrub_leaftype %>%
#   add_row(species = "", leaftype = "")
# 
# # Run the code below when you are sure you added everything correctly
# shrub_leaftype <- new.shrub_leaftype
# 
# write.csv(shrub_leaftype, file = "shrub_leaftype.csv")
```

### left_join leaftype
```{r}
abcover_charateristics_leaftype <- abcover_charateristics %>% 
  left_join(shrub_leaftype, by = "species") 
```

# Data prep
```{r data check, include = TRUE}
abcover_charateristics_leaftype %>% 
  group_by(site, transect) %>%
  summarize(data_points = length(unique(distance))) # number of "hits" per transect

abcover_charateristics_leaftype %>% 
  group_by(site) %>%
  summarize(n_transects = length(unique(transect))) # number of transects per site
# sort(unique(abcover_full$site_rep))
```
- omit ground
### edit df 
```{r omit ground as a status}
abcover_omitground <- abcover_charateristics_leaftype %>% 
  filter(vertical != "ground", 
         vertical != "ground cover", 
         vertical != "0") %>% 
  filter(species != "no_species", 
         species != "thatch", 
         species != "unknown3") %>% 
  mutate(lifeform_status = paste(lifeform, status, sep = "_")) %>% 
  mutate(lifeform_status_leaftype = paste(lifeform_status, leaftype, sep = "_"))

# sort(unique(abcover_omitground$status))
# names(abcover_omitground)
```

### transect percent cover by species
```{r}

# species % cover per transect
abcover_omitground %>%  
  group_by(site_rep, species) %>%  
  summarize (n = length(species)) %>% 
  mutate(percent_cover = round((n/41*100),2)) %>% 
  ungroup() %>% 
  dplyr::select(-n) %>% 
  pivot_wider(names_from = site_rep, values_from = percent_cover) %>% 
  dplyr::select(species, INT4_1)
  
# species with > 50% cover in at least one transect
abcover_omitground %>%  
  group_by(site_rep, species) %>%  
  summarize (n = length(species)) %>% 
  mutate(percent_cover = round((n/41*100),2)) %>% 
  ungroup() %>% 
  dplyr::select(-n) %>% 
  filter(percent_cover > 50) %>% 
  dplyr::select(species) %>% 
  distinct()
  # pivot_wider(names_from = site_rep, values_from = percent_cover)

# Avena barbata				<- species with > 50% cover in at least one transect
# Bromus rubens				
# Hirschfeldia incana				
# Centaurea melitensis				
# Bromus diandrus				
# Rapistrum rugosum
# 
# Malacothamnus fasciculatus				
# Salvia leucophylla				
# Artemisia californica				
# Heteromeles arbutifolia
# Stipa lepida

```

### transect percent cover by native or non-native stauts
```{r hist percent cover by site and status}

# I'm not interested in cover by total native vs. total non-native

# cover_bystatus <- abcover_omitground %>% 
#   group_by(site, transect, site_rep, year, status) %>%
#   dplyr::summarize(
#     count_per_transect = n_distinct(site_rep_dist),
#     percentcover = n_distinct(site_rep_dist)/41 # <-- calculate percent cover by transect, lifeform, and status
#     ) 

# # view(cover_bystatus)
# hist(cover_bystatus$percentcover)
# 
# # jitter - by site and status
# ggplot(data = cover_bystatus, 
#        aes(y = percentcover*100, x = site, color = status)) + 
#   geom_jitter() +
#   facet_wrap(~status)

```

### percent cover - by lifeform_status and lifeform_status_leaftype
```{r hist percent cover by lifeform and status}

cover_bylfstatus <- abcover_omitground %>% # total percent cover of shrubs_native
   group_by(year, site, transect, site_rep, lifeform_status) %>%
  dplyr::summarize(
    lfstatus_count_per_transect = n_distinct(site_rep_dist),
    lifeform_status_percentcover = n_distinct(site_rep_dist)/41 # <-- calculate percent cover by transect, lifeform, and status
    ) %>%  
    dplyr::select(!c(lfstatus_count_per_transect)) %>% 
  ungroup() 

# view(cover_bylfstatus)

join_cover <- cover_bylfstatus %>% 
   dplyr::select(site_rep, lifeform_status, lifeform_status_percentcover) %>%
  unite("join", 1:2, sep = "_")
  
cover_bylfstatusleaftype <- abcover_omitground %>% 
   group_by(year, site, transect, site_rep, lifeform_status, lifeform_status_leaftype) %>%
   dplyr::summarize(
    leaftype_count_per_transect = n_distinct(site_rep_dist),
    lifeform_status_leaftype_percentcover = n_distinct(site_rep_dist)/41
    ) %>%  
   dplyr::select(!c(leaftype_count_per_transect)) %>% 
  ungroup() %>% 
  mutate(join = paste(site_rep, lifeform_status, sep = "_")) %>% 
  left_join(join_cover, by = "join") %>% 
   dplyr::select(!c(join))

# view(cover_bylfstatusleaftype)


##### native herb cover
herb_cover <- abcover_omitground %>% # total percent cover of shrubs_native
  filter(lifeform_status == "grass_native" | lifeform_status == "forb_native") %>% 
   group_by(year, site, transect, site_rep) %>%
  dplyr::summarize(
    lfstatus_count_per_transect = n_distinct(site_rep_dist),
    lifeform_status_percentcover = n_distinct(site_rep_dist)/41 # <-- calculate percent cover by transect, lifeform, and status
    ) %>%  
    dplyr::select(!c(lfstatus_count_per_transect)) %>% 
  ungroup() %>% 
 mutate(lifeform_status = "herb_native") %>% 
  bind_rows(cover_bylfstatus) 

```


- Here I'm transposing the dataframes from long to wide  because I want to visualize native shrub by leaftype cover by non-native grass cover.
```{r transpose cover_bylfstatus}


cover_bylfstatus_wide <- cover_bylfstatus %>%
  dplyr::select(site, site_rep, lifeform_status, lifeform_status_percentcover) %>% 
   pivot_wider(names_from = lifeform_status, values_from = lifeform_status_percentcover) %>%
   replace_na(replace = list(grass_native = 0,  # Replace NA with 0 for each value column
                             grass_nonnative = 0,
                             forb_native = 0,
                             forb_nonnative = 0,
                             forb_unknown = 0,
                             shrub_native = 0,
                             fern_native = 0,
                             unknown_unknown = 0)) %>% 
  left_join(groupsdash, by = "site_rep") %>% 
  mutate(cluster = as.character(cluster)) %>% 
   mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
  mutate(cluster = factor(cluster, levels = c("NNG", "ssG", "ssF", "ssFG", "EVG")))
  
# view(cover_bylfstatus_wide)

cover_byleaftype_wide <- cover_bylfstatusleaftype %>% 
  dplyr::select(site, site_rep, lifeform_status_leaftype, lifeform_status_leaftype_percentcover) %>% 
  pivot_wider(names_from = lifeform_status_leaftype, values_from = lifeform_status_leaftype_percentcover) %>%
  replace_na(replace = list(fern_native_NA = 0,
                            unknown_unknown_NA = 0,
                            forb_native_NA = 0,
                            forb_nonnative_NA = 0,
                            forb_unknown_NA = 0,
                            shrub_native_dead_shrub = 0,
                            shrub_native_nonsclero = 0,
                            shrub_native_sclerophyllous = 0,
                            grass_native_NA = 0,
                            grass_nonnative_NA = 0)) %>% 
  left_join(groupsdash, by = "site_rep") %>% 
   mutate(cluster = as.character(cluster)) %>% 
   mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
  mutate(cluster = factor(cluster, levels = c("NNG", "ssG", "ssF", "ssFG", "EVG")))
  

# view(cover_byleaftype_wide)

# join two dfs 
cover_wide <- cover_byleaftype_wide %>% 
  left_join(cover_bylfstatus_wide, by = c("site_rep", "site", "cluster"))


herb_cover_wide <- herb_cover %>% 
  pivot_wider(names_from = "lifeform_status", values_from = "lifeform_status_percentcover") %>% 
  replace_na(replace = list(grass_native = 0,  # Replace NA with 0 for each value column
                             grass_nonnative = 0,
                             forb_native = 0,
                             forb_nonnative = 0,
                             forb_unknown = 0,
                             shrub_native = 0,
                             fern_native = 0,
                             unknown_unknown = 0, 
                            herb_native = 0)) %>% 
   left_join(groupsdash, by = "site_rep") %>% 
  mutate(cluster = as.character(cluster)) %>% 
   mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
  mutate(cluster = factor(cluster, levels = c("NNG", "ssG", "ssF", "ssFG", "EVG")))

```
 


# REGRESSIONS 

```{r}
native_aes <- list(
  aes(shape = "native", size = 3, color = "native"),
  scale_shape_manual(values = c("native" = 1), guide = "none"), # Shape: open circle
  scale_color_manual(values = c("native" = "black"), guide = "none"), # Color: black
  scale_size_manual(values = c("native" = 3), guide = "none") # Size: 3
)
```

1. x = shrub cover by leaf type

- y = non-native grass cover 
```{r shrub_split, eval = FALSE}

########################### SHRUB_SPLIT


############ scl slope >= 50%
model.scl.50 <- lm(shrub_native_sclerophyllous ~ grass_nonnative_NA, data = (cover_wide %>%  filter(shrub_native_sclerophyllous >= .50))) # response variable ~ independent variable
# Print the summary of the model
model.scl_summary.50 <- summary(model.scl.50)
# Extract the intercept, slope, and R^2 values
interceptscl.50 <- round(coef(model.scl.50)[1], 2)
slopescl.50 <- round(coef(model.scl.50)[2], 2)
r_squaredscl.50 <- round(model.scl_summary.50$r.squared, 3)
print(paste("Multiple R^2:", r_squaredscl.50))  # [1] "Multiple R^2: 0.429"
# Create the label for the equation and R^2
eq_label_scl.50 <- paste0("Scl >50%: y = ", slopescl.50, "x + ", interceptscl.50, "\n", "R² = ", r_squaredscl.50)

############ scl slope < 50%
model.scl00 <- lm(shrub_native_sclerophyllous ~ grass_nonnative_NA, data = (cover_wide %>%  filter(shrub_native_sclerophyllous < .50))) # response variable ~ independent variable
# Print the summary of the model
model.scl_summary00 <- summary(model.scl00)
# Extract the intercept, slope, and R^2 values
interceptscl00 <- round(coef(model.scl00)[1], 2)
slopescl00 <- round(coef(model.scl00)[2], 2)
r_squaredscl00 <- round(model.scl_summary00$r.squared, 3)
print(paste("Multiple R^2:", r_squaredscl00))
# [1] "Multiple R^2: 0.442"
# Create the label for the equation and R^2
eq_label_scl00 <- paste0("Scl <50%: y = ", slopescl00, "x + ", interceptscl00, "\n", "R² = ", r_squaredscl00)



######### sage scrub slope > 50%
model.ss50 <- lm(shrub_native_nonsclero ~ grass_nonnative_NA, data = (cover_byleaftype_wide %>%  filter(shrub_native_nonsclero >= .50))) # response variable ~ independent variable
model.ss_summary50 <- summary(model.ss50)
# Extract the intercept, slope, and R^2 values
interceptss50 <- round(coef(model.ss50)[1], 2)
slopess50 <- round(coef(model.ss50)[2], 2)
r_squaredss50 <- round(model.ss_summary50$r.squared, 3)
print(paste("Multiple R^2:", r_squaredss50))
eq_label_ss50 <- paste0("ss >50%: y = ", slopess50, "x + ", interceptss50, "\n", 
                        "R² = ", r_squaredss50)

######### sage scrub slope < 50%
model.ss00 <- lm(shrub_native_nonsclero ~ grass_nonnative_NA, data = (cover_byleaftype_wide %>%  filter(shrub_native_nonsclero < .50 ))) # response variable ~ independent variable
model.ss_summary00 <- summary(model.ss00)
# Extract the intercept, slope, and R^2 values
interceptss00 <- round(coef(model.ss00)[1], 2)
slopess00 <- round(coef(model.ss00)[2], 2)
r_squaredss00 <- round(model.ss_summary00$r.squared, 3)
print(paste("Multiple R^2:", r_squaredss00))
eq_label_ss00 <- paste0("ss <50%: y = ", slopess00, "x + ", interceptss00, "\n", 
                        "R² = ", r_squaredss00)




shrub_split <- ggplot(data = cover_wide) +
  
  #  scl cover >= 50%
  geom_point(data = cover_wide %>%  filter(shrub_native_sclerophyllous >= .50), 
             aes(x = shrub_native_sclerophyllous * 100, y = grass_nonnative * 100, 
                 color = "sclerophyllous", 
                 shape = "sclerophyllous"
                 ), 
             size = 3, 
             show.legend = TRUE) +  # Adjust point size here
  geom_smooth(data = cover_wide %>% filter(shrub_native_sclerophyllous >= .50), 
              aes(x = shrub_native_sclerophyllous * 100, 
                  y = grass_nonnative * 100, 
                  color = "sclerophyllous"), 
              method = "lm", se = TRUE, linetype = "solid", show.legend = TRUE) +
  
 #  scl cover < 50%
  geom_point(data = cover_wide %>%  filter( shrub_native_sclerophyllous < .50
                                            #   & shrub_native_sclerophyllous > 0 
                                           ), 
             aes(x = shrub_native_sclerophyllous * 100, y = grass_nonnative * 100, 
                 color = "sclerophyllous" , 
                 shape = "sclerophyllous"
                 ), 
             size = 3, 
             show.legend = TRUE) +  # Adjust point size here
  geom_smooth(data = cover_wide %>% filter(shrub_native_sclerophyllous < .50), 
              aes(x = shrub_native_sclerophyllous * 100, 
                  y = grass_nonnative * 100, 
                  color = "sclerophyllous"), 
              method = "lm", se = TRUE, linetype = "solid", show.legend = TRUE) +
  
  #  ss cover >= 50%
  geom_point(data = cover_wide %>%  filter(shrub_native_nonsclero >= .50), 
             aes(x = shrub_native_nonsclero * 100, y = grass_nonnative * 100, 
                 color = "sage scrub", 
                 shape = "sage scrub"), 
             size = 3, 
             show.legend = TRUE) +  # Adjust point size here
  geom_smooth(data = cover_wide %>% filter(shrub_native_nonsclero >= .50), 
              aes(x = shrub_native_nonsclero * 100, 
                  y = grass_nonnative * 100, 
                  color = "sage scrub"), 
              method = "lm", se = TRUE, linetype = "dotted", show.legend = TRUE) +
  
   #  ss cover < 50%
  geom_point(data = cover_wide %>%  filter( shrub_native_nonsclero < .50
                                            #   & shrub_native_nonsclero > 0 
                                           ), 
             aes(x = shrub_native_nonsclero * 100, y = grass_nonnative * 100, 
                 color = "sage scrub", 
                 shape = "sage scrub"), 
             size = 3, 
             show.legend = TRUE) +  # Adjust point size here
  geom_smooth(data = cover_wide %>% filter(shrub_native_nonsclero < .50), 
              aes(x = shrub_native_nonsclero * 100, 
                  y = grass_nonnative * 100, 
                  color = "sage scrub"), 
              method = "lm", se = TRUE, linetype = "dotted", show.legend = TRUE) +
  # Labels
  labs(
    color = "Shrub Type",
    shape = "Shrub Type",
    x = "Shrub Cover (%)",
    y = "Non-naive grass cover (%)"
  ) +
  # Custom Shapes and Colors for Legend
  scale_shape_manual(values = c("sclerophyllous" = 7, "sage scrub" = 16), 
                     breaks = c("sclerophyllous", "sage scrub")) +  # Square = 15, Circle = 16
 
  # Reorder variables with sclerophyllous first
  scale_color_manual(values = c("sclerophyllous" = "black", "sage scrub" = "black"), 
                     breaks = c("sclerophyllous", "sage scrub")) +
  
  # Axis Limits
  xlim(0, 100) +
  ylim(0, 100) +
  # Theme
  theme_bw() +
  geom_abline(intercept = 100, slope = -1, color = "gray", linetype = "dashed") +
  # Annotations for Equation Labels
  annotate("text", x = 60, y = 98, label = eq_label_scl.50, color = "gray30", size = 4, hjust = 0) +
  annotate("text", x = 5, y = 15, label = eq_label_scl00, color = "grey30", size = 4, hjust = 0) + 
  
  annotate("text", x = 60, y = 84, label = eq_label_ss50, color = "gray30", size = 4, hjust = 0) +
  annotate("text", x = 5, y = 1, label = eq_label_ss00, color = "grey30", size = 4, hjust = 0) 
  
print(shrub_split)

```

2. x = total shrub
- y = native and non-native grass cover 
```{r}

############ non-native slope
# Fit the linear model
model.nng <- lm(grass_nonnative ~ shrub_native, data = cover_bylfstatus_wide) # response variable ~ independent variable

# Print the summary of the model
model.nng_summary <- summary(model.nng)
# Extract the intercept, slope, and R^2 values
interceptnng <- round(coef(model.nng)[1], 2)
slopenng <- round(coef(model.nng)[2], 2)
r_squarednng <- round(model.nng_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squarednng))
# [1] "Multiple R^2: 0.734"
# Create the label for the equation and R^2
eq_label_nng <- paste0("Non-native grass: y = ", slopenng, "x + ", interceptnng, "\n", "R² = ", r_squarednng)

######### native grass slope
# Fit the linear model
model.ng <- lm(grass_native ~ shrub_native, data = cover_bylfstatus_wide) # response variable ~ independent variable
model.ng_summary <- summary(model.ng)
# Extract the intercept, slope, and R^2 values
interceptng <- round(coef(model.ng)[1], 2)
slopeng <- round(coef(model.ng)[2], 2)
r_squaredng <- round(model.ng_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squaredng))
# [1] "Multiple R^2: 0.261"
# Create the label for the equation and R^2
eq_label_ng <- paste0("Native grass: y = ", slopeng, "x + ", interceptng, "\n", "R² = ", r_squaredng)

fig.1f <- ggplot(data = cover_bylfstatus_wide) + 
  #%>%  filter(forb_native > 0.01 | forb_nonnative > 0.01 | forb_unknown > 0.01)) +
  
  geom_point(aes(x = shrub_native * 100, 
                 y = grass_native * 100), 
             size = 3, shape = 1, show.legend = FALSE) +
  geom_smooth(aes(x = shrub_native * 100, y = grass_native * 100, color = "grass_native"),
             method = "lm", se = TRUE, linetype = "dashed", show.legend = FALSE) +
  
  geom_point(aes(x = shrub_native * 100, 
                 y = grass_nonnative * 100), 
             size = 3, shape = 16 , show.legend = FALSE) +
  geom_smooth(aes(x = shrub_native * 100, y = grass_nonnative * 100, color = "grass_nonnative"), 
              method = "lm", se = TRUE, linetype = "solid", show.legend = FALSE) +
  labs(
     # title = "Comparison of native and non-native forb percent cover by Nonnative Grass percent cover",
      color = "Status",
    x = "Native shrub cover (%)",
    y = "Grass cover (%)"
    ) +
  scale_color_manual(values = c(
     "grass_native" = "black", 
    "grass_nonnative" = "black"),
                     labels = c(
                        "Native ", 
                       "Non-native")) +
  xlim(0, 100) +
  ylim(0, 100) +
  theme_bw() +
  annotate("text", x = 0, y = 40, label = eq_label_nng, color = "black", size = 4, hjust = 0) +
  annotate("text", x = 0, y = 25, label = eq_label_ng, color = "black", size = 4, hjust = 0) +
  geom_abline(intercept = 100, slope = -1, color = "darkgray", linetype = "dashed")

fig.1f


ggplot(data = cover_bylfstatus_wide, 
       aes(x = shrub_native * 100, 
           y = grass_nonnative * 100)) +
  geom_point(size = 3, show.legend = TRUE) +
  geom_smooth(aes(color = grass_nonnative), method = "lm", se = TRUE, linetype = "dashed", show.legend = TRUE) +
  labs(
    x = "Shrub Native Cover (%)",
    y = "Grass Non-native Cover (%)",
    title = "Relationship Between Shrub Native and Grass Non-native Cover"
  ) +
  theme_minimal() +
  facet_grid(~ cluster) +
   geom_abline(intercept = 100, slope = -1, color = "gray", linetype = "dashed")
  


```

- y = non-native grass cover at SHRUB COVER >50% and <50%
```{r, eval = FALSE}
# 
# shrub_50 <- ggplot(data = (cover_bylfstatus_wide %>%  filter(shrub_native >= .50)), 
#        aes(x = shrub_native*100,
#            y = grass_nonnative*100
#            )) + 
#    geom_point(aes(color = site), size = 3) +
#   scale_color_manual(values = c("blue", "blue", "maroon", "maroon", "maroon", "maroon", "maroon")) +
#   geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval 
#   labs(
#     x = "Native shrub cover (%)",
#     y = "Non-native grass cover (%)",
#    # title = "Linear regression of non-native grass by sclerophyllous shrub percent cover"
#    color = "Site"
#     ) +
# scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
#   scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
#   theme_bw() +
#    annotate("text", x = 0, y = 5, label = eq_label_nng, color = "black", size = 4, hjust = 0) 
# 
# shrub_0 <- ggplot(data = (cover_bylfstatus_wide %>%  filter(shrub_native < .50)), 
#        aes(x = shrub_native*100,
#            y = grass_nonnative*100
#            )) + 
#    geom_point(aes(color = site), size = 3) +
#   scale_color_manual(values = c("blue", "blue", "maroon", "maroon", "maroon", "maroon", "maroon")) +
#   geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval 
#   labs(
#     x = "Native shrub cover (%)",
#     y = "Non-native grass cover (%)",
#    # title = "Linear regression of non-native grass by sclerophyllous shrub percent cover"
#    color = "Site"
#     ) +
# scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
#   scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
#   theme_bw() +
#    annotate("text", x = 0, y = 5, label = eq_label_nng, color = "black", size = 4, hjust = 0) 
# 
# 
# shrub_50
# shrub_0

```

- y = non-native FORB cover
```{r}
############ non-native slope
# Fit the linear model
model.nnf <- lm(forb_nonnative ~ shrub_native, data = cover_bylfstatus_wide) # response variable ~ independent variable

# Print the summary of the model
model.nnf_summary <- summary(model.nnf)
# Extract the intercept, slope, and R^2 values
interceptnnf <- round(coef(model.nnf)[1], 2)
slopennf <- round(coef(model.nnf)[2], 2)
r_squarednnf <- round(model.nnf_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squarednnf))
# [1] "Multiple R^2: 0.108"
# Create the label for the equation and R^2
eq_label_nnf <- paste0("Non-native forb: y = ", slopennf, "x + ", interceptnnf, "\n", "R² = ", r_squarednnf)


######### native forb slope
# Fit the linear model
model.nf <- lm(forb_native ~ shrub_native, data = cover_bylfstatus_wide) # response variable ~ independent variable
model.nf_summary <- summary(model.nf)
# Extract the intercept, slope, and R^2 values
interceptnf <- round(coef(model.nf)[1], 2)
slopenf <- round(coef(model.nf)[2], 2)
r_squarednf <- round(model.nf_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squarednf))
# [1] "Multiple R^2: 0.002"
# Create the label for the equation and R^2
eq_label_nf <- paste0("Native forb: y = ", slopenf, "x + ", interceptnf, "\n", "R² = ", r_squarednf)

fig.1d <- ggplot(data = cover_bylfstatus_wide) + #%>%  filter(forb_native > 0.01 | forb_nonnative > 0.01 | forb_unknown > 0.01)) +
  geom_point(aes(x = shrub_native * 100, y = forb_native * 100, color = "forb_native"), 
             size = 3, shape = 1, show.legend = FALSE) +
  geom_smooth(aes(x = shrub_native * 100, y = forb_native * 100, color = "forb_native"), 
              method = "lm", se = TRUE, linetype = "dashed", show.legend = FALSE) +
  
  geom_point(aes(x = shrub_native * 100, y = forb_nonnative * 100, color = "forb_nonnative"), 
             size = 3, shape = 16, show.legend = FALSE) +
  geom_smooth(aes(x = shrub_native * 100, y = forb_nonnative * 100, color = "forb_nonnative"), 
              method = "lm", se = TRUE, linetype = "solid", show.legend = FALSE) +
  labs(
     # title = "Comparison of native and non-native forb percent cover by Nonnative Grass percent cover",
      color = "Status",
    x = "Native shrub cover (%)",
    y = "Forb cover (%)"
    ) +
  scale_color_manual(values = c("forb_native" = "black", "forb_nonnative" = "black"),
                     labels = c("Native ", "Non-native")) +
  xlim(0, 100) +
  ylim(0, 100) +
  theme_bw() +
  annotate("text", x = 50, y = 90, label = eq_label_nnf, color = "black", size = 4, hjust = 0) +
  annotate("text", x = 50, y = 75, label = eq_label_nf, color = "black", size = 4, hjust = 0) +
  geom_abline(intercept = 100, slope = -1, color = "darkgray", linetype = "dashed")

fig.1d


 

```

- y = shrub cover by leaftype by HILLSLOPE
```{r, eval = FALSE}
# ggplot(data = (cover_bylfstatusleaftype %>%
#                  filter(lifeform_status == "shrub_native") %>%
#               mutate(site = case_when(
#                            site %in% c("INT1", "INT2", "INT3", "INT4", "INT5") ~ "INT",
#                            TRUE ~ site)
#                         )
#                ),
#        aes(y = lifeform_status_leaftype_percentcover*100,
#            x = lifeform_status_percentcover*100)) +
#    # geom_point(aes(color = site), size = 3) +
#    # scale_color_manual(values = c("blue", "green", "maroon", "maroon", "maroon", "maroon", "maroon")) +
# 
#   geom_point(aes(color = lifeform_status_leaftype), size = 3) +
#    scale_color_manual(values = c("black", "gray", "green")) +
# 
#    scale_shape_manual(values = c(4, 1, 16)) +
# 
#  # geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
#   labs(
#     x = "Total shrub cover (%)",
#     y = "Shrub cover by leaf type (%)",
#     title = "Total shrub cover as a product of dead, non-scl, or scl shrubs"
#     ) +
# scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
#   scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
#   theme_bw() +
#   geom_abline(intercept = 0, slope = 1) +
#   facet_wrap(~site) # lifeform_status_leaftype

```


```{r}
fig.1b <- ggplot(data = (cover_wide %>%  
                 filter(shrub_native_sclerophyllous > 0.01)
               ), 
       aes(x = shrub_native_sclerophyllous*100,
           y = grass_nonnative_NA*100
           )) + 
   geom_point(aes(color = site), size = 3) +
   scale_color_manual(values = c("blue", "maroon", "maroon", "maroon", "maroon", "maroon")) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval 
  labs(
    x = "Schlerophylous shrub cover (%)",
    y = "Non-native grass cover (%)",
    title = "Linear regression of non-native grass by sclerophyllous shrub percent cover"
    ) +
scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  theme_bw() +
  geom_abline(intercept = 100, slope = -1, color = "gray", linetype = "dashed")
  
fig.1b

# Fit the linear model
model.s <- lm(grass_nonnative_NA ~ shrub_native_sclerophyllous, data = cover_byleaftype_wide %>%  
                 filter(shrub_native_sclerophyllous > 0.01)) # response variable ~ independent variable

# Print the summary of the model
model.s_summary <- summary(model.s)

# Extract the R^2 value
r_squared <- round(model.s_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squared))
#  "Multiple R^2: 0.442"

```

3. x = css
y = non-native grass cover 
```{r, eval = FALSE}
ggplot(data = (cover_byleaftype_wide %>%  
                 filter(shrub_native_nonsclero > 0.01)
               ), 
       aes( x = shrub_native_nonsclero*100, 
            y = grass_nonnative_NA*100)
       ) + 
   geom_point(aes(color = site), size = 3) +
   scale_color_manual(values = c("blue", "blue", "maroon", "maroon", "maroon", "maroon", "maroon")) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval 
  labs(
    x = "Sage scrub cover (%)",
    y = "Non-native grass cover (%)",
    title = "Linear regression of non-native grass by sage scrub shrub percent cover"
    ) +
scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  theme_bw()


# Fit the linear model <- for all sites
model.s <- lm(grass_nonnative_NA ~ shrub_native_nonsclero, # response variable ~ independent variable
              data = cover_byleaftype_wide %>%  
                 filter(shrub_native_nonsclero > 0.01))
# Print the summary of the model
model.s_summary <- summary(model.s)
# Extract the R^2 value
r_squared <- round(model.s_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squared))
# [1] "Multiple R^2: 0.327" <-- all sites

# Fit the linear model <- for sites 1 and 2
model.s2 <- lm(grass_nonnative_NA ~ shrub_native_nonsclero, # response variable ~ independent variable
              data = cover_byleaftype_wide %>%  
                 filter(shrub_native_nonsclero > 0.01) %>% 
                filter(site == "1" | site == "2"))
model.s2_summary <- summary(model.s2)
r_squared_s2 <- round(model.s2_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squared_s2))
# [1] "Multiple R^2: 0.684" <-- sites 1 and 2

ggplot(data = (cover_byleaftype_wide %>%  
                 filter(site == "1" | site == "2") %>% 
                 filter(shrub_native_nonsclero > 0.01) 
               ), 
       aes( x = shrub_native_nonsclero*100, 
            y = grass_nonnative_NA*100)
       ) + 
   geom_point(aes(color = site), size = 3) +
   scale_color_manual(values = c("maroon", "pink", "maroon", "maroon", "maroon")) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval 
  labs(
    x = "Sage scrub cover (%)",
    y = "Non-native grass cover (%)",
    title = "Linear regression of non-native grass by sage scrub shrub percent cover"
    ) +
scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  theme_bw()

##################

# Fit the linear model <- for sites INT1-5
model.s3 <- lm(grass_nonnative_NA ~ shrub_native_nonsclero, # response variable ~ independent variable
              data = (cover_byleaftype_wide %>%  
               filter(site != "1" & site != "2") %>% 
                 filter(shrub_native_nonsclero > 0.01)
              ))
model.s3_summary <- summary(model.s3)
r_squared_s3 <- round(model.s3_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squared_s3))
# [1] "Multiple R^2: 0.693" <-- sites INT

ggplot(data = (cover_byleaftype_wide %>%  
                 filter(site != "1" & site != "2") %>% 
                 filter(shrub_native_nonsclero > 0.01) 
               ), 
       aes( x = shrub_native_nonsclero*100, 
            y = grass_nonnative_NA*100)
       ) + 
   geom_point(aes(color = site), size = 3) +
   scale_color_manual(values = c("maroon", "red", "cyan", "green", "blue")) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval 
  labs(
    x = "Sage scrub cover (%)",
    y = "Non-native grass cover (%)",
    title = "Non-native grass by mean sage scrub shrub cover per site"
    ) +
scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  theme_bw()
```

4. x = nn grass

### - correlations
```{r, eval = FALSE}

# NOTES

?cor # Correlation, Variance and Covariance (Matrices)
# var, cov and cor compute the variance of x and the covariance or correlation of x and y if these are vectors. 
# If x and y are matrices then the covariances (or correlations) between the columns of x and the columns of y are computed.

?cor.test # Test for Association/Correlation Between Paired Samples
# Test for association between paired samples, using one of Pearson's product moment correlation coefficient, Kendall's τ or Spearman's ρ.


# e.g., 
cor(herb_cover_wide$grass_nonnative,  
    herb_cover_wide$forb_native, method = "spearman")
cor.test(herb_cover_wide$grass_nonnative,  
    herb_cover_wide$forb_native, method = "spearman") # rho = 0.1074625
cor.test(herb_cover_wide$grass_nonnative,  
    herb_cover_wide$forb_native, method = "pearson") # cor = 0.1005004 

# Pearson's correlation measures the linear relationship between two continuous variables,
# while Spearman's correlation measures the monotonic relationship (variables consistently move in the same or opposite direction) between two ranked or ordinal variables. 
# --> Choose Pearson's for normally distributed, continuous data with a linear pattern
# --> Choose Spearman's for non-normally distributed, ordinal, or ranked data, especially when outliers are present, as it is more robust


# I think cor and cor.test run the same correlation, but cor.test gives you the correlation value, df, and p-values, while cor only gives you the correlation value.
# I think running spearman is best if data are non-normally distributed or if there are outlines

```

##### - qqplots 
```{r}
view(herb_cover_wide)


hist(herb_cover_wide$grass_nonnative)
qqnorm(herb_cover_wide$grass_nonnative)
qqline(herb_cover_wide$grass_nonnative, col = "red", lwd = 2)

hist(herb_cover_wide$shrub_native)
qqnorm(herb_cover_wide$shrub_native)
qqline(herb_cover_wide$shrub_native, col = "darkgreen", lwd = 2)

hist(herb_cover_wide$herb_native)
qqnorm(herb_cover_wide$herb_native)
qqline(herb_cover_wide$herb_native, col = "purple", lwd = 2)

hist(herb_cover_wide$forb_native)
qqnorm(herb_cover_wide$forb_native)
qqline(herb_cover_wide$forb_native, col = "orchid", lwd = 2)

hist(herb_cover_wide$grass_native)
qqnorm(herb_cover_wide$grass_native)
qqline(herb_cover_wide$grass_native, col = "green", lwd = 2)

# qq plots of herb, forb, and native grass are a bit skews

shapiro.test(herb_cover_wide$grass_nonnative) # <-- not normally distributed
shapiro.test(herb_cover_wide$shrub_native) # <-- normally distributed
shapiro.test(herb_cover_wide$herb_native) # <-- not normally distributed
shapiro.test(herb_cover_wide$forb_native) # <-- not normally distributed
shapiro.test(herb_cover_wide$grass_native) # <-- not normally distributed


# Select only numeric variables and total_nncover
cor(herb_cover_wide[, 
                                      c("grass_nonnative", 
                                        "shrub_native", 
                                         "herb_native", 
                                        "forb_native", 
                                        "grass_native")], 
                  use = "pairwise.complete.obs", 
                 method = "spearman") # Pearson correlation coefficient for normally distributed data that has a linear relationship
```

##### - y = total shrub cover

--  plot
```{r}

# Fit the poly model
# model.s <- lm(shrub_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide)
model.s <- lm(shrub_native ~ grass_nonnative + I(grass_nonnative^2), data = cover_bylfstatus_wide) # poly equation 
coef(model.s) # model coeficients
# shrub_native = a + b⋅grass_nonnative + c⋅grass_nonnative2
# shrub_native = 0.885 − 0.077⋅grass_nonnative − 0.687⋅grass_nonnative2
# y = a + bx + c xx
# a <- round(coef(model.s)[1], 3) # intercept
# b <- round(coef(model.s)[2], 3)
# c <- round(coef(model.s)[3], 3)
# equ_s <- print(paste0("y = ", a, " + (", b, ")x + (",c , ")x²"))
equ_s <- print(paste0("y = ", round(coef(model.s)[1], 2), " + (", round(coef(model.s)[2], 2), ")x + (", round(coef(model.s)[3], 2), ")x²"))

summary(model.s) 
# r_squareds <- round(summary(model.s)$r.squared, 2)
r_shrub <- print(paste0("R² = ", round(summary(model.s)$r.squared, 2)))
# Create the label for the equation and R^2


label_s <- paste0(equ_s,  "\n", 
                  r_shrub)

# find the inflection point
b <- coef(
  lm(shrub_native ~ poly(grass_nonnative, 2, raw = TRUE), 
            data = cover_bylfstatus_wide))
# If: b[3]>0, the parabola opens upward (minimum point).
# If: b[3]<0, it opens downward (maximum point).

# Calculate turning point
x_star <- -b[2] / (2 * b[3])
x_star

nngxnatshr <- ggplot(data = cover_bylfstatus_wide, 
       aes(x = grass_nonnative*100,
         y = shrub_native*100)) + 
  geom_vline(xintercept = 52.7, color = "gray", linewidth = 1, lty = 3) +
      geom_point(aes(color = cluster), size = 3,  show.legend = FALSE) +
   scale_color_manual(values = colors_plantclusters) +

    stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +
  
  labs(
    #  title = "Linear regression of  total shrub cover by non-native grass cover",
    x = "Non-native grass cover (%)",
    y = "Native shrub cover (%)", 
     color = "Plant Cluster"
    ) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 20)) + # Set y-axis limits and breaks
  theme_bw() +
  
  theme(axis.text = element_text(size = 16)) + # axes numbers - font size
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 16)) + 
  theme(legend.text=element_text(size = 16)) +
  annotate("text", x = 0, y = 10, label = label_s, color = "black", size = 6, hjust = 0) 
  
  
nngxnatshr
```
```{r}

######################################

summary(
  segmented(
  lm(shrub_native ~ grass_nonnative, data = cover_bylfstatus_wide)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1)
  )

# breakpoint = 52.7%
# slope < 52.7% = -0.35924; p = 0.223 
# slope > 52.7% = -1.22714; p = NA 


# Plot the segmented regression model and increase text sizes
plot(segmented(
  lm(shrub_native ~ grass_nonnative, data = cover_bylfstatus_wide)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1), 
     conf.level = 0.95, 
     shade = TRUE,
     # main = "Segmented Regression with Confidence Interval",
     xlab = "Non-Native Grass Cover (%)", 
     ylab = "Native Shrub Cover (%)",
     cex.main = 1.5,   # Increase the main title size
     cex.lab = 1.3,    # Increase the axis labels size
     cex.axis = 1.2)   # Increase the axis numbers size

# Add the original data points, increasing their size as well
points(cover_bylfstatus_wide$grass_nonnative, 
       cover_bylfstatus_wide$shrub_native,
       col = colors_plantclusters,
       pch = 16,
       cex = 1.5)      # Increase the size of the data points
```


-- stats
Types of linear regressions:
- Correlations
- Linear regression = straight line
- Polynomial regression = test for simple curvature.
- GAMs = flexible non-linear trend.
- Piecewise regression = detect thresholds or breakpoints.
- Quantile regression = test upper/lower bounds of the relationship.

The "best" regression is a: Polynomial Regression
```{r}
# Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.

summary(
  lm(shrub_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide)
  )

#  second-order polynomial regression
# F-statistic: 61.53 on 2 and 37 DF <-- F(2, 37) = 61.53
# p-value: 1.707e-12 <-- p < 0.001
# R2 = 0.77
# not Adjusted R2 since only one predictive variable

summary(
  segmented(lm(shrub_native ~ grass_nonnative, data = cover_bylfstatus_wide),
            seg.Z = ~grass_nonnative,
                       npsi = 1) 
)
# Est. St.Err
# psi1.grass_nonnative 0.527   0.13



# Extract residuals from the poly model
residuals_poly <- residuals(
  lm(shrub_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide)
  )

# Extract residuals from the segmented model
residuals_segmented <- residuals(
  segmented( lm(shrub_native ~ grass_nonnative, data = cover_bylfstatus_wide)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1)
)
# Plot the Q-Q plot for the poly model residuals
qqnorm(residuals_poly, main = "Q-Q Plot for Poly Model Residuals")
qqline(residuals_poly, col = "red")
```

```{r}
# Plot the Q-Q plot for the segmented model residuals
qqnorm(residuals_segmented, main = "Q-Q Plot for Segmented Model Residuals")
qqline(residuals_segmented, col = "blue")


```
- sand box
```{r, eval = FALSE}

# sand box

# how to report correlations in manuscipts: 
# https://www.statology.org/how-to-report-pearson-correlation/
# https://phdassistance.com/academy/reporting-regression-analysis/ 

################################################################ 
##### other regression and correlation tests between nn grass cover and shrub cover


# Takeaway:
# Correlations - linear
# Linear regression
# Polynomial regression = test for simple curvature.
# GAMs = flexible non-linear trend.
# Piecewise regression = detect thresholds or breakpoints.
# Quantile regression = test upper/lower bounds of the relationship.

# Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(cover_bylfstatus_wide$grass_nonnative, 
         cover_bylfstatus_wide$shrub_native)
# Pearson's product-moment correlation 
### t = test statistic = -10.243 <-- |-10.243| = number is large, correlation unlikely by chance
### df = 38
### p-value = 1.747e-12 <-- sig!
### cor = -0.856795 <-- Correlation coefficient; strong negative correlation 
### 95% CI: -0.9221759 -0.7438076 <-- you are 95% confident the true correlation lies in this range, which is still very strong and negative.

# linear regression
model_lm <- lm(shrub_native ~ grass_nonnative, data = cover_bylfstatus_wide) 
# Intercept =  1.0278 <-- when non-native grass cover = 0, shrub cover is predicted to be about 1.03
# grass_nonnative = -0.8411 <-- slope, for every 1% increase in grass cover, shrub cover decreases by about 0.84%.
summary(glm(shrub_native ~ grass_nonnative, 
    family =  binomial(link = "logit"),
    data = cover_bylfstatus_wide))


# Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(shrub_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide)
summary(model_poly)
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -0.26850 -0.11923  0.04357  0.10246  0.31940 
# 
# Coefficients:
#                           Estimate Std. Error t value Pr(>|t|)    
# (Intercept)                 0.4811     0.0237  20.302  < 2e-16 ***
# poly(grass_nonnative, 2)1  -1.6246     0.1499 -10.840 4.87e-13 ***
# poly(grass_nonnative, 2)2  -0.3534     0.1499  -2.358   0.0238 *  
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# Residual standard error: 0.1499 on 37 degrees of freedom
# Multiple R-squared:  0.7688,	Adjusted R-squared:  0.7563 
# F-statistic: 61.53 on 2 and 37 DF,  p-value: 1.707e-12


# Generalized Additive Models (GAMs) - If you don’t want to assume the shape (e.g., parabola), GAMs let the data “decide” the curve:
model_gam <- gam(shrub_native ~ s(grass_nonnative), data = cover_bylfstatus_wide)
summary(model_gam)
# Parametric coefficients:
            # Estimate    Std. Error  t value     Pr(>|t|)    
# (Intercept)  0.48110    0.02365     20.34       <2e-16 *** <-- sig!
# -- Parametric intercept = 0.4811 <-- When grass cover = 0, the baseline shrub cover is ~48%
# 
# Approximate significance of smooth terms:
                     # edf      Ref.df          F p-value    
# s(grass_nonnative) 2.054      2.548 48.09     <2e-16 ***

# R-sq.(adj) =  0.757 <-- model explains ~76% of variance
#  Deviance explained =   77% <- similar to R²
# GCV = 0.02422  Scale est. = 0.022371  n = 40 <-- you want small GCV and Scale fit
plot(model_gam)
# - GAMs are flexible and can capture non-linear but smooth patterns.
# - You can test significance of the smooth term (edf > 1 indicates non-linearity).
## plot_gam code in next chunk


# Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_seg <- segmented(model_lm, seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
# plot(segmented(model, seg.Z = ~grass_nonnative, 
#                npsi = 2)) # <- you can set the number of breakpoints here
summary(model_seg)
plot(model_seg)
# - This estimates a breakpoint (e.g., shrubs decline only after grass > 40%).
# - You’ll get separate slopes before and after the threshold.

# Quantile Regression - Sometimes the average trend isn’t the full story — for example, shrubs may persist under moderate grass cover only in the “best-case” sites. Quantile regression shows how the relationship differs across the distribution of shrub cover.
model_qr <- rq(shrub_native ~ grass_nonnative, tau = 0.9, data = cover_bylfstatus_wide)
summary(model_qr)
# - This tests whether the upper limit of shrub cover declines with grass cover.

# tau: [1] 0.9 <-- quantile regression at the 90th percentile
# Coefficients:
#                 coefficients lower bound   upper bound
# (Intercept)      1.17561      1.07409       2.31828 <-- (1.176, CI: 1.07 – 2.32)
# grass_nonnative -0.80000     -1.76827       -0.44443

# Intercept: (1.176, CI: 1.07 – 2.32) <-- When non-native grass cover = 0, the upper end (90th percentile) of shrub cover is ~1.18%

# Slope for grass_nonnative: (–0.80, CI: –1.77 to –0.44) <-- At the 90th percentile, for every 1% increase in non-native grass cover, shrub cover is predicted to decrease by ~0.8%.
# Since the confidence interval is entirely below zero (–1.77 to –0.44), the effect is statistically significant: more non-native grass strongly limits the upper potential of shrub cover.

###### Ecological interpretation
# - You’re looking at the upper bound of possible shrub cover, not the average.
# - The result suggests that EVEN UNDER the best-case conditions (stands with unusually high shrub cover for their level of grass invasion), shrub cover still declines steeply as non-native grass cover increases.
# 
# - In practice: stands with low grass cover can sustain high shrub cover, but as grass cover increases, the “ceiling” on shrub cover gets pushed down sharply.


### Model Comparison
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AIC_shrub <- (AIC(model_lm, model_poly, model_gam, model_seg))
# Lower/more negative AIC = better fit.
# - GAM is best fit, but polynomial and segmented regressions are just as good of a fit too.

# Or use likelihood ratio tests: (anova(model, model_poly) if models are nested).




##################################### to compare a GAM regression against a polynomial regression

# Create a prediction dataset
newdat <- data.frame(grass_nonnative = seq(min(cover_bylfstatus_wide$grass_nonnative),
                                           max(cover_bylfstatus_wide$grass_nonnative),
                                           length.out = 200))

# Predict fitted values and confidence intervals
pred <- predict(model_gam, newdata = newdat, se.fit = TRUE)
newdat$fit <- pred$fit
newdat$upper <- pred$fit + 2 * pred$se.fit
newdat$lower <- pred$fit - 2 * pred$se.fit

# Plot with ggplot
plot_gam <- ggplot() +
  # observed points
  
  geom_point(data = cover_bylfstatus_wide,
             aes(x = grass_nonnative, y = shrub_native),
             shape = 21, 
             fill = "skyblue", color = "black", size = 3, alpha = 0.7) +

  # polynomial regression line
  geom_smooth(data = cover_bylfstatus_wide, 
              aes(x = grass_nonnative, y = shrub_native, color = "Polynomial"), 
              method = "lm", formula = y ~ poly(x, 2), se = TRUE, size = 1.2) +

  # GAM fit line
  geom_line(data = newdat, 
            aes(x = grass_nonnative, y = fit, color = "GAM"), 
            size = 1.2) +

  # confidence ribbon
  geom_ribbon(data = newdat,
              aes(x = grass_nonnative, ymin = lower, ymax = upper),
              fill = "lightblue", alpha = 0.3) +

  scale_color_manual(name = "Model", values = c("Polynomial" = "red", "GAM" = "blue")) +
  
  labs(x = "Non-native grass cover (%)",
       y = "Native shrub cover (%)",
       title = "Shrub cover vs. Grass cover") +
  theme_minimal(base_size = 14)

plot_gam

```


```{r}
# Maxi code (9/276/2025)

#### checking residuals
ggqqplot(herb_cover_wide$shrub_native)

# linear
model_lmsh <- lm(shrub_native ~ grass_nonnative, data = herb_cover_wide)
residuals(model_lmsh) # → raw or standardized differences between observed & fitted values.

plot(fitted(model_lmsh) ~ resid(model_lmsh)) # looks random

testDispersion(simulateResiduals( # linear
  lm(shrub_native ~ grass_nonnative,
         data = herb_cover_wide, 
      family=gaussian))) # 0.97615
# Q-Q plot
qqnorm(residuals(model_lmsh))
qqline(residuals(model_lmsh), col = "red")
model_lmsh_res<- simulateResiduals(model_lmsh) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_lmsh_res) # 1

summary(model_lmsh)

# polynomial
model_polysh <- lm(shrub_native ~ poly(grass_nonnative, 2), data = herb_cover_wide)
residuals(model_polysh)

qqnorm(residuals(model_polysh)) # qqplot - ROB
qqline(residuals(model_polysh), col = "red") # qqplot - ROB
plot(fitted(model_polysh) ~ resid(model_polysh)) # scatter plot - ROB

testDispersion(simulateResiduals(
  lm(shrub_native ~ poly(grass_nonnative, 2),
         data = herb_cover_wide, 
      family=gaussian))) # 0.95046
model_polysh_res<- simulateResiduals(model_polysh) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_polysh_res) # 0.912

# segmented
model3 <- segmented(lm(shrub_native ~ grass_nonnative, data = herb_cover_wide, seg.Z = ~ grass_nonnative,
                       npsi = 1) )
qqnorm(residuals(model3))
qqline(residuals(model3), col = "red")
residuals(model3)
plot(fitted(model3) ~ resid(model3))

```
-- linear equation
```{r, eval = FALSE}
# quadratic regression equation:  y = ax² + bx + c

# Fit the linear model
model.s <- lm(grass_nonnative ~ shrub_native, data = cover_bylfstatus_wide) # response variable ~ independent variable

# Print the summary of the model
model.s_summary <- summary(model.s)
intercept <- round(coef(model.s)[1], 2)
slope <- round(coef(model.s)[2], 2)
# Extract the R^2 value
r_squared <- round(model.s_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squared))
# [1] "Multiple R^2: 0.734"


# adjusted_r_squared <- round(model.s_summary$adj.r.squared, 3)
# print(paste("Adjusted R^2:", adjusted_r_squared))

# Multiple R-squared = variance in the dependent variable that is predictable from the independent variables.  It indicates how well the independent variables explain the variation in the dependent variable. 

# Adjusted R-squared = adjusts for the number of predictors in the model.  It provides a more accurate measure when comparing models with a different number of predictors.

# Create the label for the equation and R^2
eq_label <- paste0("y = ", slope, "x + ", intercept, "\n", "R² = ", r_squared)
```

-- linear mixed-effects model
--> I don't think I need to run lmers becuae I don't have repeated measurments and I don't have multiple predictor variables.
```{r, eval = FALSE}
lme.shrub <- lmer(shrub_native ~ grass_nonnative + (1|site), 
                   data = cover_bylfstatus_wide)

MOD <- lme.shrub

# Calculate model's residual and fitted values
F1 <- fitted(MOD)
E1 <- residuals(MOD, "pearson")

# See residuals as a histogram, look for normal distribution
hist(E1)

# Graph residuals against a normal distribution, look for all points to be on 1:1 line
# need to call next two lines together
qqnorm(E1, xlab = "Theoretical Quantiles", ylab = "Pearson Residuals")
qqline(E1)

# Graph residuals vs fitted values to inspect homogeneity of variance, look for a random scattering of plots
# run together 2 lines
plot(x=F1, y=E1, xlab="Fitted Model Values", ylab="Pearson Residuals", main = "Variance")
abline(h = 0) # looking for random scatter

# Check for crazy outliers, look for lines MUCH taller than the rest of data
plot(cooks.distance(MOD))

# Plot a box plot for each factor, look for equal variance amount levels along the zero line
# Box plots need to be assessed for every fixed effect (categorical factor) for your model. 
# Random effects need the qqline just like normality. 
# So, only site and treatment get box plots. 
# MAFA cover is a covariate (continuous variable).
boxplot(E1 ~ site, data = cover_bylfstatus_wide)
abline(h = 0)

# Plot each random effect in the model, look for dots along 1:1 line
qqnorm(ranef(MOD)$site[,1], main = "Plot Residuals")
qqline(ranef(MOD)$site[,1])

MOD <- lme.tdrmod
simulationOutput <- simulateResiduals(fittedModel = MOD, plot = T)

```

- y = total shrub cover x leaf type
```{r}

############ scl slope
# Fit the linear model
model.scl <- lm(shrub_native_sclerophyllous ~ grass_nonnative_NA, data = (cover_byleaftype_wide %>%  
                                                                            filter(shrub_native_sclerophyllous > 0))) # response variable ~ independent variable

# Print the summary of the model
model.scl_summary <- summary(model.scl)
# Extract the intercept, slope, and R^2 values
interceptscl <- round(coef(model.scl)[1], 2)
slopescl <- round(coef(model.scl)[2], 2)
r_squaredscl <- round(model.scl_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squaredscl))
# [1] "Multiple R^2: 0.442"
# Create the label for the equation and R^2
eq_label_scl <- paste0("Scl: y = ", slopescl, "x + ", interceptscl, "\n", "R² = ", r_squaredscl)


######### sage scrub slope
# Fit the linear model
model.ss <- lm(shrub_native_nonsclero ~ grass_nonnative_NA, data = (cover_byleaftype_wide %>%  filter(shrub_native_nonsclero > 0))) # response variable ~ independent variable
model.ss_summary <- summary(model.ss)
# Extract the intercept, slope, and R^2 values
interceptss <- round(coef(model.ss)[1], 2)
slopess <- round(coef(model.ss)[2], 2)
r_squaredss <- round(model.ss_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squaredss))
# [1] "Multiple R^2: 0.327"
# Create the label for the equation and R^2
eq_label_ss <- paste0("Nonscl: y = ", slopess, "x + ", interceptss, "\n", "R² = ", r_squaredss)


fig.1a <- ggplot(data = cover_byleaftype_wide) +
  # Sclerophyllous Shrub Cover
  geom_point(data = cover_byleaftype_wide, # %>% filter(shrub_native_sclerophyllous > 0
             aes(x = grass_nonnative_NA * 100, y = shrub_native_sclerophyllous * 100, 
                 color = "sclerophyllous", shape = "sclerophyllous"), 
             size = 3, show.legend = FALSE) +  # Adjust point size here
  geom_smooth(data = cover_byleaftype_wide , # %>% filter(shrub_native_sclerophyllous > 0) 
              aes(x = grass_nonnative_NA * 100, y = shrub_native_sclerophyllous * 100, color = "sclerophyllous"), 
              method = "lm", se = TRUE, linetype = "dotdash", show.legend = FALSE) +
  # Sage Scrub Cover
  geom_point(data = cover_byleaftype_wide, 
             aes(x = grass_nonnative_NA * 100, y = shrub_native_nonsclero * 100, 
                 color = "sage scrub", shape = "sage scrub"), 
             size = 3, show.legend = FALSE) +  # Adjust point size here
  geom_smooth(data = cover_byleaftype_wide, 
              aes(x = grass_nonnative_NA * 100, y = shrub_native_nonsclero * 100, color = "sage scrub"), 
              method = "lm", se = TRUE, linetype = "dotted", show.legend = FALSE) +
  # Labels
  labs(
    color = "Shrub Type",
    shape = "Shrub Type",
    x = "Non-native grass cover (%)",
    y = "Shrub cover (%)"
  ) +
  # Custom Shapes and Colors for Legend
  scale_shape_manual(values = c("sclerophyllous" = 7, "sage scrub" = 4)) +  # Square = 15, Circle = 16, 8 = *
  scale_color_manual(values = c("sclerophyllous" = "black", "sage scrub" = "black")) +
  # Axis Limits
  xlim(0, 100) +
  ylim(0, 100) +
  # Theme
  theme_bw() +
  # Annotations for Equation Labels
  annotate("text", x = 67, y = 90, label = eq_label_scl, color = "gray30", size = 4, hjust = 0) +
  annotate("text", x = 67, y = 75, label = eq_label_ss, color = "grey30", size = 4, hjust = 0) +
  geom_abline(intercept = 100, slope = -1, color = "darkgray", linetype = "dashed")



fig.1a

# quadratic regression equation:  y = ax² + bx + c
```

 - y = scl shrub cover 
```{r regression nngrass x scl shrub, eval = FALSE}
 ggplot(data = cover_byleaftype_wide #%>%  
          # filter(shrub_native_sclerophyllous > 0.01) #include/omit 0% cover
        , 
       aes(x = grass_nonnative_NA*100, 
         y = shrub_native_sclerophyllous*100)) + 
  # geom_point()+
     geom_point(aes(color = site), size = 3) +
     scale_color_manual(values = c("blue", "blue", "maroon", "maroon", "maroon", "maroon", "maroon")) +
  # geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval  # linear fit
  stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +  # polynomial fit
  labs(
    x = "Non-native grass cover (%)",
    y = "Native scl shrub cover (%)",
    title = "Linear regression of  scl shrub cover by non-native grass cover"
    ) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  theme_bw()

# Fit the linear model
model.s <- lm(shrub_native_sclerophyllous ~ grass_nonnative_NA, data = cover_byleaftype_wide %>% filter(shrub_native_sclerophyllous > 0.01)) # response variable ~ independent variable

# print slope and intercept
cf <- round(coef(model.s), 3)
cat("Intercept:", cf[1], "\n")
cat("Slope:", cf[2], "\n")
# cf <- coef(model.s).   # <-- old code
# Intercept <- cf$(Intercept)
# Slope <- cf[2]
# Intercept <- round(Intercept, 3)
# Slope <- round(Slope, 3)
# print(paste("Intercept:", Intercept))
# print(paste("Slope:", Slope))


# Print the summary of the model
model.s_summary <- summary(model.s)
cat("Multiple R^2:", round(summary(model.s)$r.squared, 3), "\n")
# # Extract the R^2 value
# r_squared <- round(model.s_summary$r.squared, 3)   # <- old code
# print(paste("Multiple R^2:", r_squared))
# [1] "Multiple R^2: 0.442"
```

 - y = sage scrub cover
```{r, eval = FALSE}
# original plot
ggplot(data = cover_byleaftype_wide %>%  
         filter(shrub_native_nonsclero > 0.01) %>% 
         filter(site == "1" | site == "2")
         , 
       aes(x = grass_nonnative_NA*100, 
         y = shrub_native_nonsclero*100)) + 
      geom_point(aes(color = site), size = 3) +
   scale_color_manual(values = c("blue", "blue", "maroon", "maroon", "maroon", "maroon", "maroon")) +
  # geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
   stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +  # polynomial fit
  labs(
    x = "Non-native grass cover (%)",
    y = "Non-scl shrub cover (%)",
    title = "Linear regression of  non-scl shrub cover by non-native grass cover"
    ) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  theme_bw()

# Fit the linear model
model.s <- lm(shrub_native_nonsclero ~ grass_nonnative_NA, # response variable ~ independent variable
              data = cover_byleaftype_wide %>% 
                filter(shrub_native_nonsclero > 0.01) %>% 
                filter(site == "1" | site == "2")
              )

# Print the summary of the model
model.s_summary <- summary(model.s)

# Extract the R^2 value
r_squared <- round(model.s_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squared))
# [1] "Multiple R^2: 0.327" <-- all sites
# [1] "Multiple R^2: 0.684" <-- sites 1 and 2


##############################################
# plot made August 1, 2025
######### sage scrub slope
# Create the label for the equation and R^2
eq_label_ss2 <- paste0("y = ", slopess, "x + ", interceptss, "\n", "R² = ", r_squaredss)


nngxss <- 
  ggplot(data = cover_byleaftype_wide,
       aes(x = grass_nonnative_NA*100, 
         y = shrub_native_nonsclero*100)) + 
      geom_point(aes(color = site, shape = site), size = 3) +
 
  # Custom Shapes and Colors for Legend
  scale_color_manual(values = c("blue", "green", "maroon", "maroon", "maroon", "maroon", "maroon")) +
  scale_shape_manual(values = c(16, 16, 8, 8, 8, 8, 8)) +  # Square = 15, Circle = 16, 8 = *
  
  # regression line
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval 
  
  # labels
  labs(
    x = "Non-native grass cover (%)",
    y = "Non-scl shrub cover (%)"#,
    #title = "Linear regression of  non-scl shrub cover by non-native grass cover"
    ) +
  
  # axes breaks
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  
  theme_bw() +

  # Annotations for Equation Labels
  annotate("text", x = 70, y = 90, label = eq_label_ss2, color = "gray30", size = 4, hjust = 0) +
  geom_abline(intercept = 100, slope = -1, color = "darkgray", linetype = "dashed")
 


nngxss
```

 - y = total forb cover
```{r regression forb x grass}
############ non-native slope
# Fit the linear model
model.nnf <- lm(forb_nonnative ~ grass_nonnative, data = cover_bylfstatus_wide) # response variable ~ independent variable

# Print the summary of the model
model.nnf_summary <- summary(model.nnf)
# Extract the intercept, slope, and R^2 values
interceptnnf <- round(coef(model.nnf)[1], 2)
slopennf <- round(coef(model.nnf)[2], 2)
r_squarednnf <- round(model.nnf_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squarednnf))
# [1] "Multiple R^2: 0.097"
# Create the label for the equation and R^2
eq_label_nnf <- paste0("Non-native forb: y = ", slopennf, "x + ", interceptnnf, "\n", "R² = ", r_squarednnf)


######### native forb slope
# Fit the linear model
model.nf <- lm(forb_native ~ grass_nonnative, data = cover_bylfstatus_wide) # response variable ~ independent variable
model.nf_summary <- summary(model.nf)
# Extract the intercept, slope, and R^2 values
interceptnf <- round(coef(model.nf)[1], 2)
slopenf <- round(coef(model.nf)[2], 2)
r_squarednf <- round(model.nf_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squarednf))
# [1] "Multiple R^2: 0.01"
# Create the label for the equation and R^2
eq_label_nf <- paste0("Native forb: y = ", slopenf, "x + ", interceptnf, "\n", "R² = ", r_squarednf)

fig.1c <- ggplot(data = cover_bylfstatus_wide) + #%>%  filter(forb_native > 0.01 | forb_nonnative > 0.01 | forb_unknown > 0.01)) +
  geom_point(aes(x = grass_nonnative * 100, y = forb_native * 100, color = "forb_native"), 
             shape = 1, size = 3, show.legend = FALSE) +
  geom_smooth(aes(x = grass_nonnative * 100, y = forb_native * 100, color = "forb_native"), 
              method = "lm", se = TRUE, linetype = "dashed", show.legend = FALSE) +
  geom_point(aes(x = grass_nonnative * 100, y = forb_nonnative * 100, color = "forb_nonnative"),  
             shape = 16, size = 3, , show.legend = FALSE) +
  geom_smooth(aes(x = grass_nonnative * 100, y = forb_nonnative * 100, color = "forb_nonnative"), 
              method = "lm", se = TRUE, linetype = "solid", show.legend = FALSE) +
  labs(
     # title = "Comparison of native and non-native forb percent cover by Nonnative Grass percent cover",
      color = "Status",
    x = "Non-native grass cvoer (%)",
    y = "Forb cover (%)"
    ) +
  scale_color_manual(values = c("forb_native" = "black", "forb_nonnative" = "black"),
                     labels = c("Native ", "Non-native")) +
  xlim(0, 100) +
  ylim(0, 100) +
  theme_bw() +
  annotate("text", x = 0, y = 90, label = eq_label_nnf, color = "black", size = 4, hjust = 0) +
  annotate("text", x = 0, y = 75, label = eq_label_nf, color = "black", size = 4, hjust = 0)

fig.1c

```

##### - y = native forb cover
```{r native forb cover x nn grass cover}


# Fit the linear model
model.f <- lm(forb_native ~ grass_nonnative, data = cover_bylfstatus_wide) # linear equation 
coef(model.f) # model coeficients
# equation
equ_f <- print(paste0("y = ", round(coef(model.f)[1], 2), " + ", round(coef(model.f)[2], 2), "x"))

# r squared value
summary(model.f) 
r_forb <- print(paste0("R² = ", round(summary(model.f)$r.squared, 2)))

# Create the label for the equation and R^2
label_f <- paste0(equ_f,  "\n", 
                  r_forb)

# native forb cover x nn grass cover
nngxnatforb <- ggplot(data = cover_bylfstatus_wide,
       aes(x = grass_nonnative*100, 
         y = forb_native*100)) + 
  
      geom_point(aes(color = cluster), size = 3, show.legend = FALSE) +
   scale_color_manual(values = colors_plantclusters) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
   # stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +  # polynomial fit
  labs(
    x = "Non-native grass cover (%)",
    y = "Native forb cover (%)" 
    ) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)
                     # , expand = expansion(mult = c(0, 0.05))
                     ) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 20)
                     # , expand = expansion(mult = c(0, 0.05))
                     ) + # Set y-axis limits and breaks
  theme_bw() + 
    
  theme(axis.text = element_text(size = 16)) + # axes numbers - font size
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 16)) + 
  theme(legend.text=element_text(size = 16))+
  annotate("text", x = 0, y = 90, label = label_f, color = "black", size = 6, hjust = 0)

nngxnatforb
```

```{r}
####################

df <- cover_bylfstatus_wide


# 1. Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(df$grass_nonnative, 
         df$forb_native)
cor(df$grass_nonnative, 
         df$forb_native)


# 2. Linear regression
lm(forb_native ~ grass_nonnative, data = df) 

# 3. Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(forb_native ~ poly(grass_nonnative, 2), data = df)
summary(model_poly)

# 4. Generalized Additive Models (GAMs) - If you don’t want to assume the shape (e.g., parabola), GAMs let the data “decide” the curve:
model_gam <- gam(forb_native ~ s(grass_nonnative), data = df)
summary(model_gam)
plot(model_gam)

# 5. Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_lin <- lm(forb_native ~ grass_nonnative, data = df) #linear regression (same as above)
model_seg <- segmented(model_lin, seg.Z = ~ grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg)
plot(model_seg) 


# 6. Quantile Regression - Sometimes the average trend isn’t the full story — for example, shrubs may persist under moderate grass cover only in the “best-case” sites. Quantile regression shows how the relationship differs across the distribution of shrub cover.
model_qr <- rq(forb_native ~ grass_nonnative, tau = 0.9, data = df)
summary(model_qr)



### MODEL COMPARISON
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AICforb <- (AIC(model_lin, model_poly, model_gam, model_seg)) 
# Lower/more negative AIC = better fit.

```

##### - y = native grass

```{r}

# Fit the linear model
model.g <- lm(grass_native ~ grass_nonnative, data = cover_bylfstatus_wide) # linear equation 
coef(model.g) # model coeficients
# equation
equ_g <- print(paste0("y = ", round(coef(model.g)[1], 2), " + (", round(coef(model.g)[2], 2), ")x"))

# r squared value
summary(model.g) 
r_grass <- print(paste0("R² = ", round(summary(model.g)$r.squared, 2)))

# Create the label for the equation and R^2
label_g <- paste0(equ_g,  "\n", 
                  "R² = 0.50")




# native grass cover x nn grass cover
nngxantgrass <- ggplot(data = cover_bylfstatus_wide,
       aes(x = grass_nonnative*100, 
         y = grass_native*100)) + 
  
      geom_point(aes(color = cluster), size = 3, show.legend = TRUE) +
   scale_color_manual(values = colors_plantclusters) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
   # stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +  # polynomial fit - error bars go below 0%
  labs(
    x = "Non-native grass cover (%)",
    y = "Native grass cover (%)",
    color = "Community-type") +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 20)) + # Set y-axis limits and breaks 
  theme_bw() +
      
  theme(axis.text = element_text(size = 16)) + # axes numbers - font size
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 16)) + 
  theme(legend.text=element_text(size = 16))+
  annotate("text", x = 0, y = 90, label = label_g, color = "black", size = 6, hjust = 0) 

nngxantgrass


```



```{r}

#############################

#stats

# 1. Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(cover_bylfstatus_wide$grass_nonnative, 
         cover_bylfstatus_wide$grass_native )

# 2. Linear regression
model_lm <- lm(grass_native ~ grass_nonnative, data = cover_bylfstatus_wide) 

# 3. Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(grass_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide)
summary(model_poly)

# 4. Generalized Additive Models (GAMs) - If you don’t want to assume the shape (e.g., parabola), GAMs let the data “decide” the curve:
model_gam <- gam(grass_native ~ s(grass_nonnative), data = cover_bylfstatus_wide)
summary(model_gam)
plot(model_gam)

# 5. Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_seg <- segmented(lm(grass_native ~ grass_nonnative, data = cover_bylfstatus_wide) , seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg)
plot(model_seg)


### MODEL COMPARISON
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AICgrass <- (AIC(model_lm, model_poly, model_gam, model_seg))
# Lower/more negative AIC = better fit.

# linear model is best fit

###################

# test residuals from linear model
residuals_lm_grass <- residuals(lm(grass_native ~ grass_nonnative, data = cover_bylfstatus_wide))
plot(fitted(model.g) ~ residuals_lm_grass) # does not look random
testDispersion(simulateResiduals(
  lm(grass_native ~ grass_nonnative,
         data = cover_bylfstatus_wide, 
      family=gaussian))) # dispersion = 0.97615, p-value = 1
# Q-Q plot
qqnorm(residuals_lm_grass, main = "Q-Q Plot for Linear Model Residuals - nativegrass")
qqline(residuals_lm_grass, col = "red")
model_lm_g_res<- simulateResiduals(model.g) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_lm_g_res) # 1


# Extract residuals from the poly model
residuals_poly_g <- residuals(
  lm(grass_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide)
  )
plot(fitted(model.g) ~ residuals_poly_g) # does not look random
testDispersion(simulateResiduals(
  lm(grass_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide),
  
      family=gaussian)) # dispersion = 0.95046, p-value = 0.912
# Q-Q plot
qqnorm(residuals_poly_g, main = "Q-Q Plot for Polynomial Model Residuals - nativegrass")
qqline(residuals_poly_g, col = "red")
model_poly_g_res<- simulateResiduals(
  lm(grass_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide)
) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_poly_g_res) # significan diviation



# Extract residuals from the segmented model
residuals_segmented_g <- residuals(
  segmented( lm(grass_native ~ grass_nonnative, data = cover_bylfstatus_wide)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1)
)



# test residuals from poly model
residuals_poly_grass <- residuals(lm(grass_native ~ grass_nonnative, data = cover_bylfstatus_wide))
plot(fitted(model.g) ~ resid(model.g)) # does not look random
# Extract residuals from the poly model
residuals_poly_g <- residuals(
  lm(grass_native ~ poly(grass_nonnative, 2), data = cover_bylfstatus_wide)
  )
# Extract residuals from the segmented model
residuals_segmented_g <- residuals(
  segmented( lm(grass_native ~ grass_nonnative, data = cover_bylfstatus_wide)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1)
)
# Plot the Q-Q plot for the linear model residuals
qqnorm(residuals_lm_grass, main = "Q-Q Plot for Linear Model Residuals - nativegrass")
qqline(residuals_lm_grass, col = "red")


```


```{r regression grass x grass}

###  original (aka. old) figure

# Fit the linear model
model.g <- lm(grass_native ~ grass_nonnative, data = cover_bylfstatus_wide %>%  filter(grass_native >0)) # response variable ~ independent variable
model.g_summary <- summary(model.g)
# Extract the intercept, slope, and R^2 values
interceptg <- round(coef(model.g)[1], 2)
slopeg <- round(coef(model.g)[2], 2)
r_squaredg <- round(model.g_summary$r.squared, 3)
print(paste("Multiple R^2:", r_squaredg))
# [1] "Multiple R^2: 0.497"
# Create the label for the equation and R^2
eq_label_g <- paste0("Native grass: y = ", slopeg, "x + ", interceptg, "\n", "R² = ", r_squaredg)


fig.1e <- ggplot(data = cover_bylfstatus_wide 
                 # %>%   filter(grass_native >0)
                 )  +
  geom_point(aes(x = grass_nonnative * 100, y = grass_native * 100, color = "grass_native"), 
             size = 3, shape = 1, show.legend = FALSE) +
  geom_smooth(aes(x = grass_nonnative * 100, y = grass_native * 100, color = "grass_native"), 
              method = "lm", se = TRUE, linetype = "dashed", show.legend = FALSE) +
  labs(
    x = "Non-native grass cover (%)",
    y = "Native grass cover (%)",
    #title = "Comparison of Native grass percent cover by Nonnative Grass percent cover",
    color = "Legend"
    ) +
  scale_color_manual(values = c("grass_native" = "black"),
                     labels = c("Native ", "Non-native")) +
  xlim(0, 100) +
  ylim(0, 100) +
  theme_bw() + 
 annotate("text", x = 0, y = 90, label = eq_label_g, color = "black", size = 4, hjust = 0) 
 
#14 transecrs have native grass present - mostly at Site 1 and at INT transects
#cover_bylfstatus_wide %>% filter(grass_native > 0) %>% group_by(site_rep, year) %>%  summarize(native_grass = grass_native)

fig.1e

```


##### - y = native herbaceous cover
```{r}

# the polynomial is the best fit regression
# Fit the poly model
model.h <- lm(herb_native ~ grass_nonnative + I(grass_nonnative^2), data = herb_cover_wide) # poly equation 
coef(model.h) # model coeficients
equ_h <- print(paste0("y = ", round(coef(model.h)[1], 2), " + (", round(coef(model.h)[2], 2), ")x + (", round(coef(model.h)[3], 2), ")x²"))

summary(model.h) 
r_herb <- print(paste0("R² = ", round(summary(model.h)$r.squared, 2)))
# Create the label for the equation and R^2


label_h <- paste0(equ_h,  "\n", 
                  r_herb)

nngxnatherb <- ggplot(data = herb_cover_wide,
       aes(x = grass_nonnative*100, 
         y = herb_native*100)) + 
  
      geom_point(aes(color = cluster), size = 3, show.legend = FALSE) +
   scale_color_manual(values = colors_plantclusters) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
   # stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +  # polynomial fit
  labs(
    # title = "Native forb cover by non-native grass cover",
    x = "Non-native grass cover (%)",
    y = "Native herbaceous cover (%)" , 
    color = "Plant cluster"
    ) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)
                     # , expand = expansion(mult = c(0, 0.05))
                     ) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)
                     # , expand = expansion(mult = c(0, 0.05))
                     ) + # Set y-axis limits and breaks
  theme_bw() + 
    
  theme(axis.text = element_text(size = 16)) + # axes numbers - font size
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 16)) + 
  theme(legend.text=element_text(size = 16)) +
   annotate("text", x = 0, y = 90, label = label_h, color = "black", size = 6, hjust = 0) 

nngxnatherb
```

```{r}
# herb segmented model
model_seg_herb <- segmented(
  lm(herb_native ~ grass_nonnative, data = herb_cover_wide)
  , seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg_herb)
# Estimated Break-Point(s):
#                        Est. St.Err
# psi1.grass_nonnative 0.341  0.182
# 
# Coefficients of the linear terms:
#                    Estimate Std. Error t value Pr(>|t|)    
# (Intercept)          0.5046     0.1001   5.042 1.32e-05 ***
# grass_nonnative     -0.9073     0.5341  -1.699    0.098 .  
# U1.grass_nonnative   0.7060     0.5511   1.281       NA    

plot(model_seg_herb)
# break point = 34.1%
# slope <34.1% = -0.9073; p < 0.001
# slope >34.1% = -0.2013; p = 0.098


# Plot the segmented regression model and increase text sizes
plot(segmented(
  lm(herb_native ~ grass_nonnative, data = herb_cover_wide)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1), 
     conf.level = 0.95, 
     shade = TRUE,
     # main = "Segmented Regression with Confidence Interval",
     xlab = "Non-Native Grass Cover (%)", 
     ylab = "Native Herbaceous Cover (%)",
     cex.main = 1.5,   # Increase the main title size
     cex.lab = 1.3,    # Increase the axis labels size
     cex.axis = 1.2)   # Increase the axis numbers size

# Add the original data points, increasing their size as well
points(herb_cover_wide$grass_nonnative, 
       herb_cover_wide$herb_native,
       col = colors_plantclusters,
       pch = 16,
       cex = 1.5)      # Increase the size of the data points

```

The "best" regression for native herb cover is: poly
(really they're all the same - all AICs are within 2 of each other)
```{r}

# sand box

df = herb_cover_wide

# Types of regression lines:
# Correlations
# Polynomial regression = test for simple curvature.
# GAMs = flexible non-linear trend.
# Piecewise regression = detect thresholds or breakpoints.
# Quantile regression = test upper/lower bounds of the relationship.



# 1. Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(herb_cover_wide$grass_nonnative, 
         herb_cover_wide$herb_native)
# p-value = 6.78e-05
# cor = -0.5872979 

# 2. Linear regression
model_herb_lin <- lm(herb_native ~ grass_nonnative, data = herb_cover_wide) 

# 3. Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(herb_native ~ poly(grass_nonnative, 2), data = herb_cover_wide)
summary(model_poly)


# 5. Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_lin <- lm(herb_native ~ grass_nonnative, data = herb_cover_wide) #linear regression (same as above)
model_seg <- segmented(model_lin, seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg)
plot(model_seg)




### MODEL COMPARISON
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AIC_herb <- (AIC(model_herb_lin, model_poly, model_gam, model_seg))
# Lower/more negative AIC = better fit.




#### checking residuals

model <- lm(herb_native ~ poly(grass_nonnative, 2), data = herb_cover_wide)

residuals(lm(herb_native ~ poly(grass_nonnative, 2), data = herb_cover_wide))

plot(fitted(model) ~ resid(model))

ggqqplot(herb_cover_wide$herb_native)
testDispersion(simulateResiduals(
  glm(herb_native ~ grass_nonnative, 
         data = herb_cover_wide, 
      family=gaussian)
))




#### checking residuals
ggqqplot(herb_cover_wide$herb_native)

# linear
model2 <- lm(herb_native ~ grass_nonnative, data = herb_cover_wide)
residuals(model2) # → raw or standardized differences between observed & fitted values.

plot(fitted(model2) ~ resid(model2))

testDispersion(simulateResiduals(
  lm(herb_native ~ grass_nonnative,
         data = herb_cover_wide, 
      family=gaussian)
))
# Q-Q plot
qqnorm(residuals(model2))
qqline(residuals(model2), col = "red")

model_2res<- simulateResiduals(model2) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_2res)


trial <-  testDispersion(simulateResiduals(
  lm(herb_native ~ grass_nonnative,
         data = herb_cover_wide, 
      family=gaussian)))
dispersion <- trial$statistic
dispersion # 0.9761529

# polynomial
model <- lm(herb_native ~ poly(grass_nonnative, 2), data = herb_cover_wide)
residuals(lm(herb_native ~ poly(grass_nonnative, 2), data = herb_cover_wide))
plot(fitted(model) ~ resid(model))
poly <- testDispersion(simulateResiduals(
  lm(herb_native ~ poly(grass_nonnative, 2),
         data = herb_cover_wide, 
      family=gaussian)
))
poly_disp <- poly$statistic # 0.9504647

# segmented
model3 <- segmented(model2, seg.Z = ~ grass_nonnative,
                       npsi = 1) 
residuals(model3)
plot(fitted(model3) ~ resid(model3))

```

### Figure 1 - cover regressions
```{r}

########### Save the plot with specified size

# Add labels to the plots using cowplot's draw_label() function

# fig.1a_labeled <- ggdraw(fig.1a) + draw_label("A", x = 0.95, y = 0.92, size = 15)  # shrub 
# fig.1c_labeled <- ggdraw(fig.1b) + draw_label("E", x = 0.95, y = 0.92, size = 15)  # nat forb
# fig.1d_labeled <- ggdraw(fig.1d) + draw_label("B", x = 0.95, y = 0.92, size = 15)  # nat grass
# fig.1e_labeled <- ggdraw(fig.1e) + draw_label("D", x = 0.95, y = 0.92, size = 15)  # Add letter "D"
# fig.1f_labeled <- ggdraw(fig.1f) + draw_label("A", x = 0.95, y = 0.92, size = 15)  # Add letter "E"


fig.1a_labeled <- ggdraw(nngxnatshr) + draw_label("A", x = 0.95, y = 0.92, size = 15)  # shrub 
fig.1b_labeled <- ggdraw(nngxantgrass) + draw_label("B", x = 0.95, y = 0.92, size = 15)  
fig.1c_labeled <- ggdraw(nngxnatforb) + draw_label("C", x = 0.95, y = 0.92, size = 15)  
fig.1d_labeled <- ggdraw(nngxnatherb) + draw_label("D", x = 0.95, y = 0.92, size = 15)  

# Combine the plots in a 2x3 layout
figure1 <- plot_grid( fig.1a_labeled,
             fig.1b_labeled,
             fig.1c_labeled,
             fig.1d_labeled,
             nrow = 2, 
             ncol = 2, 
             widths = c(1, 1), # Custom widths for each column
             heights = c(1, 1, 1) # Custom heights for each row
             ) 

## save Figure 1 as a .png
# ggsave(
#   filename = "Ch1_Degradation_figures/figure_1.png",    # Specify the output file name
#   plot = figure1,         # Specify the plot object
#   width = 12,                   # Set width in inches
#   height = 10,                   # Set height in inches
#   dpi = 300                     # Set resolution for high-quality output
# )

```



# GROUND COVER
```{r}
groundcover <- abcover_charateristics_leaftype %>% 
  filter(vertical == "0") %>% 
  dplyr::select(year, site, transect, distance, vertical, species) %>% 
   # mutate(transect = case_when(transect == "1" ~ "01", # oldname ~ newname
   #                       transect == "2" ~ "02",
   #                       transect == "3" ~ "03",
   #                       transect == "4" ~ "04",
   #                       transect == "5" ~ "05",
   #                       transect == "6" ~ "06",
   #                       transect == "7" ~ "07",
   #                       transect == "8" ~ "08",
   #                       transect == "9" ~ "09",
   #                            TRUE ~ transect)) %>%
   mutate(site_rep = paste(site, transect, sep = "_")) %>%
  # mutate(site_rep = case_when(site_rep == "INT1.01" ~ "INT1.1",
  #                             site_rep == "INT2.01" ~ "INT2.1",
  #                             site_rep == "INT3.01" ~ "INT3.1",
  #                             site_rep == "INT4.01" ~ "INT4.1",
  #                             site_rep == "INT5.05" ~ "INT5.1",
  #                             TRUE ~ site_rep)) %>% 
   mutate(site_rep_dist = paste(site_rep, distance, sep = "_")) %>% 
  mutate(species = case_when(
    species == "litter" ~ "native_litter", 
    species == "thatch" ~ "nonnative_thatch", 
    species == "wood" ~ "native_wood", 
    TRUE ~ species
  ))

# length(unique(groundcover$site_rep))   # 40 transects
# sort(unique(groundcover$site_rep))


# groundcover %>% 
#   group_by(site, transect) %>% 
#   summarize(num = length(distance))

sort(unique(groundcover$species))

groundcover_percent <- groundcover %>% 
   group_by(year, site, transect, site_rep, species) %>%
  dplyr::summarize(
    groundtype_count_per_transect = n_distinct(site_rep_dist),
    groundtype_percentcover = n_distinct(site_rep_dist)/41 # <-- calculate percent cover by transect and ground type
    ) %>%  
  ungroup() %>% 
  
  # here I'm pivoting the df wider
   dplyr::select(site, site_rep, species, groundtype_percentcover) %>% 
   pivot_wider(names_from = species, values_from = groundtype_percentcover) %>%
   replace_na(replace = list(bare_ground = 0,  # Replace NA with 0 for each value column
                             native_litter = 0,
                             moss = 0,
                             native_thatch = 0,
                             nonnative_litter = 0,
                             rock = 0,
                             nonnative_thatch = 0,
                             native_wood = 0)) %>% 
  
  # here I'm left joining ground cover types with nngrass cover
  left_join(cover_bylfstatus_wide %>%  # cover_bylfstatus_wide: 1_1
              dplyr::select(site_rep, grass_nonnative, shrub_native), by = "site_rep") %>% 
  
  # here I'm combining columns: e.g., bare ground and rock cover
  mutate(bare_rock = bare_ground + rock, 
        # and native_litter and native_wood
         native_litter_wood = native_litter + native_wood
         ) 
# ground cover types to visualize:
# - bare_rock = bare ground + rock
# - native_litter_wood
# - nonnative_thatch

names(groundcover_percent)
### 2 transects with no bare ground
### 2 transects with no non-native grass thatch


groundcover_percent_cluster <- groundcover_percent %>% 
  left_join(groupsdash, by = "site_rep") %>% 
  mutate(cluster = as.character(cluster)) %>% 
  mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
  mutate(cluster = factor(cluster, levels = c("NNG", "ssG", "ssF", "ssFG", "EVG"))) %>% 
  dplyr::select(site, site_rep, grass_nonnative, nonnative_thatch, bare_rock, native_litter_wood, cluster)
  

######################################## FIGURES

fig_bareground_all <- ggplot(   # <- # code edited from CHATGPT 8.8.2025
  (groundcover_percent %>% 
  select(grass_nonnative, 
         bare_rock, native_litter_wood, nonnative_thatch) %>% # pivot df longer, n = 120 rows
  tidyr::pivot_longer(
    cols = c(bare_rock, native_litter_wood, nonnative_thatch),
    names_to = "cover_type",
    values_to = "cover_value")
  ),
       aes(x = grass_nonnative * 100, # data point esthetics
           y = cover_value * 100,
           color = cover_type)) +
  geom_point(size = 3) +
  
  # LEGEND 
  scale_color_manual( # data ponit colors
    name = "Ground cover type",  # legend title
    values = c(
      bare_rock = "black",     # "grey40" 
      native_litter_wood = "maroon", # "green4"
      nonnative_thatch = "lightblue" # "black"
    ),
    labels = c(
      bare_rock = "bare rock",
      native_litter_wood = "native litter/wood",
      nonnative_thatch = "non-native thatch"
    )
  ) +
  
  # THEME 
  labs(
   x = "Non-native grass cover (%)",
    y = "Ground cover (%)"
  ) +
  scale_x_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_y_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme_bw() +
  theme(
    axis.text = element_text(size = 16),
    axis.title = element_text(size = 20),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 16)
  )

fig_bareground_all

################################## don't run, instead - run the figure above
ggplot(data = groundcover_percent) +
  # bare_rock
  geom_point(data = groundcover_percent, 
            aes(x = grass_nonnative * 100, y = bare_rock*100), 
              color = "grey40", #  bare_rock = "gray40"
              # shape = shape_bare_rock, # shape_bare_rock = 16
              size = 3, 
            show.legend = TRUE) +
 # native_litter_wood
 geom_point(data = groundcover_percent,
           aes(x = grass_nonnative * 100, y = native_litter_wood*100),
               color = "green4", # native_litter_wood = "green4"
               # shape = shape_native_litter_wood),
               size = 3, show.legend = TRUE) +
 # nonnative_thatch
 geom_point(data = groundcover_percent,
           aes(x = grass_nonnative * 100, y = nonnative_thatch*100),
               color = "black", # nonnative_thatch = "black"
               # shape = shape_nonnative_thatch),
               size = 3, show.legend = TRUE) +
 # Labels
  labs(
    color = "Ground Cover Type",
    # shape = "Ground Cover Type",
    x = "Non-native grass cover (%)",
    y = "Ground cover (%)"
  ) +
   scale_x_continuous(
      limits = c(0, 100),
      breaks = seq(0, 100, by = 10),
      expand = expansion(mult = c(0, 0.05))
     ) +
 scale_y_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  # Theme
  theme_bw() +
  theme(axis.text = element_text(size = 16)) + # axes numbers - font size
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 16)) + 
  theme(legend.text=element_text(size = 16))
```


### - x = nn grass cover
- y = bare ground 
```{r}

# best fit regression is: linear regression
# although seg and poly are statistically similar: (AIC_bareground)
#               df       AIC
# model_lm_bg    3 -43.19959 <-- lowest number = "best"
# model_poly_bg  4 -41.74443
# model_seg_bg   5 -43.10927

lm(bare_rock ~ grass_nonnative, groundcover_percent_cluster) 

coef(lm(bare_rock ~ grass_nonnative, groundcover_percent_cluster))
# y = mx + b
b = round(coef(lm(bare_rock ~ grass_nonnative, groundcover_percent_cluster) )[1], 3) # intercept
m = round(coef(lm(bare_rock ~ grass_nonnative, groundcover_percent_cluster) )[2], 3) # slope

equ_bareground <- print(paste0("y = ", 
                               b,
                               " + (", 
                               m, 
                               ")x"))

summary(lm(bare_rock ~ grass_nonnative, groundcover_percent_cluster))
r2_bareground <- print(paste0("R² = ", round(summary(lm(bare_rock ~ grass_nonnative, groundcover_percent_cluster))$r.squared, 2)))

label_bareground <- paste0(equ_bareground,  "\n", 
                  r2_bareground)



# figure: bare_rock
fig_bareground <- 
  ggplot(data = groundcover_percent_cluster %>%
                              mutate(site = ifelse(str_detect(site, "INT"), "3", site)),
                           aes(x = grass_nonnative * 100, y = bare_rock*100)) +
  geom_point(aes(color = cluster),
              shape = 16,
              size = 3,
              # position = position_jitter(width = 0.2, height = 0.1),
            show.legend = TRUE) +
   scale_color_manual(values = colors_plantclusters) +
  
  labs(
    color = "Plant Community-type",
    shape = "Plant Community-type",
    x = "Non-native grass cover (%)",
    y = "Bare ground cover (%)"
  ) +
   scale_x_continuous(
      limits = c(0, 100),
      breaks = seq(0, 100, by = 10),
      expand = expansion(mult = c(0, 0.05))
     ) +
 scale_y_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
   theme_bw() + # theme
  theme(
    # axis 
    axis.text.x = element_text(angle = 0,  # Rotate x-axis labels if needed  
                               hjust = 0.5, # hjust = 0.5 = centered; 1 = right justified
                               size = 16), 
    axis.text.y = element_text(size = 16),       # Increase y-axis text size
    
    axis.title = element_text(size = 20),        # Axis title size
    
    legend.position = "right",
    legend.title = element_text(size = 16),      # Legend title size
    legend.text = element_text(size = 16)      # Legend text size
     
  ) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
  annotate("text", x = 10, y = 90, label = label_bareground, color = "black", size = 4, hjust = 0)
  
label_bareground
fig_bareground



############################ stats

hist(groundcover_percent$bare_rock)
shapiro.test(groundcover_percent$bare_rock) # p-value = 0.002545 <- not normal

cor.test(groundcover_percent$grass_nonnative, 
         groundcover_percent$bare_rock, method = "spearman") 
# Pearson = normally distributed data
# Spearman = non-normal data
# 
# # p-value = 0.05862
# rho = -0.3015608
# rho = This is Spearman’s correlation coefficient. It suggests a weak negative association: as non-native grass cover increases, bare ground tends to decrease slightly.
# meaning --> There is a weak negative correlation (ρ = –0.3015608) between non-native grass cover and bare ground, but the relationship was not statistically significant (p = 0.05862).


# linear regression
model_lm_bg <- lm(bare_rock ~ grass_nonnative, data = groundcover_percent) 
    # (Intercept)  grass_nonnative  
    #      0.2588          -0.1120 

# Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly_bg <- lm(bare_rock ~ poly(grass_nonnative, 2), data = groundcover_percent)
summary(model_poly_bg)
# Coefficients:
#                           Estimate Std. Error t value Pr(>|t|)    
# (Intercept)                0.18598    0.02136   8.706 1.74e-10 ***
# poly(grass_nonnative, 2)1 -0.21629    0.13510  -1.601    0.118    
# poly(grass_nonnative, 2)2 -0.09623    0.13510  -0.712    0.481    
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# Residual standard error: 0.1351 on 37 degrees of freedom
# Multiple R-squared:  0.07663,	Adjusted R-squared:  0.02672 
# F-statistic: 1.535 on 2 and 37 DF,  p-value: 0.2288


# Threshold or Breakpoint Models (Piecewise Regression)
model_seg_bg <- segmented(model_lm_bg, seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg_bg)
plot(model_seg_bg)


### Model Comparison
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AIC_bareground <- (AIC(model_lm_bg, model_poly_bg, model_seg_bg))
# Lower/more negative AIC = better fit.
AIC_bareground
#               df       AIC
# model_lm_bg    3 -43.19959
# model_poly_bg  4 -41.74443
# model_seg_bg   5 -43.10927


#### checking residuals
ggqqplot(groundcover_percent_cluster$bare_rock)

# linear
model_linear_bg <- lm(bare_rock ~ grass_nonnative, data = groundcover_percent_cluster)

residuals(lm(bare_rock ~ grass_nonnative, data = groundcover_percent_cluster)) # → raw or standardized differences between observed & fitted values.

plot(
  fitted(lm(bare_rock ~ grass_nonnative, data = groundcover_percent_cluster)) ~ 
    resid(lm(bare_rock ~ grass_nonnative, data = groundcover_percent_cluster))) # looks random

testDispersion(simulateResiduals( # linear
  lm(bare_rock ~ grass_nonnative,
         data = groundcover_percent_cluster, 
      family=gaussian))) # p = 1, dispersion = 0.97615

# Q-Q plot
# qqnorm(residuals(lm(bare_rock ~ grass_nonnative, data = groundcover_percent_cluster)))
# qqline(residuals(lm(bare_rock ~ grass_nonnative, data = groundcover_percent_cluster), col = "red"))
model_linear_bg_resid <- simulateResiduals(lm(bare_rock ~ grass_nonnative, data = groundcover_percent_cluster)) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_linear_bg_resid) # 1


# segmented
model_seg_bg <- segmented(
  model_linear_bg
  , seg.Z = ~ grass_nonnative,
                       npsi = 1) 
residuals(model_seg_bg)
plot(fitted(model_seg_bg) ~ resid(model_seg_bg))



```

- y = thatch cover
```{r}

# the best fit regression is a : linear model


lm(nonnative_thatch ~ grass_nonnative, groundcover_percent_cluster) 

coef(lm(nonnative_thatch ~ grass_nonnative, groundcover_percent_cluster))
# y = mx + b
b = round(coef(lm(nonnative_thatch ~ grass_nonnative, groundcover_percent_cluster) )[1], 3) # intercept
m = round(coef(lm(nonnative_thatch ~ grass_nonnative, groundcover_percent_cluster) )[2], 3) # slope

equ_thatch <- print(paste0("y = ", 
                               b,
                               " + ", 
                               m, 
                               "x"))

summary(lm(nonnative_thatch ~ grass_nonnative, groundcover_percent_cluster))
r2_thatch <- print(paste0("R² = ", round(summary(lm(nonnative_thatch ~ grass_nonnative, groundcover_percent_cluster))$r.squared, 2)))

label_thatch <- paste0(equ_thatch,  "\n", 
                  "R² = 0.80")





# figure: thatch
fig_thatch <- 
     ggplot(data = groundcover_percent_cluster %>%
                              mutate(site = ifelse(str_detect(site, "INT"), "3", site)),
                           aes(x = grass_nonnative * 100, y = nonnative_thatch*100)) +
  geom_point(aes(color = cluster),
              shape = 16,
              size = 3,
              # position = position_jitter(width = 0.2, height = 0.1),
            show.legend = TRUE) +
   scale_color_manual(values = colors_plantclusters) + # transects with no non-native thatch: INT5, 1_7

  labs(
    color = "Plant Community-type",
    shape = "Plant Community-type",
    x = "Non-native grass cover (%)",
    y = "Non-native thatch (%)"
  ) +
   scale_x_continuous(
      limits = c(0, 100),
      breaks = seq(0, 100, by = 10),
      expand = expansion(mult = c(0, 0.05))
     ) +
 scale_y_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  # Theme
  theme_bw() +
 theme(
    # axis 
    axis.text.x = element_text(angle = 0,  # Rotate x-axis labels if needed  
                               hjust = 0.5, # hjust = 0.5 = centered; 1 = right justified
                               size = 16), 
    axis.text.y = element_text(size = 16),       # Increase y-axis text size
    
    axis.title = element_text(size = 20),        # Axis title size
    
    legend.position = "right",
    legend.title = element_text(size = 16),      # Legend title size
    legend.text = element_text(size = 16)      # Legend text size
     
  ) +
  geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
  annotate("text", x = 10, y = 90, label = label_thatch, color = "black", size = 4, hjust = 0)

fig_thatch




############################ stats

hist(groundcover_percent_cluster$nonnative_thatch)
shapiro.test(groundcover_percent$nonnative_thatch) # p-value = 0.008226 <- not normal

cor.test(groundcover_percent$grass_nonnative, 
         groundcover_percent$nonnative_thatch, method = "spearman") 
# Pearson = normally distributed data
# Spearman = non-normal data
# 
# # p-value < 0.001 <-- there is a significant correlation
# rho = 0.8634075 <-- there is a positive correlation


# linear regression
model_lm_thatch <- lm(nonnative_thatch ~ grass_nonnative, data = groundcover_percent_cluster) 
#         (Intercept)  grass_nonnative  
#         0.01426          0.85235 

# Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly_thatch <- lm(nonnative_thatch ~ poly(grass_nonnative, 2), data = groundcover_percent_cluster)
summary(model_poly_thatch)
# Coefficients:
#                           Estimate Std. Error t value Pr(>|t|)    
# (Intercept)                0.56829    0.02165  26.249  < 2e-16 ***
# poly(grass_nonnative, 2)1  1.64630    0.13693  12.023 2.41e-14 ***
# poly(grass_nonnative, 2)2  0.01298    0.13693   0.095    0.925    
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# Residual standard error: 0.1369 on 37 degrees of freedom
# Multiple R-squared:  0.7962,	Adjusted R-squared:  0.7852 
# F-statistic: 72.28 on 2 and 37 DF,  p-value: 1.658e-13


# Threshold or Breakpoint Models (Piecewise Regression)
model_seg_thatch <- segmented(model_lm_thatch, seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg_thatch)
plot(model_seg_thatch)



### Model Comparison
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AIC_thatch <- (AIC(model_lm_thatch, model_poly_thatch, model_seg_thatch))
# Lower/more negative AIC = better fit.
AIC_thatch

# -42.65894	+ 40.66866	= -1.99028 difference




#### checking residuals
ggqqplot(groundcover_percent_cluster$nonnative_thatch)

# linear
model_linear_thatch <- lm(nonnative_thatch ~ grass_nonnative, data = groundcover_percent_cluster)

residuals(model_linear_thatch) # → raw or standardized differences between observed & fitted values.

plot(fitted(model_linear_thatch) ~ resid(model_linear_thatch)) # looks random

testDispersion(simulateResiduals(model_linear_thatch, # linear
      family=gaussian)) # p = 1, dispersion = 0.97615

# Q-Q plot
model_linear_thatch_resid <- simulateResiduals(lm(nonnative_thatch ~ grass_nonnative, data = groundcover_percent_cluster)) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_linear_thatch_resid) # 1


```

- y = native litter
```{r}
# the best fit regression is a : linear regression
# although poly and seg models are < 2 AIC from lm()



lm(native_litter_wood ~ grass_nonnative, groundcover_percent_cluster) 

coef(lm(native_litter_wood ~ grass_nonnative, groundcover_percent_cluster))
# y = mx + b
b = round(coef(lm(native_litter_wood ~ grass_nonnative, groundcover_percent_cluster) )[1], 3) # intercept
m = round(coef(lm(native_litter_wood ~ grass_nonnative, groundcover_percent_cluster) )[2], 3) # slope

equ_litter <- print(paste0("y = ", 
                               b,
                               " + (", 
                               m, 
                               ")x"))

summary(lm(native_litter_wood ~ grass_nonnative, groundcover_percent_cluster))
r2_litter <- print(paste0("R² = ", round(summary(lm(native_litter_wood ~ grass_nonnative, groundcover_percent_cluster))$r.squared, 2)))

label_litter <- paste0(equ_thatch,  "\n", 
                       r2_litter)



# figure: native_litter_wood
fig_nativelitter <- ggplot(data = groundcover_percent_cluster  %>% 
                              mutate(site = ifelse(str_detect(site, "INT"), "3", site)), 
                           aes(x = grass_nonnative * 100, y = native_litter_wood*100)) +
  geom_point(aes(color = cluster),
              shape = 16,
              size = 3, 
              position = position_jitter(width = 0.2, height = 0.1),
            show.legend = TRUE) +
   scale_color_manual(values = colors_plantclusters) +
 # Labels
  labs(
    color = "Site",
    shape = "Site",
    x = "Non-native grass cover (%)",
    y = "Native litter cover (%)"
  ) +
   scale_x_continuous(
      limits = c(0, 100),
      breaks = seq(0, 100, by = 10),
      expand = expansion(mult = c(0, 0.05))
     ) +
 scale_y_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  # Theme
  theme_bw() +
  theme(
    # axis 
    axis.text.x = element_text(angle = 0,  # Rotate x-axis labels if needed  
                               hjust = 0.5, # hjust = 0.5 = centered; 1 = right justified
                               size = 16), 
    axis.text.y = element_text(size = 16),       # Increase y-axis text size
    
    axis.title = element_text(size = 20),        # Axis title size
    
    legend.position = "right",
    legend.title = element_text(size = 16),      # Legend title size
    legend.text = element_text(size = 16)      # Legend text size
     
  ) +
   geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
  annotate("text", x = 10, y = 10, label = label_litter, color = "black", size = 4, hjust = 0)
  

fig_nativelitter
label_litter





############################ stats

hist(groundcover_percent_cluster$native_litter_wood)
shapiro.test(groundcover_percent$native_litter_wood) # p-value < 0.001 <- not normal

cor.test(groundcover_percent$grass_nonnative, 
         groundcover_percent$native_litter_wood, method = "spearman") 
# Pearson = normally distributed data
# Spearman = non-normal data
# 
# # p-value < 0.001 <-- there is a significant correlation
# rho = -0.8936966  <-- there is a negative correlation


# linear regression
model_lm_litter <- lm(native_litter_wood ~ grass_nonnative, data = groundcover_percent_cluster) 

# Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly_litter <- lm(native_litter_wood ~ poly(grass_nonnative, 2), data = groundcover_percent_cluster)
summary(model_poly_litter)


# Threshold or Breakpoint Models (Piecewise Regression)
model_seg_litter <- segmented(model_lm_litter, seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg_litter)
plot(model_seg_litter)


### Model Comparison
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AIC_litter <- (AIC(model_lm_litter, model_poly_litter, model_seg_litter))
# Lower/more negative AIC = better fit.
AIC_litter

# -44.55619 + 42.91063 = -1.64556 difference
# -44.55619 + 42.67214 = -1.88405 difference




#### checking residuals
ggqqplot(groundcover_percent_cluster$native_litter_wood)

# linear
model_linear_litter <- lm(native_litter_wood ~ grass_nonnative, data = groundcover_percent_cluster)

residuals(model_linear_litter) # → raw or standardized differences between observed & fitted values.

plot(fitted(model_linear_litter) ~ resid(model_linear_litter)) # looks random

testDispersion(simulateResiduals(model_linear_litter, # linear
      family=gaussian)) # p = 1, dispersion = 0.97615

# Q-Q plot
model_linear_litter_resid <- simulateResiduals(lm(native_litter_wood ~ grass_nonnative, data = groundcover_percent_cluster)) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_linear_litter_resid) # 1


```


### - by cluster
```{r}

######### bare ground and rock
hist(groundcover_percent_cluster$bare_rock)
shapiro.test(groundcover_percent_cluster$bare_rock) # <- not normal
kruskal.test(bare_rock ~ cluster, data = groundcover_percent_cluster) # <- not sig

# pairwise_wilcox_test(bare_rock ~ cluster,  # rstatix
#                      data = groundcover_percent_cluster,
#                      p.adjust.method = "bonferroni")

pairwise.wilcox.test(groundcover_percent_cluster$bare_rock, # base R
                     groundcover_percent_cluster$cluster,
                     p.adjust.method = "bonferroni")

# medians
groundcover_percent_cluster %>%
  group_by(cluster) %>%
  summarise(
    median_nativelitter = round((median(bare_rock))*100, 2),
    Q1 = round((quantile(bare_rock, 0.25))*100,2),
    Q3 = round((quantile(bare_rock, 0.75))*100, 2),
    .groups = "drop")
# cluster median_nativelitter    Q1    Q3
#   <chr>                 <dbl> <dbl> <dbl>
# 1 EVG                   29.3  14.6   41.5
# 4 ssFG                  19.5  14.6   22.6
# 3 ssF                   17.1  13.4   25.6
# 5 ssG                   15.8   6.1   28.0
# 2 NNG                    9.76  7.93  11.6

######## native litter and wood
hist(groundcover_percent_cluster$native_litter_wood)
shapiro.test(groundcover_percent_cluster$native_litter_wood) # <- not normal, medians (Q1_Q3) 
kruskal.test(native_litter_wood ~ cluster, data = groundcover_percent_cluster)
pairwise.wilcox.test(groundcover_percent_cluster$native_litter_wood, groundcover_percent_cluster$cluster, 
                     p.adjust.method = "bonferroni")
pairwise_wilcox_test(native_litter_wood ~ cluster,
                     data = groundcover_percent_cluster,
                     p.adjust.method = "bonferroni")
#       group1 group2    n1    n2 statistic        p p.adj p.adj.signif
#  * <chr>              <chr>  <chr>  <int> <int>     <dbl>    <dbl> <dbl> <chr>       
#  1 native_litter_wood EVG    NNG        5    10      50   0.001    0.011 *     
#  4 native_litter_wood EVG    ssG        5    10      49.5 0.003    0.027 *      

       
#  2 native_litter_wood EVG    ssF        5     7      31   0.034    0.341 ns          
#  3 native_litter_wood EVG    ssFG       5     8      23   0.713    1     ns          
     
#  5 native_litter_wood NNG    ssF       10     7       2   0.000799 0.008 **          
#  6 native_litter_wood NNG    ssFG      10     8       0   0.000238 0.002 **          

#  7 native_litter_wood NNG    ssG       10    10      30   0.084    0.835 ns          
#  8 native_litter_wood ssF    ssFG       7     8       5.5 0.011    0.106 ns          
#  9 native_litter_wood ssF    ssG        7    10      46   0.299    1     ns          
# 10 native_litter_wood ssFG   ssG        8    10      79   0.000529 0.005 ** 

# medians
groundcover_percent_cluster %>%
  group_by(cluster) %>%
  summarise(
    median_nativelitter = round((median(native_litter_wood))*100, 2),
    Q1 = round((quantile(native_litter_wood, 0.25))*100,2),
    Q3 = round((quantile(native_litter_wood, 0.75))*100, 2),
    .groups = "drop")
#  cluster median_nativelitter    Q1    Q3
#   <chr>                 <dbl> <dbl> <dbl>
# 1 EVG                   46.3  34.2   78.0
# 2 NNG                    0     0      0  
# 3 ssF                    9.76  7.32  26.8
# 4 ssFG                  46.3  39.0   57.9
# 5 ssG                    6.1   0     19.5


###### non-native thratch
hist(groundcover_percent_cluster$nonnative_thatch)
shapiro.test(groundcover_percent_cluster$nonnative_thatch) # not normal
kruskal.test(native_litter_wood ~ cluster, data = groundcover_percent_cluster)
pairwise.wilcox.test(groundcover_percent_cluster$nonnative_thatch, 
                     groundcover_percent_cluster$cluster, 
                     p.adjust.method = "bonferroni")
# EVG    NNG    ssF    ssFG  
# NNG  0.0246 -      -      -     
# ssF  0.0568 0.0922 -      -     
# ssFG 0.4721 0.0058 0.1268 -     
# ssG  0.0267 0.2211 1.0000 0.0115
# 
# P value adjustment method: bonferroni
pairwise_wilcox_test(nonnative_thatch ~ cluster, 
                     data = groundcover_percent_cluster, 
                     p.adjust.method = "bonferroni")

# medians
groundcover_percent_cluster %>%
  group_by(cluster) %>%
  summarise(
    median_nnthatch = round((median(nonnative_thatch))*100, 2),
    Q1 = round((quantile(nonnative_thatch, 0.25))*100,2),
    Q3 = round((quantile(nonnative_thatch, 0.75))*100, 2),
    .groups = "drop")
# cluster median_nnthatch     Q1    Q3
#   <chr>             <dbl> <dbl> <dbl>
# 1 EVG                4.88  2.44  22.0
# 2 NNG               90.2  84.2   90.2
# 3 ssF               73.2  42.7   75.6
# 4 ssFG              29.3  25.6   37.2
# 5 ssG               67.1  63.4   81.7

```


# CLUSTER
### by percent cover
```{r}

# making a figure of mean forb x annual/perennial cover by cluster group

cover_bylifecycle <- abcover_omitground %>% 
  dplyr::select(!c(site_rep, site_rep_dist)) %>% 
  mutate(transect = case_when(transect == "1" ~ "01", # oldname ~ newname
                         transect == "2" ~ "02",
                         transect == "3" ~ "03",
                         transect == "4" ~ "04",
                         transect == "5" ~ "05",
                         transect == "6" ~ "06",
                         transect == "7" ~ "07",
                         transect == "8" ~ "08",
                         transect == "9" ~ "09",
                              TRUE ~ transect)) %>%
  mutate(site_rep = paste(site, transect, sep = ".")) %>%
  mutate(site_rep = case_when(site_rep == "INT1.01" ~ "INT1.1",
                              site_rep == "INT2.01" ~ "INT2.1",
                              site_rep == "INT3.01" ~ "INT3.1",
                              site_rep == "INT4.01" ~ "INT4.1",
                              site_rep == "INT5.05" ~ "INT5.1",
                              TRUE ~ site_rep)) %>% 
  left_join(groups, by = "site_rep") %>% 
  
  mutate(site_rep_dist = paste(site_rep, distance, sep = "_")) %>%
  mutate(lifeform_lifecycle = paste(lifeform, lifecycle, sep = "_")) %>% 
  mutate(lifeform_lifecycle_status = paste(lifeform_lifecycle, status, sep = "_")) %>% 
  
  group_by(year, site, transect, site_rep, lifeform, lifecycle, status, lifeform_lifecycle, lifeform_lifecycle_status, cluster) %>%
  dplyr::summarize(
    lifeform_lifecycle_count_per_transect = n_distinct(site_rep_dist),
    lifeform_lifecycle_percentcover = (n_distinct(site_rep_dist)/41)*100 # <-- calculate percent cover by transect, life form, and life cycle
    ) %>% 
  ungroup() %>% 
  mutate(cluster = factor(cluster, levels = c(5, 4, 2, 3, 1))) %>% 
  mutate(lifeform = factor(lifeform, levels = c("shrub", "forb", "grass", "fern", "forb or vine")))
  # mutate(cluster = case_when(cluster == "1" ~ "NNG",
  #                             cluster == "2" ~ "ssF",
  #                             cluster == "3" ~ "ssG",
  #                             cluster == "4" ~ "ssFG",
  #                             cluster == "5" ~ "EVG",
  #                             TRUE ~ cluster)) %>% 
  # mutate(cluster = factor(cluster, levels = c("NNG", "ssG", "ssF", "ssFG", "EVG")))
  
cover_bylifecycle_bygroup <- cover_bylifecycle %>% 
  group_by(cluster, lifeform, lifecycle, status, lifeform_lifecycle, lifeform_lifecycle_status) %>% 
  filter(lifeform != "fern") %>% # omit fern
  filter(lifeform != "forb or vine") %>% # omit forb or vine
  dplyr::summarise(
    mean_cover = mean(lifeform_lifecycle_percentcover, na.rm = TRUE), 
    n = n_distinct(site_rep), 
    sd = sd(lifeform_lifecycle_percentcover, na.rm = TRUE), 
    se = sd / sqrt(n)
  ) 

############################## figures of lifeform_lifecycle by cluster group

# # Split lifeform_lifecycle into two separate columns: lifeform and lifecycle
# cover_bylifecycle_bygroup <- cover_bylifecycle_bygroup %>%
#   separate(lifeform_lifecycle, into = c("lifeform", "lifecycle"), sep = "_")

############ this is the original ggplot. New ggplot with sig letters coded below - july 22, 2025 SML
############ 
fig_forbgrass_original <- ggplot(cover_bylifecycle_bygroup %>%
         filter(lifeform_lifecycle_status %in% c(
           "forb_annual_native", "forb_annual_nonnative", "forb_perennial_native",
           "grass_annual_nonnative", "grass_perennial_native",
           "shrub_perennial_native")),
       aes(x = cluster,
           y = mean_cover,
           shape = lifecycle,
           color = lifecycle
           )) +
  geom_point(size = 3, position = position_dodge(width = 0.3), show.legend = TRUE) +  # Mean points
  geom_errorbar(aes(ymin = mean_cover - se, ymax = mean_cover + se),
                width = 0.5, position = position_dodge(width = 0.3)) +  # SE bars
  labs(x = "Plant Cluster",
       y = "Mean Percent Cover (%)",
       color = "Lifecycle",  # Label for color legend
        shape = "Lifecycle"
       ) +  # Label for shape legend
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 14),  # Rotate x-axis labels if needed
    # hjust = 0.5 = centered; 1 = right justified
    axis.text.y = element_text(size = 14),       # Increase y-axis text size
    axis.title = element_text(size = 16),        # Axis title size
    strip.text = element_text(size = 16),        # Facet label text size
    legend.text = element_text(size = 14),       # Legend text size
    legend.title = element_text(size = 14),      # Legend title size
    legend.position = "right"
  ) +

  ylim(0, 100) +
  facet_grid(~lifeform * status) +  # Facet by lifeform: facet_wrap
  scale_shape_manual(values = c("annual" = 1, "perennial" = 15)) +
  scale_color_manual(values = c("annual" = "black", "perennial" = "black")) +
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG"))  # Relabel clusters
fig_forbgrass_original


##################### let's try to add sig letters
# EVG = 5
# ssFG = 4
# ssF = 2
# ssG = 3
# NNG = 1

fig_forbgrass_sig_labels <- bind_rows(
  # Shrub native
  data.frame(
  cluster = c("5", "4", "2", "3", "1"),
  lifeform = "shrub",
  status = "native",
  label = c("a", "a", "ab", "bc", "c"),
  y = c(95.4, 82.8, 76.0, 50.3, 34.4)
   #  run this to find y placement --> cover_bylifecycle_bygroup %>% filter(lifeform == "shrub") %>% dplyr::select(mean_cover, se) %>% mutate(max = mean_cover + se + 5)
   ),
  
  # Forb native annual
  data.frame(
    cluster = c("5", "4", "2", "3", "1"),
    lifeform = "forb",
    status = "native",
    label = c("A", "A", "A", "A", "A"),
    y = c(22.2, 34.4, 31.6, 24.3, 15.5)
     #  run this to find y placement --> cover_bylifecycle_bygroup %>% filter(lifeform_lifecycle_status == "forb_annual_native") %>% dplyr::select(mean_cover, se) %>% mutate(max = mean_cover + se + 5)
  ),
    # Forb native perennial
  data.frame(
    cluster = c("5", "4", "2", "3", "1"),
    lifeform = "forb",
    status = "native",
    label = c("a", "a", "a", "a", "a"),
    y = c(17.2, 29.4, 26.6, 19.3, 10.5)
     #  run this to find y placement --> cover_bylifecycle_bygroup %>% filter(lifeform_lifecycle_status == "forb_perennial_native") %>% dplyr::select(mean_cover, se) %>% mutate(max = mean_cover + se + 5)
  ), 
  # Forb non-native annual
 data.frame(
    cluster = c("5", "4", "2", "3", "1"),
    lifeform = "forb",
    status = "nonnative",
    label = c("AB", "B", "A", "B", "AB"),
    y = c(7.44, 24.1, 66.6, 29.9, 55.2)
     #  run this to find y placement --> cover_bylifecycle_bygroup %>% filter(lifeform_lifecycle_status == "forb_annual_nonnative") %>% dplyr::select(mean_cover, se) %>% mutate(max = mean_cover + se + 5)
  ),
  # grass Native perennial
 data.frame(
    cluster = c("5", "4", "2", "3", "1"),
    lifeform = "grass",
    status = "native",
    label = c("b", "ab", "a", "ab", "ab"),
    y = c(65.0, 34.9, 22.2, 7.44, 9.88)
     #  run this to find y placement --> cover_bylifecycle_bygroup %>% filter(lifeform_lifecycle_status == "grass_perennial_native") %>% dplyr::select(mean_cover, se) %>% mutate(max = mean_cover + se + 5)
  ), 
   # grass nonnative annual
 data.frame(
    cluster = c("5", "4", "2", "3", "1"),
    lifeform = "grass",
    status = "nonnative",
    label = c("C", "BC", "B", "A", "A"),
    y = c(37.4, 54.0, 68.6, 91.8, 100)
     #  run this to find y placement --> cover_bylifecycle_bygroup %>% filter(lifeform_lifecycle_status == "grass_annual_nonnative") %>% dplyr::select(mean_cover, se) %>% mutate(max = mean_cover + se + 5)
  )
  ) %>% 
  mutate(lifeform = factor(lifeform, levels = c("shrub", "forb", "grass")))
  

fig_forbgrass <- ggplot(cover_bylifecycle_bygroup %>%
         filter(lifeform_lifecycle_status %in% c(
           "shrub_perennial_native",
           "forb_annual_native", 
           "forb_annual_nonnative", 
           "forb_perennial_native",
           "grass_perennial_native",
           "grass_annual_nonnative"
           )),
       aes(x = cluster, 
           y = mean_cover, 
           shape = lifecycle,   
           color = lifecycle   
           )) +
  geom_point(size = 3, position = position_dodge(width = 0.3), show.legend = TRUE) +  # Mean points
  geom_errorbar(aes(ymin = mean_cover - se, ymax = mean_cover + se), 
                width = 0.5, position = position_dodge(width = 0.3)) +  # SE bars
  geom_text(data = fig_forbgrass_sig_labels,
          aes(x = cluster, y = y, label = label),
          inherit.aes = FALSE,
          size = 5) +
  labs(x = "Plant Cluster", 
       y = "Mean Percent Cover (%)",
       color = "Lifecycle",  # Label for color legend
        shape = "Lifecycle"
       ) +  # Label for shape legend
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 14),  # Rotate x-axis labels if needed
    # hjust = 0.5 = centered; 1 = right justified
    axis.text.y = element_text(size = 14),       # Increase y-axis text size
    axis.title = element_text(size = 16),        # Axis title size
    strip.text = element_text(size = 16),        # Facet label text size
    legend.text = element_text(size = 14),       # Legend text size
    legend.title = element_text(size = 14),      # Legend title size
    legend.position = "right"
  ) +
   
  ylim(0, 100) +
  facet_grid(~lifeform * status) +  # Facet by lifeform: facet_wrap
  scale_shape_manual(values = c("annual" = 1, "perennial" = 15)) +  
  scale_color_manual(values = c("annual" = "black", "perennial" = "black")) +  
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) 

fig_forbgrass
```

```{r, eval = FALSE}
# copied from Ch 2 

# mean non-native grass height by cluster
hist(ch2grassheight$mean_grassheight_cm, 
     main = "Histogram of Non-Native Grass height",
     xlab = "Total Non-Native Grass height",
     col = "lightblue",
     border = "black") 

ggqqplot(ch2grassheight$mean_grassheight_cm)
testDispersion(simulateResiduals(
  glm(mean_grassheight_cm ~ site, 
         data = ch2grassheight, 
      family=gaussian)
)) # dispersion = 0.99897


############# 2017 mean grass height x SITE
aa <- glm(mean_grassheight_cm ~ site, 
         data = ch2grassheight %>% filter(year == "Feb. 2017"), 
                                          family=gaussian)
simulationOutput <- simulateResiduals(a)
testDispersion(simulationOutput)
emmeans(aa, pairwise ~ site, adjust = "tukey")

a <- glm(mean_grassheight_cm ~ site, 
         data = ch2grassheight %>% filter(year == "Jul. 2017"), 
                                          family=gaussian)
simulationOutput <- simulateResiduals(a)
testDispersion(simulationOutput)
emmeans(a, pairwise ~ site, adjust = "tukey")

b <- glm(mean_grassheight_cm ~ site, 
         data = ch2grassheight %>% filter(year == "2018"), 
                                          family=gaussian)
simulationOutput <- simulateResiduals(b)
testDispersion(simulationOutput)
emmeans(b, pairwise ~ site, adjust = "tukey")

c <- glm(mean_grassheight_cm ~ site, 
         data = ch2grassheight %>% filter(year == "2019"), 
                                          family=gaussian)
simulationOutput <- simulateResiduals(c)
testDispersion(simulationOutput)
emmeans(c, pairwise ~ site, adjust = "tukey")
# $emmeans
#  site emmean   SE df lower.CL upper.CL
#  1      50.0 3.01 34     43.9     56.1
#  2      39.8 3.01 34     33.7     45.9
# 
# Confidence level used: 0.95 
# 
# $contrasts
#  contrast      estimate   SE df t.ratio p.value
#  site1 - site2     10.2 4.25 34   2.402  0.0219

```


##### shrub stats 
```{r}
############################## stats among groups

### SHRUB COVER by CLUSTER

hist((cover_bylifecycle %>% filter(lifeform=="shrub"))$lifeform_lifecycle_percentcover)
shapiro.test((cover_bylifecycle %>% filter(lifeform=="shrub"))$lifeform_lifecycle_percentcover)
# data:  shrub_perennial_data$lifeform_lifecycle_percentcover
# W = 0.94181, p-value = 0.06355 <-- normal

aov_shrub <- aov(lifeform_lifecycle_percentcover ~ cluster, data = (cover_bylifecycle %>% filter(lifeform=="shrub")))
summary(aov_shrub)
# Df Sum Sq Mean Sq F value   Pr(>F)    
# cluster      4  14974    3743   14.48 1.08e-06 ***
# Residuals   30   7755     258                     
tukey_result <- TukeyHSD(aov_shrub, conf.level=.95)
# $cluster
#         diff        lwr      upr     p adj
# 3-1 14.54704  -9.588734 38.68281 0.4212663
# 2-1 35.45296  11.317190 59.58873 0.0016217 <- 2, 4, 5 are sig from 1
# 4-1 45.73171  22.414336 69.04908 0.0000312 <- 
# 5-1 58.17073  31.584838 84.75663 0.0000050 <- 
# 2-3 20.90592  -4.021395 45.83324 0.1342625
# 4-3 31.18467   7.048897 55.32044 0.0063246 <- 4 and 5 are sig from 3
# 5-3 43.62369  16.317185 70.93020 0.0005853 <- 
# 4-2 10.27875 -13.857026 34.41452 0.7312299
# 5-2 22.71777  -4.588739 50.02428 0.1394591
# 5-4 12.43902 -14.146869 39.02492 0.6586902
tukey_df <- as.data.frame(tukey_result$cluster)
tukey_df$comparison <- rownames(tukey_df)
# Split the comparison names into separate columns for cluster1 and cluster2
tukey_df <- tukey_df %>% 
  mutate(cluster1 = as.numeric(sub("-.*", "", comparison)),
         cluster2 = as.numeric(sub(".*-", "", comparison)))
# Create a matrix 5 x 5
comparison_matrix <- matrix(NA, nrow = 5, ncol = 5)
rownames(comparison_matrix) <- 1:5  # Cluster numbers
colnames(comparison_matrix) <- 1:5

# Fill the matrix with the adjusted p-values from the Tukey test
for (i in 1:nrow(tukey_df)) {
  comparison_matrix[as.character(tukey_df$cluster1[i]), as.character(tukey_df$cluster2[i])] <- tukey_df$`p adj`[i]
  comparison_matrix[as.character(tukey_df$cluster2[i]), as.character(tukey_df$cluster1[i])] <- tukey_df$`p adj`[i]  # Ensure symmetry
}


# Set diagonal to 1 (self-comparisons are not relevant)
diag(comparison_matrix) <- 1


# Apply multcompLetters to assign significance letters
significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
significance_letters <- significance_letters %>% 
  as.tibble() %>% 
  rownames_to_column("cluster") 

# Now you can add the significance letters to your clusters in the data frame:
shrub_perennial_data <- (cover_bylifecycle %>% filter(lifeform=="shrub")) %>%
  left_join(significance_letters, by = "cluster") %>% 
   mutate(cluster = factor(cluster, levels = c(5, 4, 2, 3, 1)))
# # Recalculate the significance letters after the reordering
# significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
# Apply the significance letters to the reordered clusters
# shrub_perennial_data <- shrub_perennial_data %>%
#   mutate(significance = significance_letters[as.factor(cluster)])

cluster_shrub_boxorjitter <- ggplot(shrub_perennial_data, 
       aes(x = cluster, 
           y = lifeform_lifecycle_percentcover)) +
  geom_boxplot() + # boxplot
  geom_jitter(width = 0.2, height = 0.1, color = "darkgreen") + # jitter
  geom_text(aes(label = value, y = max(lifeform_lifecycle_percentcover) + 5), vjust = 0.5) +
  labs(title = "cluster_shrub_boxorjitter", 
       x = "Plant Cluster", 
       y = "Percent Shrub Cover (%)") +
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +  # Relabel clusters
  theme_bw() 
cluster_shrub_boxorjitter

shrub_cluster <- ggplot(cover_bylifecycle_bygroup %>%
         filter(lifeform_lifecycle %in% c("shrub_perennial")),
       aes(x = cluster,
           y = mean_cover,
           shape = lifeform,   # Shape by lifeform
           color = lifecycle   # Color by lifecycle
           )) +
  geom_point(size = 3, position = position_dodge(width = 0.3)) +  # Mean points
  geom_errorbar(aes(ymin = mean_cover - se, ymax = mean_cover + se),
                width = 0.2, position = position_dodge(width = 0.3)) +  # SE bars
  labs(x = "Plant Cluster",
       y = "Mean Percent Cover (%)",
       color = "Lifecycle",  # Label for color legend
       shape = "Lifeform") +  # Label for shape legend
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1),  # Rotate x-axis labels if needed
    legend.position = "right"
  ) +
  ylim(0, 100) +
 # facet_wrap(~lifeform) +  # Facet by lifeform
  scale_shape_manual(values = c("shrub" = 16)) +
  scale_color_manual(values = c("perennial" = "black")) +
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG"))  # Relabel clusters

cluster_shrub_boxorjitter

shrub_cluster

```

##### forb annual native 
```{r}
############################## stats among groups

### NATIVE ANNUAL FORB COVER by CLUSTER
# sort(unique(cover_bylifecycle$lifeform_lifecycle_status))

forb_annNAT <- cover_bylifecycle %>% 
  filter(lifeform_lifecycle_status=="forb_annual_native")

hist(forb_annNAT$lifeform_lifecycle_percentcover)
shapiro.test(forb_annNAT$lifeform_lifecycle_percentcover)
# data:  forb_annNAT$lifeform_lifecycle_percentcover
# W = 0.67501, p-value = 2.843e-05 <-- not normal

aov_forb_annNAT <- aov(lifeform_lifecycle_percentcover ~ cluster, data = forb_annNAT)
summary(aov_forb_annNAT)
# Df Sum Sq Mean Sq F value             Pr(>F)
# cluster      4  400.5   100.1   0.762  0.567 <-- no diff
# Residuals   14 1839.4   131.4               

tukey_result <- TukeyHSD(aov_forb_annNAT, conf.level=.95)
# Fit: aov(formula = lifeform_lifecycle_percentcover ~ cluster, data = forb_annNAT)
# 
# $cluster
#           diff       lwr      upr     p adj
# 4-5   1.219512 -38.71260 41.15163 0.9999789
# 2-5   4.065041 -37.17667 45.30675 0.9978220
# 3-5  -3.252033 -44.49374 37.98968 0.9990898
# 1-5  -7.621951 -45.50488 30.26098 0.9681628
# 2-4   2.845528 -24.43330 30.12436 0.9972860
# 3-4  -4.471545 -31.75037 22.80728 0.9848795
# 1-4  -8.841463 -30.71318 13.03026 0.7184733
# 3-2  -7.317073 -36.47937 21.84522 0.9317343
# 1-2 -11.686992 -35.86709 12.49310 0.5752434
# 1-3  -4.369919 -28.55001 19.81018 0.9783656
tukey_df <- as.data.frame(tukey_result$cluster)
tukey_df$comparison <- rownames(tukey_df)
# Split the comparison names into separate columns for cluster1 and cluster2
tukey_df <- tukey_df %>% 
  mutate(cluster1 = as.numeric(sub("-.*", "", comparison)),
         cluster2 = as.numeric(sub(".*-", "", comparison)))
# Create a matrix 5 x 5
comparison_matrix <- matrix(NA, nrow = 5, ncol = 5)
rownames(comparison_matrix) <- 1:5  # Cluster numbers
colnames(comparison_matrix) <- 1:5

# Fill the matrix with the adjusted p-values from the Tukey test
for (i in 1:nrow(tukey_df)) {
  comparison_matrix[as.character(tukey_df$cluster1[i]), as.character(tukey_df$cluster2[i])] <- tukey_df$`p adj`[i]
  comparison_matrix[as.character(tukey_df$cluster2[i]), as.character(tukey_df$cluster1[i])] <- tukey_df$`p adj`[i]  # Ensure symmetry
}


# Set diagonal to 1 (self-comparisons are not relevant)
diag(comparison_matrix) <- 1


# Apply multcompLetters to assign significance letters
significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
significance_letters <- significance_letters %>% 
  as.tibble() %>% 
  rownames_to_column("cluster") 

# Now you can add the significance letters to your clusters in the data frame:
forb_annNAT_letters <- forb_annNAT %>%
  left_join(significance_letters, by = "cluster") %>% 
   mutate(cluster = factor(cluster, levels = c(5, 4, 2, 3, 1)))
# # Recalculate the significance letters after the reordering
# significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
# Apply the significance letters to the reordered clusters
# shrub_perennial_data <- shrub_perennial_data %>%
#   mutate(significance = significance_letters[as.factor(cluster)])

cluster_forb_annNAT_boxorjitter <- ggplot(forb_annNAT_letters, 
       aes(x = cluster, 
           y = lifeform_lifecycle_percentcover)) +
  geom_boxplot() + # boxplot
  geom_jitter(width = 0.2, height = 0.1, color = "darkgreen") + # jitter
  geom_text(aes(label = value, y = max(lifeform_lifecycle_percentcover) + 5), vjust = 0.5) +
  labs(title = "cluster_forb_annNAT_boxorjitter", 
       x = "Plant Cluster", 
       y = "Percent Shrub Cover (%)") +
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +  # Relabel clusters
  theme_bw() 

cluster_forb_annNAT_boxorjitter

```


##### native forb perennial
```{r}
############################## stats among groups

### NATIVE PERENNIAL FORB COVER by CLUSTER
# sort(unique(cover_bylifecycle$lifeform_lifecycle_status))

forb_perNAT <- cover_bylifecycle %>% 
  filter(lifeform_lifecycle_status=="forb_perennial_native")

hist(forb_perNAT$lifeform_lifecycle_percentcover)
shapiro.test(forb_perNAT$lifeform_lifecycle_percentcover)
# data:  forb_perNAT$lifeform_lifecycle_percentcover
# W = 0.84967, p-value = 0.00335 <-- not normal

aov_forb_perNAT <- aov(lifeform_lifecycle_percentcover ~ cluster, data = forb_perNAT)
summary(aov_forb_perNAT)
#                Df Sum Sq Mean Sq F value Pr(>F)
# cluster      4  46.35   11.59   0.888  0.492 <-- no diff
# Residuals   17 221.89   13.05 

tukey_result <- TukeyHSD(aov_forb_perNAT, conf.level=.95)
# $cluster
#            diff        lwr      upr     p adj
# 4-5 -2.76422764 -10.791590 5.263135 0.8298085
# 2-5 -0.81300813  -9.208225 7.582208 0.9981842
# 3-5 -2.84552846 -10.617989 4.926932 0.7971495
# 1-5 -4.47154472 -12.866761 3.923672 0.5050290
# 2-4  1.95121951  -5.422384 9.324823 0.9254719
# 3-4 -0.08130081  -6.737238 6.574636 0.9999995
# 1-4 -1.70731707  -9.080920 5.666286 0.9526570
# 3-2 -2.03252033  -9.127773 5.062733 0.9034007
# 1-2 -3.65853659 -11.430997 4.113924 0.6166667
# 1-3 -1.62601626  -8.721269 5.469237 0.9543227

tukey_df <- as.data.frame(tukey_result$cluster)
tukey_df$comparison <- rownames(tukey_df)
# Split the comparison names into separate columns for cluster1 and cluster2
tukey_df <- tukey_df %>% 
  mutate(cluster1 = as.numeric(sub("-.*", "", comparison)),
         cluster2 = as.numeric(sub(".*-", "", comparison)))
# Create a matrix 5 x 5
comparison_matrix <- matrix(NA, nrow = 5, ncol = 5)
rownames(comparison_matrix) <- 1:5  # Cluster numbers
colnames(comparison_matrix) <- 1:5

# Fill the matrix with the adjusted p-values from the Tukey test
for (i in 1:nrow(tukey_df)) {
  comparison_matrix[as.character(tukey_df$cluster1[i]), as.character(tukey_df$cluster2[i])] <- tukey_df$`p adj`[i]
  comparison_matrix[as.character(tukey_df$cluster2[i]), as.character(tukey_df$cluster1[i])] <- tukey_df$`p adj`[i]  # Ensure symmetry
}


# Set diagonal to 1 (self-comparisons are not relevant)
diag(comparison_matrix) <- 1


# Apply multcompLetters to assign significance letters
significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
significance_letters <- significance_letters %>% 
  as.tibble() %>% 
  rownames_to_column("cluster") 

# Now you can add the significance letters to your clusters in the data frame:
forb_perNAT_letters <- forb_perNAT %>%
  left_join(significance_letters, by = "cluster") %>% 
   mutate(cluster = factor(cluster, levels = c(5, 4, 2, 3, 1)))
# # Recalculate the significance letters after the reordering
# significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
# Apply the significance letters to the reordered clusters
# shrub_perennial_data <- shrub_perennial_data %>%
#   mutate(significance = significance_letters[as.factor(cluster)])

cluster_forb_perNAT_boxorjitter <- ggplot(forb_perNAT_letters, 
       aes(x = cluster, 
           y = lifeform_lifecycle_percentcover)) +
  geom_boxplot() + # boxplot
  geom_jitter(width = 0.2, height = 0.1, color = "darkgreen") + # jitter
  geom_text(aes(label = value, y = max(lifeform_lifecycle_percentcover) + 5), vjust = 0.5) +
  labs(title = "forb_perNAT_letters", 
       x = "Plant Cluster", 
       y = "Percent Shrub Cover (%)") +
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +  # Relabel clusters
  theme_bw() 

cluster_forb_perNAT_boxorjitter


```


##### nn forb annual
```{r}
############################## stats among groups

### NONNATIVE ANNUAL FORB COVER by CLUSTER
# sort(unique(cover_bylifecycle$lifeform_lifecycle_status))

forb_annNN <- cover_bylifecycle %>% 
  filter(lifeform_lifecycle_status=="forb_annual_nonnative")

hist(forb_annNN$lifeform_lifecycle_percentcover)
shapiro.test(forb_perNAT$lifeform_lifecycle_percentcover)
# data:  forb_perNAT$lifeform_lifecycle_percentcover
# W = 0.84967, p-value = 0.00335 <-- not normal

aov_forb_annNN <- aov(lifeform_lifecycle_percentcover ~ cluster, data = forb_annNN)
summary(aov_forb_annNN)
#             Df Sum Sq Mean Sq F value  Pr(>F)   
# cluster      4   8390  2097.4   5.683 0.00167 **
# Residuals   29  10703   369.1                   

tukey_result <- TukeyHSD(aov_forb_annNN, conf.level=.95)
# $cluster
#           diff        lwr       upr     p adj
# 4-5  13.937282 -45.762940  73.63750 0.9595139
# 2-5  50.174216  -9.526006 109.87444 0.1324882
# 3-5  16.341463 -42.228684  74.91161 0.9251130
# 1-5  40.650407 -18.214806  99.51562 0.2878351
# 2-4  36.236934   6.386823  66.08704 0.0113931 <--  2 and 4 are diff
# 3-4   2.404181 -25.116261  29.92462 0.9990267
# 1-4  26.713124  -1.429830  54.85608 0.0691610
# 3-2 -33.832753 -61.353195  -6.31231 0.0101841 <-- 2 and 3 are diff
# 1-2  -9.523810 -37.666764  18.61915 0.8604176
# 1-3  24.308943  -1.349808  49.96769 0.0699448

tukey_df <- as.data.frame(tukey_result$cluster)
tukey_df$comparison <- rownames(tukey_df)
# Split the comparison names into separate columns for cluster1 and cluster2
tukey_df <- tukey_df %>% 
  mutate(cluster1 = as.numeric(sub("-.*", "", comparison)),
         cluster2 = as.numeric(sub(".*-", "", comparison)))
# Create a matrix 5 x 5
comparison_matrix <- matrix(NA, nrow = 5, ncol = 5)
rownames(comparison_matrix) <- 1:5  # Cluster numbers
colnames(comparison_matrix) <- 1:5

# Fill the matrix with the adjusted p-values from the Tukey test
for (i in 1:nrow(tukey_df)) {
  comparison_matrix[as.character(tukey_df$cluster1[i]), as.character(tukey_df$cluster2[i])] <- tukey_df$`p adj`[i]
  comparison_matrix[as.character(tukey_df$cluster2[i]), as.character(tukey_df$cluster1[i])] <- tukey_df$`p adj`[i]  # Ensure symmetry
}


# Set diagonal to 1 (self-comparisons are not relevant)
diag(comparison_matrix) <- 1


# Apply multcompLetters to assign significance letters
significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
significance_letters <- significance_letters %>% 
  as.tibble() %>% 
  rownames_to_column("cluster") 

# Now you can add the significance letters to your clusters in the data frame:
forb_annNN_letters <- forb_annNN %>%
  left_join(significance_letters, by = "cluster") %>% 
   mutate(cluster = factor(cluster, levels = c(5, 4, 2, 3, 1)))
# # Recalculate the significance letters after the reordering
# significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
# Apply the significance letters to the reordered clusters
# shrub_perennial_data <- shrub_perennial_data %>%
#   mutate(significance = significance_letters[as.factor(cluster)])

cluster_forb_annNN_boxorjitter <- ggplot(forb_annNN_letters, 
       aes(x = cluster, 
           y = lifeform_lifecycle_percentcover)) +
  geom_boxplot() + # boxplot
  geom_jitter(width = 0.2, height = 0.1, color = "darkgreen") + # jitter
  geom_text(aes(label = value, y = max(lifeform_lifecycle_percentcover) + 5), vjust = 0.5) +
  labs(title = "forb_annNN_letters", 
       x = "Plant Cluster", 
       y = "Percent Shrub Cover (%)") +
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +  # Relabel clusters
  theme_bw() 

cluster_forb_annNN_boxorjitter




```


#####  grass native
```{r}
############################## stats among groups

### GRASS NATIVE COVER by CLUSTER
# sort(unique(cover_bylifecycle$lifeform_lifecycle_status))

grass_perNAT <- cover_bylifecycle %>% 
  filter(lifeform_lifecycle_status=="grass_perennial_native")

hist(grass_perNAT$lifeform_lifecycle_percentcover)
shapiro.test(grass_perNAT$lifeform_lifecycle_percentcover)
# data:  grass_perNAT$lifeform_lifecycle_percentcover
# W = 0.87591, p-value = 0.04124 <-- not normal
aov_grass_perNAT <- aov(lifeform_lifecycle_percentcover ~ cluster, data = grass_perNAT)
summary(aov_grass_perNAT)
#             Df Sum Sq Mean Sq F value Pr(>F)  
# cluster      4   4837  1209.3   5.811 0.0111 *
# Residuals   10   2081   208.1                

tukey_result <- TukeyHSD(aov_grass_perNAT, conf.level=.95)
# $cluster
#           diff        lwr       upr     p adj
# 4-5 -30.487805  -64.05768  3.082074 0.0797737
# 2-5 -40.731707  -72.57889 -8.884524 0.0121566 <--  2 and 5
# 3-5 -50.000000 -103.07864  3.078639 0.0672039
# 1-5 -47.560976 -100.63961  5.517664 0.0848197
# 2-4 -10.243902  -42.09109 21.603281 0.8229154
# 3-4 -19.512195  -72.59083 33.566444 0.7464879
# 1-4 -17.073171  -70.15181 36.005469 0.8229154
# 3-2  -9.268293  -61.27453 42.737940 0.9741014
# 1-2  -6.829268  -58.83550 45.176965 0.9915857
# 1-3   2.439024  -64.70073 69.578783 0.9999450

tukey_df <- as.data.frame(tukey_result$cluster)
tukey_df$comparison <- rownames(tukey_df)
# Split the comparison names into separate columns for cluster1 and cluster2
tukey_df <- tukey_df %>% 
  mutate(cluster1 = as.numeric(sub("-.*", "", comparison)),
         cluster2 = as.numeric(sub(".*-", "", comparison)))
# Create a matrix 5 x 5
comparison_matrix <- matrix(NA, nrow = 5, ncol = 5)
rownames(comparison_matrix) <- 1:5  # Cluster numbers
colnames(comparison_matrix) <- 1:5

# Fill the matrix with the adjusted p-values from the Tukey test
for (i in 1:nrow(tukey_df)) {
  comparison_matrix[as.character(tukey_df$cluster1[i]), as.character(tukey_df$cluster2[i])] <- tukey_df$`p adj`[i]
  comparison_matrix[as.character(tukey_df$cluster2[i]), as.character(tukey_df$cluster1[i])] <- tukey_df$`p adj`[i]  # Ensure symmetry
}


# Set diagonal to 1 (self-comparisons are not relevant)
diag(comparison_matrix) <- 1


# Apply multcompLetters to assign significance letters
significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
significance_letters <- significance_letters %>% 
  as.tibble() %>% 
  rownames_to_column("cluster") 

# Now you can add the significance letters to your clusters in the data frame:
grass_perNAT_letters <- grass_perNAT %>%
  left_join(significance_letters, by = "cluster") %>% 
   mutate(cluster = factor(cluster, levels = c(5, 4, 2, 3, 1)))
# # Recalculate the significance letters after the reordering
# significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
# Apply the significance letters to the reordered clusters
# shrub_perennial_data <- shrub_perennial_data %>%
#   mutate(significance = significance_letters[as.factor(cluster)])

cluster_grass_perNAT_boxorjitter <- ggplot(grass_perNAT_letters, 
       aes(x = cluster, 
           y = lifeform_lifecycle_percentcover)) +
  geom_boxplot() + # boxplot
  geom_jitter(width = 0.2, height = 0.1, color = "darkgreen") + # jitter
  geom_text(aes(label = value, y = max(lifeform_lifecycle_percentcover) + 5), vjust = 0.5) +
  labs(title = "cluster_grass_perNAT_boxorjitter", 
       x = "Plant Cluster", 
       y = "Percent Shrub Cover (%)") +
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +  # Relabel clusters
  theme_bw() 

cluster_grass_perNAT_boxorjitter


```

##### grass nonnative
```{r}
############################## stats among groups

### GRASS NONNATIVE COVER by CLUSTER
# sort(unique(cover_bylifecycle$lifeform_lifecycle_status))

grass_annNN <- cover_bylifecycle %>% 
  filter(lifeform_lifecycle_status=="grass_annual_nonnative")

hist(grass_annNN$lifeform_lifecycle_percentcover)
shapiro.test(grass_annNN$lifeform_lifecycle_percentcover)
# data:  grass_annNN$lifeform_lifecycle_percentcover
# W = 0.90111, p-value = 0.002374 <-- not normal
aov_grass_annNN <- aov(lifeform_lifecycle_percentcover ~ cluster, data = grass_annNN)
summary(aov_grass_annNN)
#             Df Sum Sq Mean Sq F value   Pr(>F)    
# cluster      4  24509    6127   24.61 1.24e-09 ***
# Residuals   34   8463     249              

tukey_result <- TukeyHSD(aov_grass_annNN, conf.level=.95)
# $cluster
#         diff        lwr      upr     p adj
# 4-5 18.90244  -8.918732 46.72361 0.3084854
# 2-5 31.53310   3.057225 60.00898 0.0238752 <-- 
# 3-5 60.00000  33.122195 86.87780 0.0000023 <--
# 1-5 72.43902  45.561220 99.31683 0.0000000 <--
# 2-4 12.63066 -10.882519 36.14384 0.5403999
# 3-4 41.09756  19.547375 62.64775 0.0000371 <--
# 1-4 53.53659  31.986399 75.08677 0.0000003 <--
# 3-2 28.46690   6.077872 50.85593 0.0070654 <--
# 1-2 40.90592  18.516897 63.29495 0.0000735 <--
# 1-3 12.43902  -7.878686 32.75673 0.4109881

tukey_df <- as.data.frame(tukey_result$cluster)
tukey_df$comparison <- rownames(tukey_df)
# Split the comparison names into separate columns for cluster1 and cluster2
tukey_df <- tukey_df %>% 
  mutate(cluster1 = as.numeric(sub("-.*", "", comparison)),
         cluster2 = as.numeric(sub(".*-", "", comparison)))
# Create a matrix 5 x 5
comparison_matrix <- matrix(NA, nrow = 5, ncol = 5)
rownames(comparison_matrix) <- 1:5  # Cluster numbers
colnames(comparison_matrix) <- 1:5

# Fill the matrix with the adjusted p-values from the Tukey test
for (i in 1:nrow(tukey_df)) {
  comparison_matrix[as.character(tukey_df$cluster1[i]), as.character(tukey_df$cluster2[i])] <- tukey_df$`p adj`[i]
  comparison_matrix[as.character(tukey_df$cluster2[i]), as.character(tukey_df$cluster1[i])] <- tukey_df$`p adj`[i]  # Ensure symmetry
}


# Set diagonal to 1 (self-comparisons are not relevant)
diag(comparison_matrix) <- 1


# Apply multcompLetters to assign significance letters
significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
significance_letters <- significance_letters %>% 
  as.tibble() %>% 
  rownames_to_column("cluster") 

# Now you can add the significance letters to your clusters in the data frame:
grass_annNN_letters <- grass_annNN %>%
  left_join(significance_letters, by = "cluster") %>% 
   mutate(cluster = factor(cluster, levels = c(5, 4, 2, 3, 1)))
# # Recalculate the significance letters after the reordering
# significance_letters <- multcompLetters(comparison_matrix, compare = "<", threshold = 0.05)$Letters
# Apply the significance letters to the reordered clusters
# shrub_perennial_data <- shrub_perennial_data %>%
#   mutate(significance = significance_letters[as.factor(cluster)])

cluster_grass_annNN_boxorjitter <- ggplot(grass_annNN_letters, 
       aes(x = cluster, 
           y = lifeform_lifecycle_percentcover)) +
  geom_boxplot() + # boxplot
  geom_jitter(width = 0.2, height = 0.1, color = "darkgreen") + # jitter
  geom_text(aes(label = value, y = max(lifeform_lifecycle_percentcover) + 5), vjust = 0.5) +
  labs(title = "cluster_grass_annNN_boxorjitter", 
       x = "Plant Cluster", 
       y = "Percent Shrub Cover (%)") +
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) +  # Relabel clusters
  theme_bw() 

cluster_grass_annNN_boxorjitter



```



# CANOPY HEIGHT
```{r}
# stand height 
standheight_load <- read_csv("data/deg_maxheight.csv",
                             col_types = cols(
                               year = col_character(),
                               site = col_character(),
                               rep = col_character(),
                               distance = col_double(),
                               species = col_character(),
                               height_cm = col_double()
                               )) 

standheight <- standheight_load %>% 
  dplyr::select('site', 'rep', 'distance', 'species', 'height_cm') %>% 
  # mutate(rep = case_when(rep == "1" ~ "01", # oldname ~ newname
  #                        rep == "2" ~ "02",
  #                        rep == "3" ~ "03",
  #                        rep == "4" ~ "04",
  #                        rep == "5" ~ "05",
  #                        rep == "6" ~ "06",
  #                        rep == "7" ~ "07",
  #                        rep == "8" ~ "08",
  #                        rep == "9" ~ "09",
  #                             TRUE ~ rep)) %>% 
  mutate(site_rep = paste(site, rep, sep = "_")) 

# calculate means, sd, se, and mean percent cover values
standheight_mean <- standheight %>% 
  group_by(site_rep) %>%
  summarize(avgheight_cm = mean(height_cm), # reframe
            n = length((height_cm)),
            sd = sd(height_cm),
            se = ((sd(height_cm))/sqrt(length((height_cm)))), 
            dist_from_mean = abs(avgheight_cm - height_cm),  # absolute distance from the mean, NOT needed to calcuate transect COV
            cov_bytransect = sd/avgheight_cm # COV = SD / mean
            ) 
  
# max(standheight_mean$avgheight_cm)
# min = 46.2 cm
# max = 280.3 cm

cover_prep <- cover_bylfstatus_wide %>% 
  dplyr::select(site, site_rep, forb_nonnative, grass_nonnative, shrub_native, forb_native, grass_native) %>% 
  mutate(site_rep = case_when(site_rep == "INT5_5" ~ "INT5_1", 
                              TRUE ~ site_rep))

height_cover <- groupsdash %>% 
  left_join(standheight_mean, by = "site_rep") %>% 
  left_join(cover_prep, by = "site_rep") %>% 
  mutate(cluster = as.character(cluster)) %>% 
  filter(site_rep != "INT5_5") %>% 
  mutate(grass_nonnative = grass_nonnative *100) %>% 
   mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
  mutate(cluster = factor(cluster, levels = c("NNG", "ssG", "ssF", "ssFG", "EVG"))) %>% 
  dplyr::select(site_rep, cluster, avgheight_cm, cov_bytransect, grass_nonnative) %>% 
  unique()
  
```

### - x = nngrass
```{r}

# the best fit model is a : polynomial model
# although segmented regression is statistically just as good

# polynomial regression
model_poly_height <- lm(avgheight_cm ~ grass_nonnative + I(grass_nonnative^2),
                data = height_cover)

# poly equation 
coef(model_poly_height) # model coeficients
# y = a + b⋅x + c⋅x2
equ_height <- print(paste0("y = ", round(coef(model_poly_height)[1], 2), " + (", round(coef(model_poly_height)[2], 2), ")x + ", round(coef(model_poly_height)[3], 2), "x²"))

summary(model_poly_height) 
# r_squareds <- round(summary(model.s)$r.squared, 2)
r_height <- print(paste0("R² = ", round(summary(model_poly_height)$r.squared, 2)))
# Create the label for the equation and R^2

label_height <- paste0(equ_height,  "\n", 
                  r_height)

# Compute vertex (turning point) of the parabola 
coefs <- coef(model_poly_height)
a <- coefs["(Intercept)"]
b <- coefs["grass_nonnative"]
c <- coefs["I(grass_nonnative^2)"]
x_vertex <- -b / (2 * c)
y_vertex <- a + b * x_vertex + c * x_vertex^2
cat("Vertex at x =", round(x_vertex, 1), "with y =", round(y_vertex, 1), "\n")


#### segmented figure
summary(
  segmented(
  lm(avgheight_cm ~ grass_nonnative, data = height_cover)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1)
  )
# breakpoint = 82.4%
# intercept = 177.65508 cm
# slope < 82.4% = -1.39919; p < 0.001
# slope > 82.4% = 1.78249; p = NA
plot(segmented(
  lm(avgheight_cm ~ grass_nonnative, data = height_cover)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1), 
     conf.level = 0.95, 
     shade = TRUE,
     # main = "Segmented Regression with Confidence Interval",
     xlab = "Non-Native Grass Cover (%)", 
     ylab = "Average canopy height (cm)",
     cex.main = 1.5,   # Increase the main title size
     cex.lab = 1.3,    # Increase the axis labels size
     cex.axis = 1.2,   # Increase the axis numbers size
     ylim = c(0, 300)) 

points(height_cover$grass_nonnative, 
       height_cover$avgheight_cm,
       color = height_cover$cluster,
       col = c("green", "blue", "hotpink", "gray", "orange"),
       pch = 16,
       cex = 1.5)      # Increase the size of the data points




# figure 
fig_height <- ggplot(data = height_cover,
       aes(x = grass_nonnative, y = avgheight_cm)) +
  geom_point(aes(color = cluster), size = 3, show.legend = TRUE
             # , position = position_jitter(width = 0.2, height = 0.1)
             ) +
  scale_color_manual(values = c(colors_plantclusters)) +
 
   scale_x_continuous(
      limits = c(0, 100),
      breaks = seq(0, 100, by = 10),
      expand = expansion(mult = c(0, 0.05))
     ) +
  
   scale_y_continuous(
    limits = c(0, 300),
    breaks = seq(0, 300, by = 50),
    expand = expansion(mult = c(0, 0.05))
  ) +

  labs(
    x = "Non-native grass (%)",
    y = "Average stand height (cm)",
  #  title = "Mean stand height by Nonnative Grass percent cover",
     color = "Plant Community-type") +
 
    # geom_smooth(aes(x = grass_nonnative * 100,
  #                 y = avgheight_cm),
  #             method = "lm", se = TRUE, linetype = "solid", show.legend = TRUE) +
  stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) + # polynomial fit - error bars go below 0%
  theme_bw() + 
   annotate("text", x = 5, y = 20, label = label_height, color = "black", size = 4, hjust = 0) +
  
# To make the font bigger:
  theme(axis.text = element_text(size = 16)) + # axes numbers - font size
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 16)) + 
  theme(legend.text=element_text(size = 16))

fig_height






############################ stats

cor.test(height_cover$grass_nonnative, 
         height_cover$avgheight_cm)

# 2. Linear regression
model_lin <- lm(avgheight_cm ~ grass_nonnative, data = height_cover) 

# 3. Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(avgheight_cm ~ poly(grass_nonnative, 2), data = height_cover)
summary(model_poly)

# 5. Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_seg <- segmented(model_lin, seg.Z = ~ grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg)
plot(model_seg) 



### MODEL COMPARISON
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AIC_height <- (AIC(model_lin, model_poly, model_seg)) # Best models: GAM, segmented
# Lower/more negative AIC = better fit.
AIC_height
#  poly is "best" models



```


### - by cluster
```{r}
# 1 = NNG: n = 10 transects
# 3 = ssG: n = 10 transects
# 2 = ssF: n = 7 transects
# 4 = ssFG: n = 8 transects
# 5 = EVG: n = 5 transects


hist((height_cover %>% 
        dplyr::select(site_rep, avgheight_cm) %>% 
        distinct()
      )$avgheight_cm)
shapiro.test((
  height_cover %>% 
        dplyr::select(site_rep, avgheight_cm) %>% 
        distinct())
  $avgheight_cm)
# W  = 0.82631, p-value = 2.515e-05.  <-- not normally distributed


# Here I am reporting the MEDIAN (Q1-Q3)
cluster_heights <- height_cover %>%
   mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
          mutate(cluster = factor(cluster, levels = c("EVG", "ssFG", "ssF", "ssG", "NNG"))) %>% 
  group_by(cluster) %>%
  summarise(
    median_height_cm = round(median(avgheight_cm)),
    Q1_cm = round(quantile(avgheight_cm, 0.25)),
    Q3_cm = round(quantile(avgheight_cm, 0.75)),
    .groups = "drop") # drops grouping within summarize command; ungroup() removes all groupings within the code being run
#  cluster  median_height    Q1    Q3
#  <fct>           <dbl> <dbl> <dbl>
# 1 EVG               196   146   215
# 3 ssF               121    59   153
# 5 NNG                93    85   105  <-- similar height as ssFG
# 2 ssFG               92    72    99 <-- similar height as NNG
# 4 ssG                65    57    75

# here I am comparing canopy height among clusters
kruskal.test(avgheight_cm ~ cluster, data = height_cover)
# data:  avgheight_cm by cluster
# Kruskal-Wallis chi-squared = 613.59, df = 4, p-value < 2.2e-16 <-- sig

pairwise.wilcox.test(height_cover$avgheight_cm, height_cover$cluster, # PAIRWISE p-values only
                                      p.adjust.method = "bonferroni") # for small number of comparisons
#   1       2       3       4      
# 2 1.4e-11 -       -       -      
# 3 < 2e-16 < 2e-16 -       -      
# 4 0.79    8.1e-07 < 2e-16 -      
# 5 < 2e-16 < 2e-16 < 2e-16 < 2e-16

# NNG and ssFG <- not sig

# significant letters
# fig_clusterheight_siglabels <-  ## ~ line 2268

pairwise_wilcox_test(avgheight_cm ~ cluster, # identifies PAIRS that are significantly different
                     data = height_cover,
                     p.adjust.method = "bonferroni") 


# figure - bar graph
fig_clusterheight_bar <- ggplot(data = cluster_heights,
           aes(x = cluster, 
      y = median_height_cm)) +
  geom_point(size = 3, 
             shape = 15, 
             color = "black", position = position_dodge(width = 0.3), show.legend = TRUE) +  # Mean points
  geom_errorbar(aes(ymax = Q3_cm, 
                    ymin = Q1_cm), 
                width = 0.5, position = position_dodge(width = 0.3)) +  # inner quartile range
  # geom_text(data = fig_clusterheight_siglabels,
  #         aes(x = cluster, y = y, label = label),
  #         inherit.aes = FALSE,
  #         size = 5) +
  labs(x = "Plant Cluster", 
       y = "Median Cluster Height (cm)"
       # color = "Lifecycle",  # Label for color legend
       #  shape = "Lifecycle"
       ) +  # Label for shape legend
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 14),  # Rotate x-axis labels if needed
    # hjust = 0.5 = centered; 1 = right justified
    axis.text.y = element_text(size = 14),       # Increase y-axis text size
    axis.title = element_text(size = 16),        # Axis title size
    strip.text = element_text(size = 16),        # Facet label text size
    legend.text = element_text(size = 14),       # Legend text size
    legend.title = element_text(size = 14),      # Legend title size
    legend.position = "right"
  ) +
   
  
  scale_y_continuous(
    limits = c(0, 300),
    breaks = seq(0, 300, by = 50),
    expand = expansion(mult = c(0, 0.05))
  ) #+

  # facet_grid(~lifeform * status) +  # Facet by lifeform: facet_wrap
  # scale_shape_manual(shape = 15)) +  
  # scale_color_manual(color = "black")) #+  
  # scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG")) 

fig_clusterheight_bar


# figure - scatter plot
fig_clusterheight_scatter <- ggplot(data = height_cover %>% 
                dplyr::select(site_rep, cluster, grass_nonnative, avgheight_cm) %>% 
                   mutate(cluster = factor(cluster, levels = c("EVG", "ssFG", "ssF", "ssG", "NNG"))),
       aes(x = grass_nonnative, y = avgheight_cm)) +
  geom_point(aes(color = cluster), size = 3, show.legend = TRUE) +
  scale_color_manual(values = c("#6C91BD",  "cyan",  "green" , "#AD1F68", 
"#E69512" )) +
   
   scale_x_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 20),
    expand = expansion(mult = c(0, 0.05))
  ) +
  
  scale_y_continuous(
    limits = c(0, 300),
    breaks = seq(0, 300, by = 50),
    expand = expansion(mult = c(0, 0.05))
  ) +
 
  theme(axis.text = element_text(size = 16)) + # axes numbers
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 60)) + 
  theme(legend.text=element_text(size = 16)) +
  labs(
    x = "Non-native grass (%)",
    y = "Transect height (cm)",
     color = "Cluster") +
  theme_bw() 

fig_clusterheight_scatter



```


# COV
```{r}
transect_cov <- standheight_mean %>% 
  dplyr::select(!dist_from_mean) %>% 
  distinct(site_rep, .keep_all = TRUE) %>% 
  left_join(cover_prep, by = "site_rep") %>% 
  left_join(groupsdash) %>% 
mutate(cluster = as.character(cluster)) %>% 
  mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster))  %>% 
   mutate(cluster = factor(cluster, levels = c("NNG", "ssG", "ssF", "ssFG", "EVG")))


```

### x = nn grass
```{r}
# the best fit model is a : segmented model
# the polynomial regression is statistically the same
# AIC_cov
#           df       AIC
# model_lin   3 -30.87340
# model_poly  4 -42.72887
# model_seg   5 -42.76877


# polynomial regression
model_poly_cov <- lm(cov_bytransect ~ grass_nonnative + I(grass_nonnative^2),
                data = transect_cov)

# poly equation 
coef(model_poly_cov) # model coeficients
# y = a + b⋅x + c⋅x2
equ_cov <- print(paste0("y = ", round(coef(model_poly_cov)[1], 2), " + ", round(coef(model_poly_cov)[2], 2), "x + x²"))

summary(model_poly_cov) 
r_cov <- print(paste0("R² = ", round(summary(model_poly_cov)$r.squared, 2)))

label_cov <- paste0(equ_cov,  "\n", 
                  r_cov)

# Compute vertex (turning point) of the parabola 
coefs <- coef(model_poly_cov)
a <- coefs["(Intercept)"]
b <- coefs["grass_nonnative"]
c <- coefs["I(grass_nonnative^2)"]
x_vertex <- -b / (2 * c)
y_vertex <- a + b * x_vertex + c * x_vertex^2
cat("Vertex at x =", round(x_vertex, 1), "with y =", round(y_vertex, 1), "\n")


### segmented regression
cov_seg <- segmented(
  lm(cov_bytransect ~ grass_nonnative, data = transect_cov) 
  , seg.Z = ~ grass_nonnative,
                       npsi = 1) # one breakpoint
plot(cov_seg)
summary(cov_seg)
# breakpoint = 82.927%
# intercept = 0.509189
# slope < 82.927% = 0.001182 (p = 0.285)
# slope > 79.82.92769% = -1.846548 (p = NA)


# Plot the segmented regression model and increase text sizes
plot(segmented(
 lm(cov_bytransect ~ grass_nonnative, data = transect_cov) 
    , seg.Z = ~ grass_nonnative,
                       npsi = 1), 
     conf.level = 0.95, 
     shade = TRUE,
 ylim = c(0,1),
     # main = "Segmented Regression with Confidence Interval",
     xlab = "Non-Native Grass Cover (%)", 
     ylab = "COV of transect (SD/mean height)",
     cex.main = 1.5,   # Increase the main title size
     cex.lab = 1.3,    # Increase the axis labels size
     cex.axis = 1.2)   # Increase the axis numbers size

# Add the original data points, increasing their size as well
points(height_cover$grass_nonnative, 
       height_cover$cov_bytransect,
       col = colors_plantclusters,
       pch = 16,
       cex = 1.5)      # Increase the size of the data points





############################# figure
fig_cov <- ggplot(transect_cov,
       aes(x = grass_nonnative * 100, y = cov_bytransect)) +

  geom_point(aes(color = cluster), size = 3,  show.legend = TRUE) +
   scale_color_manual(values = colors_plantclusters) +
  # geom_point(aes(fill = site), colour = "black", size = 3, pch = 21) +
 # theme(axis.text.x.bottom = element_text(angle = 90)) +

    scale_y_continuous(
    limits = c(0, 1),
    breaks = seq(0, 1, by = 0.2),
    expand = expansion(mult = c(0, 0.05))
  ) +
  
  labs(x = "Non-native grass (%)", 
       y = "COV of transect (SD/mean height)"#, 
       # title = "Distance from mean canopy height (cm) by average non-native cover (%)"
       ) +
  theme_bw() +
  theme(axis.text = element_text(size = 16)) + # axes numbers - font size
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 16)) + 
  theme(legend.text=element_text(size = 16)) +
  
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = .2)) + # Set y-axis limits and breaks
  
  stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +
   annotate("text", x = 10, y = 0.1, label = label_cov, color = "black", size = 4, hjust = 0)

fig_cov





############################ stats

hist(transect_cov$cov_bytransect)
shapiro.test(transect_cov$cov_bytransect) # <- not normal

cor.test(transect_cov$grass_nonnative, 
         transect_cov$cov_bytransect, method = "spearman")
# rho: -0.403853 <-  negative
# p = 0.009757

# 2. Linear regression
model_lin <- lm(cov_bytransect ~ grass_nonnative, data = transect_cov) 

# 3. Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(cov_bytransect ~ poly(grass_nonnative, 2), data = transect_cov)
summary(model_poly)

# 5. Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_seg <- segmented(model_lin, seg.Z = ~ grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg)
plot(model_seg) 



### MODEL COMPARISON
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AIC_cov <- (AIC(model_lin, model_poly, model_seg)) # Best models: GAM, segmented
# Lower/more negative AIC = better fit.
AIC_cov
#  seg is "best" model. Poly is similar.



# Extract residuals from the poly model
residuals_poly_cov <- residuals(
  lm(cov_bytransect ~ poly(grass_nonnative, 2), data = transect_cov)
  )
plot(fitted(model_lin) ~ residuals_poly_cov) #  looks random
testDispersion(simulateResiduals(
  lm(cov_bytransect ~ poly(grass_nonnative, 2), data = transect_cov),
  
      family=gaussian)) # dispersion = 0.95046, p-value = 0.912
# Q-Q plot
qqnorm(residuals_poly_cov, main = "Q-Q Plot for Polynomial Model Residuals - COV")
qqline(residuals_poly_cov, col = "red")
model_poly_cov_res<- simulateResiduals(
  lm(cov_bytransect ~ poly(grass_nonnative, 2), data = transect_cov)
) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_poly_cov_res)



```

### - by cluster
```{r}


boxplot(cov_bytransect ~ cluster,
        data = transect_cov, 
        main = "Basic Boxplot of Data", ylab = "COV")




# Here I am reporting the MEAN and SE of average transect height grouped by plant cluster
cluster_cov <- transect_cov %>%
  group_by(cluster) %>%
  summarise(
    mean_cov = mean(cov_bytransect),
    n = length(cov_bytransect),
    sd = sd(cov_bytransect),
    se = ((sd(cov_bytransect))/sqrt(length((cov_bytransect)))), 
    .groups = "drop") 
#   cluster mean_cov     n     sd     se
#   <chr>      <dbl> <int>  <dbl>  <dbl>
# 1 EVG        0.507     5 0.181  0.0811
# 2 NNG        0.374    10 0.138  0.0435
# 3 ssF        0.587     7 0.0916 0.0346
# 4 ssFG       0.567     8 0.134  0.0473
# 5 ssG        0.532    10 0.180  0.0569
    

str(transect_cov)
hist(transect_cov$cov_bytransect)
shapiro.test(transect_cov$cov_bytransect)
# data:  transect_cov$cov_bytransect
# W = 0.97738, p-value = 0.5932 <-- normal!

aov_cluster <- aov(cov_bytransect ~ cluster, transect_cov)
summary(aov_cluster) # <-- not sig
TukeyHSD(aov_cluster, conf.level=.95)
# $cluster
#            diff          lwr       upr     p adj
# 2-1  0.21307697  0.003088917 0.4230650 0.0453113
# ssF-NNG   0.21307697  0.003088917 0.4230650 0.0453113 <-- the only difference

# 3-1  0.15726672 -0.033294334 0.3478278 0.1469005
# 4-1  0.19307188 -0.009048635 0.3951924 0.0670100
# 5-1  0.13227735 -0.101111325 0.3656660 0.4893033
# 3-2 -0.05581025 -0.265798302 0.1541778 0.9391379
# 4-2 -0.02000509 -0.240536651 0.2005265 0.9989302
# 5-2 -0.08079962 -0.330302607 0.1687034 0.8828690
# 4-3  0.03580516 -0.166315353 0.2379257 0.9858905
# 5-3 -0.02498937 -0.258378043 0.2083993 0.9979520
# 5-4 -0.06079454 -0.303713167 0.1821241 0.9505766

  




```

# shrub DENSITY
- there are 4 transects without shrubs
```{r}

###################### shrub density - native


######## 2019 
shrubdensitylife_load <- read_csv("deg_beltdensity_bylifestage.csv", 
    col_types = cols(
       site = col_character(),
      transect = col_character(), 
      species = col_character(), 
      dead = col_integer(),
      immature = col_integer(),
      mature = col_integer(), 
      resprout = col_integer(), 
      seedling = col_integer()
      )
     ) %>% 
  mutate(transect = ifelse(
    site == "INT2", "1", transect
  )) %>% 
   mutate(transect = ifelse(
    site == "INT3", "1", transect
  )) %>% 
  dplyr::select(-StandType, -hillslope) %>% 
  as_tibble() %>% 
  rename("rep" = "transect") %>% 
  pivot_longer(cols = 4:8, names_to = "lifestage", values_to = "density_80m2") %>% 
  mutate(site_rep = paste(site, rep, sep = "_")) %>% 
   mutate(density_m2 = (density_80m2 / 80)) %>% 
  dplyr::select(-site, -rep, -density_80m2) %>% 
  mutate(lifestage = case_when(lifestage == "resprout" ~ "immature", 
                               TRUE ~ lifestage)) %>% 
   mutate(species = case_when(species == "Cenothus oliganthus" ~ "Ceanothus oliganthus", 
                               TRUE ~ species))


######## 2024   
shrubdensity_2024 <- read_csv("shrubdensity_2024.csv", 
      col_types = cols(
      site = col_character(),
      transect = col_character(), 
      species = col_character(), 
      lifestage = col_character(),
      density_80m2 = col_integer()
      )
      ) %>% 
  dplyr::select(site, transect, species, lifestage, density_80m2) %>% 
  rename("rep" = "transect") %>% 
  mutate(density_m2 = (density_80m2 / 80)) %>% 
 na.omit() %>% 
  mutate(site_rep = paste(site, rep, sep = "_")) %>% 
  dplyr::select(site_rep, species, lifestage, density_m2) %>% 
   mutate(lifestage = case_when(lifestage == "resprout" ~ "immature", 
                               TRUE ~ lifestage))


######################## bind shrub density WITH shrub species WITH leaf type
denspp  <- shrubdensitylife_load  %>%
  bind_rows(shrubdensity_2024)
# length(unique(denspp$site_rep)) # <-- n = 39 transects (INT4 has no density counts)
## denspp : 1_1

denspp_transect <- denspp %>% 
  group_by(site_rep, lifestage) %>% 
  summarize(tot_density_m2 = sum(density_m2)) %>% 
  pivot_wider(names_from = lifestage, values_from = tot_density_m2) %>% # 4 transects without shrubs
  mutate(across(c(seedling, dead, mature, immature), 
                 ~ if_else(site_rep %in% c("1_11", "1_12", "2_11", "2_9"), 0, .))) %>% 
  dplyr::select(-no_shrubs)

denspp_cover <- denspp_transect %>%  
  left_join(height_cover %>%  # left join nn grass cover
  dplyr::select(site_rep, grass_nonnative) %>% 
  unique()) %>%  # 39 transects, missing INT4_1
  left_join(groupsdash, by = "site_rep") %>% 
  na.omit() %>% 
  mutate(cluster = as.character(cluster)) %>% 
   mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
          mutate(cluster = factor(cluster, levels = c("NNG", "ssG", "ssF", "ssFG", "EVG")))
                                   
  
str(denspp_cover)
```

- mature shrub density
```{r}
# linear model is best fit

model.mature <- lm(mature ~ grass_nonnative, data = denspp_cover) # linear equation
coef(model.mature) # model coeficients
equ_mature <- print(paste0(
  "y = ", round(coef(model.mature)[1], 2), " + (", round(coef(model.mature)[2], 2), ")x"))

r_mature <- print(paste0("R² = ", round(summary(model.mature)$r.squared, 2)))
# Create the label for the equation and R^2


label_mature <- paste0(equ_mature,  "\n", 
                  r_mature)


################ mature
fig_den_mature <- ggplot(denspp_cover,
       aes(x = grass_nonnative, y = mature)) +

 geom_point(aes(color = cluster), size = 3, show.legend = TRUE) +
  scale_color_manual(values = c(colors_plantclusters) ) +
  
   scale_x_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_y_continuous(
    limits = c(0, 2),
    breaks = seq(0, 2, by = .25),
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme_bw()  +
  labs(
    x = "Non-native grass (%)",
    y = "Mature shrub density (m²)",
  #  title = "Mean stand height by Nonnative Grass percent cover",
     color = "Plant Community-type") +
 
   # stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +
    geom_smooth(aes(x = grass_nonnative, y = mature), method = "lm", se = TRUE, linetype = "solid", color = "gray40", show.legend = FALSE) +
  
# To make the font bigger:
  theme(axis.text = element_text(size = 16)) + # axes numbers - font size
  theme(axis.title = element_text(size = 20)) + # axes titles
  theme(legend.title=element_text(size = 16)) + 
  theme(legend.text=element_text(size = 16)) +
  annotate("text", x = 60, y = 1.75, label = label_mature, color = "black", size = 4, hjust = 0) 

fig_den_mature

######## stats


#stats

# 1. Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(denspp_cover$grass_nonnative, 
         denspp_cover$mature ) #t = -4.7937, df = 37, p-value = 2.663e-05
#       cor 
# -0.6189732 

# 2. Linear regression
model_lm <- lm(mature ~ grass_nonnative, data = denspp_cover) 

# 3. Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(mature ~ poly(grass_nonnative, 2), data = denspp_cover)
summary(model_poly)

# 4. Generalized Additive Models (GAMs) - If you don’t want to assume the shape (e.g., parabola), GAMs let the data “decide” the curve:
model_gam <- gam(mature ~ s(grass_nonnative), data = denspp_cover)
summary(model_gam)
plot(model_gam)

# 5. Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_seg <- segmented(lm(mature ~ grass_nonnative, data = denspp_cover) , seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg)
plot(model_seg)


### MODEL COMPARISON
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AICmature <- (AIC(model_lm, model_poly, model_gam, model_seg))
# Lower/more negative AIC = better fit.

# linear model is best fit


###################

# test residuals from linear model
residuals_lm_mature <- residuals(lm(mature ~ grass_nonnative, data = denspp_cover))
plot(fitted(model_lm) ~ residuals_lm_mature) # does not look random
testDispersion(simulateResiduals(
  lm(mature ~ grass_nonnative,
         data = denspp_cover, 
      family=gaussian))) # dispersion = 0.97308, p-value = 0.944

# Q-Q plot
qqnorm(residuals_lm_mature, main = "Q-Q Plot for Linear Model Residuals - Mature shrub density")
qqline(residuals_lm_mature, col = "red")
model_lm_res<- simulateResiduals(model_lm) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_lm_res) # 0.944


# Extract residuals from the poly model
residuals_poly_mature <- residuals(
  lm(mature ~ poly(grass_nonnative, 2), data = denspp_cover)
  )
plot(fitted(model_poly) ~ residuals_poly_mature) # looks kinda random
testDispersion(simulateResiduals(
  lm(mature ~ poly(grass_nonnative, 2), data = denspp_cover),
  
      family=gaussian)) # dispersion = 0.94678, p-value = 0.856

# Q-Q plot
qqnorm(residuals_poly_mature, main = "Q-Q Plot for Polynomial Model Residuals - nativegrass")
qqline(residuals_poly_mature, col = "red")
model_poly_mature_res<- simulateResiduals(
  lm(mature ~ poly(grass_nonnative, 2), data = denspp_cover)
) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_poly_mature_res) 


```

- immature shrub density
```{r}
# segmented is the best fit regression



######################################

summary(
  segmented(
  lm(immature ~ grass_nonnative, data = denspp_cover)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1)
  )

# breakpoint = 37.466%
# slope < 0.07% = 0.005377; p =  0.144
# slope > 0.07% = -0.00466; p = NA

# Plot the segmented regression model and increase text sizes
plot(segmented(
  lm(immature ~ grass_nonnative, data = denspp_cover)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1), 
     conf.level = 0.95, 
     shade = TRUE,
     # main = "Segmented Regression with Confidence Interval",
     xlab = "Non-Native Grass Cover (%)", 
     ylab = "Immature shrub density (#/m2)",
     cex.main = 1.5,   # Increase the main title size
     cex.lab = 1.3,    # Increase the axis labels size
     cex.axis = 1.2)   # Increase the axis numbers size

# Add the original data points, increasing their size as well
points(denspp_cover$grass_nonnative, 
       denspp_cover$immature,
       col = colors_plantclusters,
       pch = 16,
       cex = 1.5)      # Increase the size of the data points



# immature
fig_den_immature <- ggplot(denspp_cover,
               aes(x = grass_nonnative, 
           y = immature)) +

 geom_point(aes(color = cluster), size = 3, show.legend = TRUE) +
   scale_color_manual(values = c(colors_plantclusters) ) +
   scale_x_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_y_continuous(
    limits = c(0, 2),
    breaks = seq(0, 2, by = .25),
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme_bw()  +
  labs(
    x = "Non-native grass (%)",
    y = "Immature shrub density (m^2)",
  #  title = "Mean stand height by Nonnative Grass percent cover",
     color = "Cluster") +
 
     stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "red", linewidth = 1) +
    geom_smooth(aes(x = grass_nonnative, y = immature), method = "lm", se = TRUE, linetype = "dashed", color = "gray40", show.legend = TRUE)

fig_den_immature

#######################
#stats

# 1. Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(denspp_cover$grass_nonnative, 
         denspp_cover$immature, method= "spearman") #t = -2.8326, df = 37, p-value = 0.007429
# cor: -0.4221509 

# 2. Linear regression
model_lm <- lm(immature ~ grass_nonnative, data = denspp_cover) 

# 3. Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(immature ~ poly(grass_nonnative, 2), data = denspp_cover)
summary(model_poly)

# 4. Generalized Additive Models (GAMs) - If you don’t want to assume the shape (e.g., parabola), GAMs let the data “decide” the curve:
model_gam <- gam(immature ~ s(grass_nonnative), data = denspp_cover)
summary(model_gam)
plot(model_gam)

# 5. Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_seg <- segmented(lm(immature ~ grass_nonnative, data = denspp_cover) , seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg)
plot(model_seg)


### MODEL COMPARISON
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AICimmmature <- (AIC(model_lm, model_poly, model_gam, model_seg))
# Lower/more negative AIC = better fit.

# linear model is best fit

model_seg

```

- shrub seedling density 
```{r}
# segmented is the best fit regression


summary(
  segmented(
  lm(seedling ~ grass_nonnative, data = denspp_cover)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1)
  )

# breakpoint = 7.317 %
# intercept = 2.8500
# slope < 7.317% = -0.29400; p =  0.000563
# slope > 7.317% = -0.00751; p = NA

# Plot the segmented regression model and increase text sizes
plot(segmented(
  lm(seedling ~ grass_nonnative, data = denspp_cover)
    , seg.Z = ~ grass_nonnative,
                       npsi = 1), 
     conf.level = 0.95, 
     shade = TRUE,
     # main = "Segmented Regression with Confidence Interval",
     xlab = "Non-Native Grass Cover (%)", 
     ylab = "Shrub seedling density (#/m2)",
     cex.main = 1.5,   # Increase the main title size
     cex.lab = 1.3,    # Increase the axis labels size
     cex.axis = 1.2)   # Increase the axis numbers size

# Add the original data points, increasing their size as well
points(denspp_cover$grass_nonnative, 
       denspp_cover$seedling,
       col = colors_plantclusters,
       pch = 16,
       cex = 1.5)      # Increase the size of the data points



# seedlings
fig_den_seedling <- ggplot(denspp_cover, 
       aes(x = grass_nonnative, 
           y = seedling)) +

 geom_point(aes(color = cluster), size = 3, show.legend = TRUE) +
    scale_color_manual(values = c(colors_plantclusters) ) +
   scale_x_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_y_continuous(
    limits = c(0, 3),
    breaks = seq(0, 3, by = .25),
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme_bw()  +
  labs(
    x = "Non-native grass (%)",
    y = "Shrub seedling density (m^2)",
     color = "Cluster") +
 
      stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "red", linewidth = 1) +
    geom_smooth(aes(x = grass_nonnative, y = seedling), method = "lm", se = TRUE, linetype = "dashed", color = "gray40", show.legend = TRUE)
  
fig_den_seedling

######## stats



#stats

# 1. Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(denspp_cover$grass_nonnative, 
         denspp_cover$seedling ) #t = -3.9103, df = 37, p-value = 0.0003794
# cor: -0.5407483 

# 2. Linear regression
model_lm <- lm(seedling ~ grass_nonnative, data = denspp_cover) 

# 3. Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
model_poly <- lm(seedling ~ poly(grass_nonnative, 2), data = denspp_cover)
summary(model_poly)

# 4. Generalized Additive Models (GAMs) - If you don’t want to assume the shape (e.g., parabola), GAMs let the data “decide” the curve:
model_gam <- gam(seedling ~ s(grass_nonnative), data = denspp_cover)
summary(model_gam)
plot(model_gam)

# 5. Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
model_seg <- segmented(lm(seedling ~ grass_nonnative, data = denspp_cover) , seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
summary(model_seg)
plot(model_seg)


### MODEL COMPARISON
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
AICseedling <- (AIC(model_lm, model_poly, model_gam, model_seg))
# Lower/more negative AIC = better fit.

# linear model is best fit


###################

# test residuals from linear model
residuals_lm_mature <- residuals(lm(mature ~ grass_nonnative, data = denspp_cover))
plot(fitted(model_lm) ~ residuals_lm_mature) # does not look random
testDispersion(simulateResiduals(
  lm(mature ~ grass_nonnative,
         data = denspp_cover, 
      family=gaussian))) # dispersion = 0.97308, p-value = 0.944

# Q-Q plot
qqnorm(residuals_lm_mature, main = "Q-Q Plot for Linear Model Residuals - Mature shrub density")
qqline(residuals_lm_mature, col = "red")
model_lm_res<- simulateResiduals(model_lm) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_lm_res) # 0.944


# Extract residuals from the poly model
residuals_poly_mature <- residuals(
  lm(mature ~ poly(grass_nonnative, 2), data = denspp_cover)
  )
plot(fitted(model_poly) ~ residuals_poly_mature) # looks kinda random
testDispersion(simulateResiduals(
  lm(mature ~ poly(grass_nonnative, 2), data = denspp_cover),
  
      family=gaussian)) # dispersion = 0.94678, p-value = 0.856

# Q-Q plot
qqnorm(residuals_poly_mature, main = "Q-Q Plot for Polynomial Model Residuals - nativegrass")
qqline(residuals_poly_mature, col = "red")
model_poly_mature_res<- simulateResiduals(
  lm(mature ~ poly(grass_nonnative, 2), data = denspp_cover)
) # → generates simulated residuals to check whether the model as a whole is consistent with the data (better for model diagnostics, especially outside simple linear regression).
plotQQunif(model_poly_mature_res) 


```


```{r}
# dead shrub density
fig_den_dead <- ggplot(denspp_cover,
       aes(x = grass_nonnative, 
           y = dead)) +

 geom_point(aes(color = cluster), size = 3, show.legend = TRUE) +
  scale_color_manual(values = c(colors_plantclusters)) +
   scale_x_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 10),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_y_continuous(
    limits = c(0, 3.5),
    breaks = seq(0, 3.5, by = .25),
    expand = expansion(mult = c(0, 0.05))
  ) +
  theme_bw()  +
  labs(
    x = "Non-native grass (%)",
    y = "Dead shrub density (m^2)",
     color = "Cluster") +
 
       stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "red", linewidth = 1) +
    geom_smooth(aes(x = grass_nonnative, y = dead), method = "lm", se = TRUE, linetype = "dashed", color = "gray40", show.legend = TRUE)
  

########### old code
#   left_join(shrub_leaftype, by = "species") %>%  # left join shrub_leaftype
#   mutate(lifestage = factor(lifestage, levels = c("seedling", "immature", "mature", "dead"))) %>% 
#   separate(site_rep, into = c("site", "rep"), sep = "_") %>% 
#    mutate(rep = case_when(rep == "1" ~ "01", # oldname ~ newname
#                          rep == "2" ~ "02",
#                          rep == "3" ~ "03",
#                          rep == "4" ~ "04",
#                          rep == "5" ~ "05",
#                          rep == "6" ~ "06",
#                          rep == "7" ~ "07",
#                          rep == "8" ~ "08",
#                          rep == "9" ~ "09",
#                               TRUE ~ rep)) %>% 
#    mutate(site_rep = paste(site, rep, sep = ".")) %>%
#    mutate(site_rep = case_when(site_rep == "INT1.01" ~ "INT1.1",
#                               site_rep == "INT2.01" ~ "INT2.1",
#                               site_rep == "INT3.01" ~ "INT3.1",
#                               site_rep == "INT4.01" ~ "INT4.1",
#                               site_rep == "INT5.01" ~ "INT5.1",
#                               TRUE ~ site_rep)) %>% 
#    left_join(groups %>%  dplyr::select(site_rep, cluster), by = "site_rep") 
# 
# denspp_cover_stats <- denspp_cover %>% 
#   group_by(cluster, species, lifestage) %>% 
#   summarise(mean_density_m2 = mean(density_m2)) %>% 
#   pivot_wider(names_from = lifestage, values_from = mean_density_m2)
# # view(denspp_cover_stats)
# 
# #################### bind shrub density WITHOUT shrub species
# density2019 <- shrubdensitylife_load %>% # group shrub density by lifestage
#   group_by(site_rep, lifestage) %>% 
#   summarise(sum_density_m2 = sum(density_m2)) # 75 rows
# density2024 <- shrubdensity_2024 %>%  
#   group_by(site_rep, lifestage) %>% 
#   summarise(sum_density_m2 = sum(density_m2)) # 104 rows
# density <- density2019 %>%  
#   bind_rows(density2024) # 179 rows
# density_cover <- height_cover %>%  # left join nn grass cover
#   dplyr::select(site, site_rep, grass_nonnative, shrub_native) %>% 
#   left_join(density, by = "site_rep") %>% 
#   filter(site_rep != "INT4_1") # omit INT4_1
# 
# 




```

```{r, eval = FALSE}

################################################################ 
##### other regression and correlation tests between nn grass cover and shrub cover


# Takeaway:
# Correlations
# Polynomial regression = test for simple curvature.
# GAMs = flexible non-linear trend.
# Piecewise regression = detect thresholds or breakpoints.
# Quantile regression = test upper/lower bounds of the relationship.

# Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(denspp_cover$grass_nonnative, 
         denspp_cover$seedling)

# linear regression
seddling <- lm(seedling ~ grass_nonnative, data = denspp_cover) 

# Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
seedling_poly <- lm(seedling ~ poly(grass_nonnative, 2), data = denspp_cover)
summary(seedling_poly)
  

# Generalized Additive Models (GAMs) - If you don’t want to assume the shape (e.g., parabola), GAMs let the data “decide” the curve:
seedling_gam <- gam(seedling ~ s(grass_nonnative), data = denspp_cover)
summary(seedling_gam)
plot(gam(seedling ~ s(grass_nonnative), data = denspp_cover))
# - GAMs are flexible and can capture non-linear but smooth patterns.
# - You can test significance of the smooth term (edf > 1 indicates non-linearity). <-- 8.247
## plot_gam code in next chunk


# Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
seedling_lm <- lm(seedling ~ grass_nonnative, data = denspp_cover) #linear regression (same as above)
seedling_seg <- segmented(seedling_lm, seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
# plot(segmented(model, seg.Z = ~grass_nonnative, 
#                npsi = 2)) # <- you can set the number of breakpoints here
summary(seedling_seg)
plot(seedling_seg)
# - This estimates a breakpoint 
# - You’ll get separate slopes before and after the threshold.

# Quantile Regression - Sometimes the average trend isn’t the full story — for example, shrubs may persist under moderate grass cover only in the “best-case” sites. Quantile regression shows how the relationship differs across the distribution of shrub cover.
seedling_qr <- rq(seedling ~ grass_nonnative, tau = 0.9, data = denspp_cover)
summary(seedling_qr)
# - This tests whether the upper limit of shrub cover declines with grass cover.


### Model Comparison
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
(AIC(seedling_lm, seedling_poly, seedling_gam, seedling_seg))
# Lower/more negative AIC = better fit.
# - GAM is best fit

```


```{r, eval = FALSE}

################################################################ 
##### other regression and correlation tests between nn grass cover and shrub cover


# Takeaway:
# Correlations
# Polynomial regression = test for simple curvature.
# GAMs = flexible non-linear trend.
# Piecewise regression = detect thresholds or breakpoints.
# Quantile regression = test upper/lower bounds of the relationship.

# Correlation - Compute a correlation coefficient to see if the two are associated
cor.test(denspp_cover$grass_nonnative, 
         denspp_cover$mature)

# linear regression
mature_lm <- lm(mature ~ grass_nonnative, data = denspp_cover)

# Polynomial Regression (Curvilinear Trends) - Fit a model where shrub cover changes in a curve (concave or convex) with grass cover.
mature_poly <- lm(mature ~ poly(grass_nonnative, 2), data = denspp_cover)
summary(mature_poly)
  

# Generalized Additive Models (GAMs) - If you don’t want to assume the shape (e.g., parabola), GAMs let the data “decide” the curve:
mature_gam <- gam(mature ~ s(grass_nonnative), data = denspp_cover)
summary(mature_gam)
plot(gam(mature ~ s(grass_nonnative), data = denspp_cover))
# - GAMs are flexible and can capture non-linear but smooth patterns.
# - You can test significance of the smooth term (edf > 1 indicates non-linearity). <-- 8.247
## plot_gam code in next chunk


# Threshold or Breakpoint Models (Piecewise Regression)
# Here you test whether there’s a breakpoint in grass cover where the relationship with shrubs changes slope:
 #linear regression (same as above)
mature_seg <- segmented(mature_lm, seg.Z = ~grass_nonnative,
                       npsi = 1) # one breakpoint
# plot(segmented(model, seg.Z = ~grass_nonnative, 
#                npsi = 2)) # <- you can set the number of breakpoints here
summary(mature_seg)
plot(mature_seg)
# - This estimates a breakpoint 
# - You’ll get separate slopes before and after the threshold.

# Quantile Regression - Sometimes the average trend isn’t the full story — for example, shrubs may persist under moderate grass cover only in the “best-case” sites. Quantile regression shows how the relationship differs across the distribution of shrub cover.
mature_qr <- rq(mature ~ grass_nonnative, tau = 0.9, data = denspp_cover)
summary(mature_qr)
# - This tests whether the upper limit of shrub cover declines with grass cover.


### Model Comparison
# To decide if non-linear/threshold models are “better” than linear:
# Compare models using AIC:
(AIC(mature_lm, mature_poly, mature_gam, mature_seg))
# Lower/more negative AIC = better fit.
# - GAM is best fit

```

### - density x species
```{r}
den_cluster <- denspp %>% 
  left_join(groupsdash, by = "site_rep") %>% 
  # filter(lifestage %in% c("seedling", "immature", "mature"), 
  #        species %in% c("Salvia leucophylla", "Malacothamnus fasciculatus")) %>% 
  group_by(cluster, lifestage,  species) %>% 
  summarize(
    sum_density_m2 = sum(density_m2), 
    .groups = "drop") %>% 
  filter(sum_density_m2 >0) %>% 
  pivot_wider(names_from = cluster, values_from = sum_density_m2)
  

den_cluster_recruitment <- denspp %>% 
  left_join(groupsdash, by = "site_rep") %>% 
  filter(lifestage %in% c("seedling", "immature")) %>% 
  group_by(cluster, species) %>% 
  summarize(
    sum_density_m2 = sum(density_m2), 
    .groups = "drop") %>% 
  pivot_wider(names_from = cluster, values_from = sum_density_m2)
```

### - species count x cluster
```{r}
den_spp_cluster <- denspp %>% 
  left_join(groupsdash, by = "site_rep") %>% 
  mutate(cluster = as.character(cluster)) %>% 
  mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) 


den_spp_cluster %>% 
  filter(cluster == "NNG") %>%  
  filter(lifestage == "seedling") %>% 
  filter(density_m2 > 0) # 1 transect
  

imm <- den_spp_cluster %>% 
  filter(cluster == "NNG") %>%  
  filter(lifestage == "immature") %>% 
  filter(density_m2 > 0) 

unique(imm$site_rep)

temp1 <- read_csv("deg_beltdensity_bylifestage.csv", 
                  col_types = cols(
                      site = col_character(),
                      transect = col_character(), 
                      species = col_character(), 
                      dead = col_integer(),
                      immature = col_integer(),
                      mature = col_integer(), 
                      resprout = col_integer(), 
                      seedling = col_integer()
                  )
 ) %>% 
     mutate(transect = ifelse(
         site == "INT2", "1", transect
     )) %>% 
     mutate(transect = ifelse(
         site == "INT3", "1", transect
     )) %>% 
     dplyr::select(-StandType, -hillslope) %>% 
     as_tibble() %>% 
     rename("rep" = "transect") %>% 
  
   tidyr::pivot_longer(
    cols = c(dead, immature, mature, resprout, seedling),
    names_to = "lifestage",
    values_to = "density_80m2")

temp2 <- read_csv("shrubdensity_2024.csv", 
      col_types = cols(
      site = col_character(),
      transect = col_character(), 
      species = col_character(), 
      lifestage = col_character(),
      density_80m2 = col_integer()
      )
      ) %>% 
  dplyr::select(site, transect, species, lifestage, density_80m2) %>% 
  rename("rep" = "transect") 

den_individual_shrubs <- temp1 %>% 
  full_join(temp2) %>% 
   mutate(site_rep = paste(site, rep, sep = "_")) %>% 
  left_join(groupsdash, by = "site_rep") %>% 
   mutate(cluster = as.character(cluster)) %>% 
  mutate(cluster = case_when(
                            cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
  mutate(density_1m2 = density_80m2/80,
         density_100m2 = (density_80m2/80)*100)
  
length(unique(den_individual_shrubs$site_rep)) # 39 transects

den_individual_shrubs %>% 
  dplyr::select(site_rep, species, lifestage, density_100m2, cluster) %>% 
  filter(cluster == "NNG" &  lifestage == "seedling")

den_individual_shrubs %>% 
  dplyr::select(cluster, site, rep, site_rep, lifestage, species, density_100m2) %>% 
  filter(cluster == "NNG" &  lifestage == "immature" & density_100m2 > 0)

den_individual_shrubs %>% 
  dplyr::select( site_rep, lifestage, species, cluster, density_100m2) %>% # seedling
  filter(cluster == "ssG" &  lifestage == "seedling" & density_100m2 > 0)

den_individual_shrubs %>% 
  dplyr::select(cluster, site, rep, site_rep, lifestage, species, density_100m2) %>% # immature
  filter(cluster == "ssG" &  lifestage == "immature" & density_100m2 > 0)

```


### linear models
```{r, eval = FALSE}

######################## shrub density - linear models
denspp_cover %>% 
  left_join(groupsdash, by = "site_rep")  
  
hist(denspp_cluster$sum_density_m2) # denspp_cover
shapiro.test(density_cover$sum_density_m2) # not normal

# # RUN this to test the residuals of the model you decide to use #########
# 
# plot(model.seedling)
# 
# qqnorm(residuals(model.seedling)) # run together
# qqline(residuals(model.seedling))



##################### seedling
# Fit the linear model: canopy height x nn grass cover
# a GLM is better for count data - negative binomial distribution
model.seedling <- glm.nb(sum_density_m2 ~ grass_nonnative, 
   data = density_cover %>% filter(lifestage == "seedling")) # response variable ~ independent variable
# AIC: 49.263 - AIC: 150.4 when I ran glm.nb(sum_density_m2 ~ grass_nonnative + lifestage)

# Print the summary of the model
model.seedling.summary <- summary(model.seedling)
# Summary of Fit:
# Pseudo R²: Offers insight into explained variance.
# AIC: Useful for comparing models.
# Residual Deviance: Should be close to degrees of freedom, which in your case, it is.
# Significance of predictors: Your predictor (grass_nonnative) is significant, indicating a strong relationship.
null_model <- glm.nb(sum_density_m2 ~ 1, data = density_cover %>% filter(lifestage == "seedling"))
pseudo_r2 <- 1 - (logLik(model.seedling) / logLik(null_model))
round(pseudo_r2, 3) # 'log Lik.' 0.1976203 (df=3)

model.seedling <- glm.nb(sum_density_m2 ~ grass_nonnative, 
   data = density_cover %>% filter(lifestage == "seedling"))
# Residual deviance: 24.132  on 33  degrees of freedom
# AIC: 47.985


##################### mature
model.mature <- glm.nb(sum_density_m2 ~ grass_nonnative, 
   data = density_cover %>% filter(lifestage == "mature"))
model.mature.summary <- summary(model.mature)
null_model2 <- glm.nb(sum_density_m2 ~ 1, 
                      data = density_cover %>% filter(lifestage == "mature"))
pseudo2_r2 <- 1 - (logLik(model.seedling) / logLik(null_model2))
round(pseudo2_r2, 3) # 'log Lik.' 0.045 (df=3)



ggplot(data = density_cover) + 
  geom_point(aes(x = grass_nonnative * 100, 
                 y = sum_density_m2)) +
 facet_wrap(~lifestage)



s <- ggplot(data = density_cover %>% filter(lifestage == "seedling")
       ) + 
  geom_point(aes(x = grass_nonnative * 100, 
                 y = sum_density_m2)) +
   labs(
  #  title = "Linear regression of non-native grass by sclerophyllous shrub percent cover"
    x = "Non-native grass cover (%)",
    y = "Shrub seedling density (#/m2)"
    ) +
   geom_smooth(data = density_cover %>% filter(lifestage == "seedling"),
              aes(x = grass_nonnative * 100, 
                  y = sum_density_m2, 
                  color = "black"), 
              method = "lm", se = TRUE, linetype = "solid", show.legend = TRUE) +
  theme_bw()


m <- ggplot(data = density_cover %>% filter(lifestage == "mature")
       ) + 
  geom_point(aes(x = grass_nonnative * 100, 
                 y = sum_density_m2)) +
  labs(
  #  title = "Linear regression of non-native grass by sclerophyllous shrub percent cover"
    x = "Non-native grass cover (%)",
    y = "Mature shrub density (#/m2)"
    ) + 
 geom_smooth(data = density_cover %>% filter(lifestage == "mature"),
              aes(x = grass_nonnative * 100, 
                  y = sum_density_m2, 
                  color = "black"), 
              method = "lm", se = TRUE, linetype = "solid", show.legend = TRUE) +
  theme_bw()


# Combine plots
grid.arrange(m, 
             s,
             nrow = 2, 
             ncol = 1, 
             widths = c(1), # Custom widths for each column
             heights = c(1, 1) # Custom heights for each row
             ) 

```

### stats by lifestage

```{r, eval = FALSE}

################################ calculate shrub density means by cluster (n = 40 transects)
density_cover_cluster %>%
 group_by(cluster) %>%
 summarise(count = length(unique(site_rep)))
# 1 = NNG: n = 10 transects
# 3 = ssG: n = 10 transects
# 2 = ssF: n = 7 transects
# 4 = ssFG: n = 8 transects
# 5 = EVG: n = 5 transects
# 

density_cover_cluster %>%
  filter(sum_density_m2 > 0) %>%
  group_by(lifestage) %>%
  summarise(count = length(lifestage))
#   n = 39 becuase we didn't collect belt transect data at INT4
#  dead         17 transects 
#  immature     27 transects
#  mature       35 transects <-- all belt transects had at least one mature shrub
#  no_shrubs     4 transects
#  seedling     21 transects


densitymeans_bycluster <- density_cover_cluster %>% # without shrub species
  mutate(cluster = factor(cluster, levels = c(1, 3, 2, 4, 5))) %>% 
  group_by(cluster, lifestage) %>% 
  dplyr::summarise(
    median_density = median(sum_density_m2, na.rm = TRUE), # <---- I'm calculating medians
    n = n_distinct(site_rep),
   sd = sd(sum_density_m2, na.rm = TRUE), # spread of data points
  #  se = sd / sqrt(n), # precision of data points
    median_sd = paste0(round(median_density, 2), " ± ", round(sd, 2))  # New column for formatted mean ± sd
  ) 




##############################  lifeform stats by cluster

# seedling
density_seedling <- density_cover_cluster %>%
  filter(lifestage == "seedling")

hist(density_seedling$sum_density_m2)
shapiro.test(density_seedling$sum_density_m2) # <- not normal

kruskal.test(sum_density_m2 ~ cluster, data = density_seedling)
# data:  sum_density_m2 by cluster
# Kruskal-Wallis chi-squared = 18.441, df = 4, p-value = 0.001012 <-- sig

pairwise.wilcox.test(density_seedling$sum_density_m2, 
                                      density_seedling$cluster,
                                      p.adjust.method = "bonferroni")
#  1        2      3      4     
# 2 0.0354  -      -      -     
# 3 1.0000  1.0000 -      -     
# 4 0.0031  1.0000 0.1013 -     
# 5 0.3021  1.0000 1.0000 1.0000
# 
# P value adjustment method: bonferroni 
# significance
# 1 a
# 3 ab
# 2 b
# 4 b
# 5 ab

density_seedling_sig <- density_seedling %>%
  mutate(
    seedlingsig = case_when(
      cluster == 1 ~ "a",
      cluster == 3 ~ "ab",
      cluster == 2 ~ "b",
      cluster == 4 ~ "b",
      cluster == 5 ~ "ab",
      TRUE ~ NA_character_  # Optional: fill with NA if no match
    )
  ) %>% 
  dplyr::select(cluster, seedlingsig)


# immature
density_immature <- density_cover_cluster %>%
  filter(lifestage == "immature")

hist(density_immature$sum_density_m2)
shapiro.test(density_immature$sum_density_m2) # <- not normal

kruskal.test(sum_density_m2 ~ cluster, data = density_seedling) 

pairwise.wilcox.test(density_immature$sum_density_m2, 
                                      density_immature$cluster,
                                      p.adjust.method = "bonferroni") # <- no sig
# data:  density_immature$sum_density_m2 and density_immature$cluster 
# 
#   1    2    3    4   
# 2 0.29 -    -    -   
# 3 1.00 0.54 -    -   
# 4 1.00 1.00 1.00 -   
# 5 0.18 1.00 0.69 1.00
# 
# P value adjustment method: bonferroni 
# significance
# 1 a
# 3 a
# 2 a
# 4 a
# 5 a


# mature
density_mature <- density_cover_cluster %>%
  filter(lifestage == "mature")
hist(density_mature$sum_density_m2)

shapiro.test(density_mature$sum_density_m2) # <- not normal

kruskal.test(sum_density_m2 ~ cluster, data = density_mature) 

pairwise.wilcox.test(density_mature$sum_density_m2, 
                                      density_mature$cluster,
                                      p.adjust.method = "bonferroni")
# data:  density_mature$sum_density_m2 and density_mature$cluster 
# 
#   1      2      3      4     
# 2 0.1154 -      -      -     
# 3 1.0000 0.2503 -      -     
# 4 0.0058 1.0000 0.4266 -     
# 5 0.2046 1.0000 0.4672 1.0000
# 
# P value adjustment method: bonferroni
# 
# significance
# 1 a
# 3 ab
# 2 ab
# 4 b
# 5 ab


# dead
density_dead <- density_cover_cluster %>%
  filter(lifestage == "dead")
hist(density_dead$sum_density_m2)

shapiro.test(density_dead$sum_density_m2) # <- not normal

kruskal.test(sum_density_m2 ~ cluster, data = density_dead) 

pairwise.wilcox.test(density_dead$sum_density_m2, 
                                      density_dead$cluster,
                                      p.adjust.method = "bonferroni")
# data:  density_dead$sum_density_m2 and density_dead$cluster 
# 
#   1      2      3      4     
# 2 0.0125 -      -      -     
# 3 1.0000 0.1131 -      -     
# 4 0.0856 1.0000 1.0000 -     
# 5 0.0095 1.0000 0.3553 1.0000
# 
# P value adjustment method: bonferroni 
# significance
# 1 a
# 3 ac
# 2 bc
# 4 ac
# 5 bc

###############. TABLE
    
densitymeans_bycluster_TABLE_prep <- densitymeans_bycluster %>% 
  dplyr::select(cluster, lifestage, median_sd) %>%  # Select relevant columns for the summary table
  pivot_wider(names_from = lifestage, values_from = median_sd) %>% 
  mutate(cluster = case_when(cluster == "1" ~ "NNG",
                             cluster == "3" ~ "ssG",
                             cluster == "2" ~ "ssF",
                             cluster == "4" ~ "ssFG",
                             cluster == "5" ~ "EVG",
                             TRUE ~ cluster)) %>% 
  mutate(
    seedlingsig = case_when(
      cluster == "NNG" ~ " (a)",
      cluster == "ssG" ~ " (ab)",
      cluster == "ssF" ~ " (b)",
      cluster == "ssFG" ~ " (b)",
      cluster == "EVG" ~ " (ab)",
      TRUE ~ NA_character_  # Optional: fill with NA if no match
    )
  ) %>% 
   mutate(Seedling = paste(seedling, seedlingsig, sep = "")) %>% 
  dplyr::select(-seedling, -seedlingsig, -no_shrubs, -"NA") %>% 
  relocate(Seedling, .after = cluster) %>% 
  filter(cluster %in% c("EVG", "NNG", "ssF", "ssFG", "ssG")) 
  


densitymeans_bycluster_TABLE <- densitymeans_bycluster_TABLE_prep %>% 
 # kable(caption = "Summary Table of Means ± SD for Each Cluster and Lifestage")
  flextable() %>%
  add_header_row(
  colwidths = c(1, 4),
  values = c("", "Shrub Lifestage")) %>% 
  set_header_labels(
    # Rename your columns if necessary
    cluster = "Cluster",
    seedling = "Seedling",
    immature = "Immature",
    Mature = "Mature",
    Dead = "Dead"
  ) %>%
  autofit() %>%
  set_caption(caption = "Shrub Density Median ± SD by Cluster and Lifestage")
  
# medians
densitymeans_bycluster_figure_original <- ggplot(densitymeans_bycluster %>%
         filter(lifestage %in% c("seedling", "immature", "mature", "dead")),
       aes(x = cluster, 
           y = median_density)) +
  geom_point(size = 3, position = position_dodge(width = 0.3)) +  
  geom_errorbar(aes(ymin = median_density - sd, ymax = median_density + sd), 
                width = 0.2, position = position_dodge(width = 0.3)) +  # SD bars
  labs(x = "Plant Cluster", 
       y = "Median Shrub Density (m2)") + 
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 1),  # Rotate x-axis labels if needed
    legend.position = "right") +
  ylim(0, 1) +
  facet_wrap(~lifestage) +  # Facet by lifeform
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG"))  # Relabel clusters



### sig letters for figure
density_sig_labels <-  bind_rows(
  # seedling density
  data.frame(
  cluster = c("1", "3", "2", "4", "5"),
  lifestage = "seedling",
  label = c("a", "ab", "b", "b", "ab"),
  y = c(0.0625, 0.211, 0.713, 1.32, 0.103)
   #  run this to find y placement --> densitymeans_bycluster %>% filter(lifestage == "seedling") %>% dplyr::select(median_density, sd) %>% mutate(max = median_density + sd + .05)
   ),
  # immature
  data.frame(
    cluster = c("1", "3", "2", "4", "5"),
    lifestage = "immature",
    label = c("a", "a", "a", "a", "a"),
    y = c(0.113, 0.165, 0.329, 0.437, 0.283)
     #  run this to find y placement --> densitymeans_bycluster %>% filter(lifestage == "immature") %>% dplyr::select(median_density, sd) %>% mutate(max = median_density + sd + .05)
  ),
    # mature
  data.frame(
   cluster = c("1", "3", "2", "4", "5"),
    lifestage = "mature",
    label = c("a", "ab", "ab", "b", "ab"),
    y = c(0.231, 0.303, 1.02, 0.692, 0.688)
     #  run this to find y placement --> densitymeans_bycluster %>% filter(lifestage == "mature") %>% dplyr::select(median_density, sd) %>% mutate(max = median_density + sd + .05)
  ), 
  # dead
 data.frame(
 cluster = c("1", "3", "2", "4", "5"),
    lifestage = "dead",
    label = c("a", "ac", "bc", "ac", "bc"),
    y = c(0.05, 0.0598, 1.26, 0.215, 0.200)
     #  run this to find y placement --> densitymeans_bycluster %>% filter(lifestage == "dead") %>% dplyr::select(median_density, sd) %>% mutate(max = median_density + sd + .05)
  )
 ) %>% 
   mutate(lifestage = factor(lifestage, levels = c("seedling", "immature", "mature", "dead")))
  
#### figure
densitymeans_bycluster_figure <- ggplot(densitymeans_bycluster %>%
         filter(lifestage %in% c("seedling", "immature", "mature", "dead")) %>% 
           mutate(lifestage = factor(lifestage, levels = c("seedling", "immature", "mature", "dead"))),
       aes(x = cluster, 
           y = median_density)) + 
  geom_point(size = 3, position = position_dodge(width = 0.3), show.legend = TRUE) +  
  geom_errorbar(aes(ymin = median_density - sd, ymax = median_density + sd), 
                width = 0.5, position = position_dodge(width = 0.3)) +  # SD bars
  
  geom_text(data = density_sig_labels,
          aes(x = cluster, y = y, label = label),
          inherit.aes = FALSE,
          size = 5) +
  
  labs(x = "Plant Cluster", 
       y = "Median Shrub Density (#/m2)"
       ) + 
  theme_bw() +
    theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 14),  # Rotate x-axis labels if needed
    # hjust = 0.5 = centered; 1 = right justified
    axis.text.y = element_text(size = 14),       # Increase y-axis text size
    axis.title = element_text(size = 16),        # Axis title size
    strip.text = element_text(size = 16),        # Facet label text size
    legend.text = element_text(size = 14),       # Legend text size
    legend.title = element_text(size = 14),      # Legend title size
    legend.position = "right"
  ) +
  ylim(-1.5, 1.5) +
  facet_grid(~lifestage) +  # Facet by lifeform
  scale_x_discrete(labels = c("1" = "NNG", "2" = "ssF", "3" = "ssG", "4" = "ssFG", "5" = "EVG"))  # Relabel clusters

densitymeans_bycluster_figure

```



```{r, eval = FALSE}
################# density figures

ggplot(data = density_cover %>% filter(sum_density_m2 > 0)) + 
  geom_point(aes(x = grass_nonnative * 100, 
                 y = sum_density_m2), 
             size = 3) +
  theme_bw() 

plot_denspp <- ggplot(data = denspp_cover %>% 
         filter(density_m2 > 0) %>% 
         filter(species != "unknown5 shrub") %>% 
         filter(leaftype == "nonsclero"), 
       aes(color = species, shape = site)) + 
  geom_point(aes(x = grass_nonnative * 100, 
                 y = density_m2), 
             size = 3) +
   scale_color_manual(values = c("darkolivegreen3", "green", "dodgerblue", "plum", "orange3", "pink", "purple", "purple4", "blue")) +
  theme_bw() +
  facet_grid(~ lifestage) +
  ylim(0,3)
plot_denspp

plot_denspp_scl <- ggplot(data = denspp_cover %>% 
         filter(density_m2 > 0) %>% 
         filter(species != "unknown5 shrub") %>% 
         filter(leaftype == "sclerophyllous"), 
       aes(color = species)) + 
  geom_point(aes(x = grass_nonnative * 100, 
                 y = density_m2), 
             size = 3) +
   scale_color_manual(values = c("dodgerblue", "darkolivegreen", "green", "red", "orchid")) +
  theme_bw() +
  facet_grid(~ lifestage) +
  ylim(0,3)
plot_denspp_scl

# Combine plots
grid.arrange(plot_denspp, 
             plot_denspp_scl,
             nrow = 2, 
             ncol = 1, 
             widths = c(1), # Custom widths for each column
             heights = c(1, 1) # Custom heights for each row
             ) 


```

# REGRESSIONS (cont.)
- x = non-native grass cover

```{r}

# data prep
cover_bylifecycle_wide <- cover_bylifecycle %>% 
  dplyr::select(site_rep, lifeform_lifecycle_status, lifeform_lifecycle_percentcover) %>% 
   pivot_wider(names_from = lifeform_lifecycle_status, values_from = lifeform_lifecycle_percentcover) %>% 
  rename("forb_or_vine_perennial_native" = "forb or vine_perennial_native") %>% 
  replace_na(replace = list(forb_perennial_native = 0, # Replace NA with 0 for each value column
                            forb_unknown2_unknown2 = 0,
                            grass_annual_nonnative = 0,
                            shrub_perennial_native = 0,
                            forb_annual_native = 0,
                            forb_annual_nonnative = 0,
                            grass_perennial_native = 0,
                            fern_perennial_native = 0,
                            forb_or_vine_perennial_native = 0
                            ))  %>% 
   separate(site_rep, into = c("site", "rep"), sep = "\\.") %>% 
   mutate(site_rep = paste(site, rep, sep = "_")) %>% 
  relocate(site_rep, .after = rep)
```

```{r}
# Quantile Regression - Sometimes the average trend isn’t the full story — for example, shrubs may persist under moderate grass cover only in the “best-case” sites. Quantile regression shows how the relationship differs across the distribution of shrub cover.
model_qr <- rq(forb_native ~ grass_nonnative, tau = 0.9, data = cover_bylfstatus_wide)
summary(model_qr)

# Intercept (0.144, CI: 0.003 – 1.032)
# When non-native grass cover = 0, the upper end (90th percentile) of native forb cover is very low (~0.14). The wide CI shows uncertainty, but the lower bound is still positive.

# Slope for grass_nonnative (0.026, CI: –0.84 to 0.25)
# The coefficient is positive but very small. Importantly, the confidence interval overlaps zero (–0.84 to 0.25), meaning there’s no statistically significant relationship between non-native grass cover and the upper bound of forb cover.

# Ecological interpretation
# 
# Unlike shrubs (where grasses clearly limit their maximum cover), native forbs don’t show a strong 90th percentile response.
# 
# This suggests that even at high grass cover, some stands can still maintain high forb cover, and the upper limit of forb abundance is not consistently constrained by grass dominance.
# 
# Forbs may be less sensitive to grass competition at the upper end of their distribution, perhaps because disturbance-tolerant forb species (e.g., Lupinus, Acmispon, Eschscholzia) can coexist with or even thrive under grass cover.
# 
# However, the wide CI indicates a lot of variability — forb responses might be patchy, species-specific, or context-dependent.

# In short:
# At the 90th percentile, native forb cover is not significantly related to non-native grass cover. Forbs appear more variable and less predictably constrained by grasses compared to shrubs.

```  
- y = annual native forb
```{r}
  
# native forb annuals x nn grass
                           

# original plot
ggplot(data = cover_bylifecycle_wide,
       aes(x = grass_annual_nonnative, 
         y = forb_annual_native)) + 
      geom_point(aes(color = site), size = 3) +
   scale_color_manual(values = c("blue", "blue", "maroon", "maroon", "maroon", "maroon", "maroon")) +
  # geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
  
  stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +
  
  labs(
    #  title = "Linear regression of  total shrub cover by non-native grass cover",
    x = "Non-native grass cover (%)",
    y = "Native annual forb cover (%)", 
     color = "Site"
    ) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  theme_bw() +
   theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 14),  # Rotate x-axis labels if needed
    # hjust = 0.5 = centered; 1 = right justified
    axis.text.y = element_text(size = 14),       # Increase y-axis text size
    axis.title = element_text(size = 16),        # Axis title size
    strip.text = element_text(size = 16),        # Facet label text size
    legend.text = element_text(size = 14),       # Legend text size
    legend.title = element_text(size = 14),      # Legend title size
    legend.position = "right"
  )

```

- y = perennial native forb
```{r}
  
# perennial forb annuals x nn grass
                           

# original plot
ggplot(data = cover_bylifecycle_wide,
       aes(x = grass_annual_nonnative, 
         y = forb_perennial_native)) + 
      geom_point(aes(color = site), size = 3) +
   scale_color_manual(values = c("blue", "blue", "maroon", "maroon", "maroon", "maroon", "maroon")) +
  # geom_smooth(method = "lm", se = TRUE, color = "gray50", linetype = "solid") + # se = confidence interval
  
  stat_smooth(method = "lm", formula = y ~ poly(x, 2), se = TRUE, color = "black", linewidth = 1) +
  
  labs(
    #  title = "Linear regression of  total shrub cover by non-native grass cover",
    x = "Non-native grass cover (%)",
    y = "Native perennial forb cover (%)", 
     color = "Site"
    ) +
  # scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set x-axis limits and breaks
  # scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 10)) + # Set y-axis limits and breaks
  theme_bw() +
   theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 14),  # Rotate x-axis labels if needed
    # hjust = 0.5 = centered; 1 = right justified
    axis.text.y = element_text(size = 14),       # Increase y-axis text size
    axis.title = element_text(size = 16),        # Axis title size
    strip.text = element_text(size = 16),        # Facet label text size
    legend.text = element_text(size = 14),       # Legend text size
    legend.title = element_text(size = 14),      # Legend title size
    legend.position = "right"
  )

```

# NATIVE SPP PERSIST
```{r}

# transects with >= 80% nn grass cover
nng80_list <- cover_bylifecycle_wide %>% 
  dplyr::select(site, rep, grass_annual_nonnative) %>% 
   mutate(rep = case_when(rep == "01" ~ "1", # oldname ~ newname
                         rep == "02" ~ "2",
                         rep == "03" ~ "3",
                         rep == "04" ~ "4",
                         rep == "05" ~ "5",
                         rep == "06" ~ "6",
                         rep == "07" ~ "7",
                         rep == "08" ~ "8",
                         rep == "09" ~ "9",
                              TRUE ~ rep)) %>% 
  filter(grass_annual_nonnative > 80) %>% 
   mutate(site_rep = paste(site, rep, sep = "_")) %>% 
  dplyr::select(site_rep)
 

# native species that persist with >= 80% nn grass cover
nng80_spp <- abcover_omitground %>%
  group_by(site_rep, species, lifeform, status, lifecycle, family, leaftype) %>% 
  summarize (n = length(species)) %>%
  mutate(percent_cover = round((n/41*100),2)) %>%
  ungroup() %>%
  dplyr::select(-n) %>%
  semi_join(nng80_list, by = "site_rep")  # <-- % cover of species
# length(unique(nng80_spp$site_rep))
# n = 18 transects

nng80_spp_distinct <- nng80_spp %>% 
  filter(status == "native") %>% 
  dplyr::select(species, lifeform, status, lifecycle, family) %>%
  distinct()

####################

# transects with >= 90% nn grass cover
nng90_list <- cover_bylifecycle_wide %>% 
  dplyr::select(site, rep, grass_annual_nonnative) %>% 
   mutate(rep = case_when(rep == "01" ~ "1", # oldname ~ newname
                         rep == "02" ~ "2",
                         rep == "03" ~ "3",
                         rep == "04" ~ "4",
                         rep == "05" ~ "5",
                         rep == "06" ~ "6",
                         rep == "07" ~ "7",
                         rep == "08" ~ "8",
                         rep == "09" ~ "9",
                              TRUE ~ rep)) %>% 
  filter(grass_annual_nonnative > 90) %>% 
   mutate(site_rep = paste(site, rep, sep = "_")) %>% 
  dplyr::select(site_rep)
 

# native species that persist with >= 80% nn grass cover
nng90_spp <- abcover_omitground %>%
  group_by(site_rep, species, lifeform, status, lifecycle, family, leaftype) %>% 
  summarize (n = length(species)) %>%
  mutate(percent_cover = round((n/41*100),2)) %>%
  ungroup() %>%
  dplyr::select(-n) %>%
  semi_join(nng90_list, by = "site_rep")  # <-- % cover of species
# length(unique(nng90_spp$site_rep))
# n = 12 transects

nng90_spp_distinct <- nng90_spp %>% 
  filter(status == "native") %>% 
  dplyr::select(species, lifeform, status, lifecycle, family) %>%
  distinct()

```




```{r}
print("yay! you've reached the end!")
```
